{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "definitions": {
        "AccessEntity": {
            "enum": [
                "any",
                "app",
                "user"
            ],
            "type": "string"
        },
        "AlternativesSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/AlternativesSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/AlternativesSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "AnySchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/AnySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/AnySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "ArrayBuffer": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "byteLength": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "byteLength"
            ],
            "type": "object"
        },
        "ArrayBufferLike": {
            "anyOf": [
                {
                    "$ref": "#/definitions/ArrayBuffer"
                },
                {
                    "$ref": "#/definitions/SharedArrayBuffer"
                }
            ]
        },
        "ArraySchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/ArraySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/ArraySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "AuroraMysqlConnectionOptions": {
            "description": "MySQL specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"typeorm-aurora-data-api-driver\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "formatOptions": {
                    "additionalProperties": {},
                    "properties": {
                        "castParameters": {
                            "type": "boolean"
                        }
                    },
                    "required": [
                        "castParameters"
                    ],
                    "type": "object"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "legacySpatialSupport": {
                    "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8.\n(Default: true)",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "region": {
                    "type": "string"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "resourceArn": {
                    "type": "string"
                },
                "secretArn": {
                    "type": "string"
                },
                "serviceConfigOptions": {
                    "additionalProperties": {},
                    "type": "object"
                },
                "ssl": {
                    "description": "Object with ssl parameters or a string containing name of ssl profile."
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "aurora-mysql",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "region",
                "resourceArn",
                "secretArn",
                "type"
            ],
            "type": "object"
        },
        "AuroraPostgresConnectionOptions": {
            "description": "Postgres-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"typeorm-aurora-data-api-driver\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "formatOptions": {
                    "additionalProperties": {},
                    "properties": {
                        "castParameters": {
                            "type": "boolean"
                        }
                    },
                    "required": [
                        "castParameters"
                    ],
                    "type": "object"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "poolErrorHandler": {
                    "type": "object"
                },
                "region": {
                    "type": "string"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "resourceArn": {
                    "type": "string"
                },
                "secretArn": {
                    "type": "string"
                },
                "serviceConfigOptions": {
                    "additionalProperties": {},
                    "type": "object"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "transformParameters": {
                    "type": "boolean"
                },
                "type": {
                    "const": "aurora-postgres",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "uuidExtension": {
                    "description": "The Postgres extension to use to generate UUID columns. Defaults to uuid-ossp.\nIf pgcrypto is selected, TypeORM will use the gen_random_uuid() function from this extension.\nIf uuid-ossp is selected, TypeORM will use the uuid_generate_v4() function from this extension.",
                    "enum": [
                        "pgcrypto",
                        "uuid-ossp"
                    ],
                    "type": "string"
                }
            },
            "required": [
                "database",
                "region",
                "resourceArn",
                "secretArn",
                "type"
            ],
            "type": "object"
        },
        "AuthMechanism": {
            "enum": [
                "DEFAULT",
                "GSSAPI",
                "MONGODB-AWS",
                "MONGODB-CR",
                "MONGODB-OIDC",
                "MONGODB-X509",
                "PLAIN",
                "SCRAM-SHA-1",
                "SCRAM-SHA-256"
            ],
            "type": "string"
        },
        "AuthMechanismProperties": {
            "properties": {
                "AWS_SESSION_TOKEN": {
                    "type": "string"
                },
                "CANONICALIZE_HOST_NAME": {
                    "enum": [
                        false,
                        "forward",
                        "forwardAndReverse",
                        "none",
                        true
                    ]
                },
                "PROVIDER_NAME": {
                    "const": "aws",
                    "type": "string"
                },
                "REFRESH_TOKEN_CALLBACK": {
                    "type": "object"
                },
                "REQUEST_TOKEN_CALLBACK": {
                    "type": "object"
                },
                "SERVICE_HOST": {
                    "type": "string"
                },
                "SERVICE_NAME": {
                    "type": "string"
                },
                "SERVICE_REALM": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "AutoEncrypter": {
            "properties": {
                "cryptSharedLibVersionInfo": {
                    "anyOf": [
                        {
                            "properties": {
                                "version": {
                                    "additionalProperties": false,
                                    "properties": {},
                                    "type": "number"
                                },
                                "versionStr": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "version",
                                "versionStr"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "null"
                        }
                    ]
                }
            },
            "required": [
                "cryptSharedLibVersionInfo"
            ],
            "type": "object"
        },
        "AutoEncryptionOptions": {
            "properties": {
                "bypassAutoEncryption": {
                    "description": "Allows the user to bypass auto encryption, maintaining implicit decryption",
                    "type": "boolean"
                },
                "bypassQueryAnalysis": {
                    "type": "boolean"
                },
                "encryptedFieldsMap": {
                    "$ref": "#/definitions/Document"
                },
                "extraOptions": {
                    "properties": {
                        "cryptSharedLibPath": {
                            "description": "Full path to a MongoDB Crypt shared library to be used (instead of mongocryptd).\n\nThis needs to be the path to the file itself, not a directory.\nIt can be an absolute or relative path. If the path is relative and\nits first component is `$ORIGIN`, it will be replaced by the directory\ncontaining the mongodb-client-encryption native addon file. Otherwise,\nthe path will be interpreted relative to the current working directory.\n\nCurrently, loading different MongoDB Crypt shared library files from different\nMongoClients in the same process is not supported.\n\nIf this option is provided and no MongoDB Crypt shared library could be loaded\nfrom the specified location, creating the MongoClient will fail.\n\nIf this option is not provided and `cryptSharedLibRequired` is not specified,\nthe AutoEncrypter will attempt to spawn and/or use mongocryptd according\nto the mongocryptd-specific `extraOptions` options.\n\nSpecifying a path prevents mongocryptd from being used as a fallback.\n\nRequires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.",
                            "type": "string"
                        },
                        "cryptSharedLibRequired": {
                            "description": "If specified, never use mongocryptd and instead fail when the MongoDB Crypt\nshared library could not be loaded.\n\nThis is always true when `cryptSharedLibPath` is specified.\n\nRequires the MongoDB Crypt shared library, available in MongoDB 6.0 or higher.",
                            "type": "boolean"
                        },
                        "mongocryptdBypassSpawn": {
                            "description": "If true, autoEncryption will not attempt to spawn a mongocryptd before connecting",
                            "type": "boolean"
                        },
                        "mongocryptdSpawnArgs": {
                            "description": "Command line arguments to use when auto-spawning a mongocryptd",
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "mongocryptdSpawnPath": {
                            "description": "The path to the mongocryptd executable on the system",
                            "type": "string"
                        },
                        "mongocryptdURI": {
                            "description": "A local process the driver communicates with to determine how to encrypt values in a command.\nDefaults to \"mongodb://%2Fvar%2Fmongocryptd.sock\" if domain sockets are available or \"mongodb://localhost:27020\" otherwise",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "keyVaultClient": {
                    "$ref": "#/definitions/MongoClient",
                    "description": "A `MongoClient` used to fetch keys from a key vault"
                },
                "keyVaultNamespace": {
                    "description": "The namespace where keys are stored in the key vault",
                    "type": "string"
                },
                "kmsProviders": {
                    "description": "Configuration options that are used by specific KMS providers during key generation, encryption, and decryption.",
                    "properties": {
                        "aws": {
                            "anyOf": [
                                {
                                    "properties": {
                                        "accessKeyId": {
                                            "description": "The access key used for the AWS KMS provider",
                                            "type": "string"
                                        },
                                        "secretAccessKey": {
                                            "description": "The secret access key used for the AWS KMS provider",
                                            "type": "string"
                                        },
                                        "sessionToken": {
                                            "description": "An optional AWS session token that will be used as the\nX-Amz-Security-Token header for AWS requests.",
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "accessKeyId",
                                        "secretAccessKey"
                                    ],
                                    "type": "object"
                                },
                                {
                                    "$ref": "#/definitions/Record<string,never>"
                                }
                            ],
                            "description": "Configuration options for using 'aws' as your KMS provider"
                        },
                        "azure": {
                            "anyOf": [
                                {
                                    "$ref": "#/definitions/Record<string,never>"
                                },
                                {
                                    "properties": {
                                        "clientId": {
                                            "description": "The client ID to authenticate a registered application",
                                            "type": "string"
                                        },
                                        "clientSecret": {
                                            "description": "The client secret to authenticate a registered application",
                                            "type": "string"
                                        },
                                        "identityPlatformEndpoint": {
                                            "description": "If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\nThis is optional, and only needed if customer is using a non-commercial Azure instance\n(e.g. a government or China account, which use different URLs).\nDefaults to \"login.microsoftonline.com\"",
                                            "type": "string"
                                        },
                                        "tenantId": {
                                            "description": "The tenant ID identifies the organization for the account",
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "clientId",
                                        "clientSecret",
                                        "tenantId"
                                    ],
                                    "type": "object"
                                },
                                {
                                    "properties": {
                                        "accessToken": {
                                            "description": "If present, an access token to authenticate with Azure.",
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "accessToken"
                                    ],
                                    "type": "object"
                                }
                            ],
                            "description": "Configuration options for using 'azure' as your KMS provider"
                        },
                        "gcp": {
                            "anyOf": [
                                {
                                    "$ref": "#/definitions/Record<string,never>"
                                },
                                {
                                    "properties": {
                                        "email": {
                                            "description": "The service account email to authenticate",
                                            "type": "string"
                                        },
                                        "endpoint": {
                                            "description": "If present, a host with optional port. E.g. \"example.com\" or \"example.com:443\".\nDefaults to \"oauth2.googleapis.com\"",
                                            "type": "string"
                                        },
                                        "privateKey": {
                                            "anyOf": [
                                                {
                                                    "additionalProperties": false,
                                                    "patternProperties": {
                                                        "^[0-9]+$": {
                                                            "type": "number"
                                                        }
                                                    },
                                                    "properties": {
                                                        "BYTES_PER_ELEMENT": {
                                                            "type": "number"
                                                        },
                                                        "__@toStringTag@25": {
                                                            "const": "Uint8Array",
                                                            "type": "string"
                                                        },
                                                        "buffer": {
                                                            "$ref": "#/definitions/ArrayBufferLike"
                                                        },
                                                        "byteLength": {
                                                            "type": "number"
                                                        },
                                                        "byteOffset": {
                                                            "type": "number"
                                                        },
                                                        "length": {
                                                            "type": "number"
                                                        }
                                                    },
                                                    "required": [
                                                        "BYTES_PER_ELEMENT",
                                                        "__@toStringTag@25",
                                                        "buffer",
                                                        "byteLength",
                                                        "byteOffset",
                                                        "length"
                                                    ],
                                                    "type": "object"
                                                },
                                                {
                                                    "type": "string"
                                                }
                                            ],
                                            "description": "A PKCS#8 encrypted key. This can either be a base64 string or a binary representation"
                                        }
                                    },
                                    "required": [
                                        "email",
                                        "privateKey"
                                    ],
                                    "type": "object"
                                },
                                {
                                    "properties": {
                                        "accessToken": {
                                            "description": "If present, an access token to authenticate with GCP.",
                                            "type": "string"
                                        }
                                    },
                                    "required": [
                                        "accessToken"
                                    ],
                                    "type": "object"
                                }
                            ],
                            "description": "Configuration options for using 'gcp' as your KMS provider"
                        },
                        "kmip": {
                            "description": "Configuration options for using 'kmip' as your KMS provider",
                            "properties": {
                                "endpoint": {
                                    "description": "The output endpoint string.\nThe endpoint consists of a hostname and port separated by a colon.\nE.g. \"example.com:123\". A port is always present.",
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        "local": {
                            "description": "Configuration options for using 'local' as your KMS provider",
                            "properties": {
                                "key": {
                                    "anyOf": [
                                        {
                                            "additionalProperties": false,
                                            "patternProperties": {
                                                "^[0-9]+$": {
                                                    "type": "number"
                                                }
                                            },
                                            "properties": {
                                                "BYTES_PER_ELEMENT": {
                                                    "type": "number"
                                                },
                                                "__@toStringTag@25": {
                                                    "const": "Uint8Array",
                                                    "type": "string"
                                                },
                                                "buffer": {
                                                    "$ref": "#/definitions/ArrayBufferLike"
                                                },
                                                "byteLength": {
                                                    "type": "number"
                                                },
                                                "byteOffset": {
                                                    "type": "number"
                                                },
                                                "length": {
                                                    "type": "number"
                                                }
                                            },
                                            "required": [
                                                "BYTES_PER_ELEMENT",
                                                "__@toStringTag@25",
                                                "buffer",
                                                "byteLength",
                                                "byteOffset",
                                                "length"
                                            ],
                                            "type": "object"
                                        },
                                        {
                                            "type": "string"
                                        }
                                    ],
                                    "description": "The master key used to encrypt/decrypt data keys.\nA 96-byte long Buffer or base64 encoded string."
                                }
                            },
                            "required": [
                                "key"
                            ],
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "options": {
                    "properties": {
                        "logger": {
                            "description": "An optional hook to catch logging messages from the underlying encryption engine",
                            "type": "object"
                        }
                    },
                    "type": "object"
                },
                "proxyOptions": {
                    "$ref": "#/definitions/ProxyOptions"
                },
                "schemaMap": {
                    "$ref": "#/definitions/Document",
                    "description": "A map of namespaces to a local JSON schema for encryption\n\n**NOTE**: Supplying options.schemaMap provides more security than relying on JSON Schemas obtained from the server.\nIt protects against a malicious server advertising a false JSON Schema, which could trick the client into sending decrypted data that should be encrypted.\nSchemas supplied in the schemaMap only apply to configuring automatic encryption for Client-Side Field Level Encryption.\nOther validation rules in the JSON schema will not be enforced by the driver and will result in an error."
                },
                "tlsOptions": {
                    "description": "The TLS options to use connecting to the KMS provider",
                    "properties": {
                        "aws": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "azure": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "gcp": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "kmip": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        },
                        "local": {
                            "$ref": "#/definitions/AutoEncryptionTlsOptions"
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "AutoEncryptionTlsOptions": {
            "properties": {
                "tlsCAFile": {
                    "description": "Specifies the location of a local .pem file that contains the\nroot certificate chain from the Certificate Authority.\nThis file is used to validate the certificate presented by the\nKMS provider.",
                    "type": "string"
                },
                "tlsCertificateKeyFile": {
                    "description": "Specifies the location of a local .pem file that contains\neither the client's TLS/SSL certificate and key or only the\nclient's TLS/SSL key when tlsCertificateFile is used to\nprovide the certificate.",
                    "type": "string"
                },
                "tlsCertificateKeyFilePassword": {
                    "description": "Specifies the password to de-crypt the tlsCertificateKeyFile.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "AwilixContainer<any>": {
            "description": "The container returned from createContainer has some methods and properties.",
            "properties": {
                "cache": {
                    "$ref": "#/definitions/Map<string|symbol,CacheEntry<any>>",
                    "description": "Resolved modules cache."
                },
                "cradle": {
                    "description": "The proxy injected when using `PROXY` injection mode.\nCan be used as-is."
                },
                "options": {
                    "$ref": "#/definitions/ContainerOptions",
                    "description": "Options the container was configured with."
                },
                "registrations": {
                    "additionalProperties": false,
                    "description": "Getter for the rolled up registrations that merges the container family tree.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "$ref": "#/definitions/Resolver<any>"
                        }
                    },
                    "type": "object"
                }
            },
            "required": [
                "cache",
                "cradle",
                "options",
                "registrations"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryAccessTokenAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "token": {
                            "description": "A user need to provide `token` which they retrieved else where\nto forming the connection.",
                            "type": "string"
                        }
                    },
                    "required": [
                        "token"
                    ],
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-access-token",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryDefaultAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "clientId": {
                            "description": "The clientId of the user you want to log in with, mapped to the managedIdentityClientId in tedious",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-default",
                    "description": "This uses DefaultAzureCredential from",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryMsiAppServiceAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "clientId": {
                            "description": "If you user want to connect to an Azure app service using a specific client account\nthey need to provide `clientId` associate to their created identity.\n\nThis is optional for retrieve token from azure web app service",
                            "type": "string"
                        },
                        "msiEndpoint": {
                            "description": "A msi app service environment need to provide `msiEndpoint` for retriving the accesstoken.",
                            "type": "string"
                        },
                        "msiSecret": {
                            "description": "A msi app service environment need to provide `msiSecret` for retrieved the accesstoken.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-msi-app-service",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryMsiVmAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "clientId": {
                            "description": "If you user want to connect to an Azure app service using a specific client account\nthey need to provide `clientId` associate to their created identity.\n\nThis is optional for retrieve token from azure web app service",
                            "type": "string"
                        },
                        "msiEndpoint": {
                            "description": "A user need to provide `msiEndpoint` for retrieving the accesstoken.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-msi-vm",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryPasswordAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "domain": {
                            "description": "Optional parameter for specific Azure tenant ID",
                            "type": "string"
                        },
                        "password": {
                            "description": "A user need to provide `password` associate to their account.",
                            "type": "string"
                        },
                        "userName": {
                            "description": "A user need to provide `userName` associate to their account.",
                            "type": "string"
                        }
                    },
                    "required": [
                        "domain",
                        "password",
                        "userName"
                    ],
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-password",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "AzureActiveDirectoryServicePrincipalSecret": {
            "properties": {
                "options": {
                    "properties": {
                        "clientId": {
                            "description": "Application (`client`) ID from your registered Azure application",
                            "type": "string"
                        },
                        "clientSecret": {
                            "description": "The created `client secret` for this registered Azure application",
                            "type": "string"
                        },
                        "tenantId": {
                            "description": "Directory (`tenant`) ID from your registered Azure application",
                            "type": "string"
                        }
                    },
                    "required": [
                        "clientId",
                        "clientSecret",
                        "tenantId"
                    ],
                    "type": "object"
                },
                "type": {
                    "const": "azure-active-directory-service-principal-secret",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "BSONSerializeOptions": {
            "description": "BSON Serialization options.",
            "properties": {
                "bsonRegExp": {
                    "description": "return BSON regular expressions as BSONRegExp instances.",
                    "type": "boolean"
                },
                "checkKeys": {
                    "description": "the serializer will check if keys are valid.",
                    "type": "boolean"
                },
                "enableUtf8Validation": {
                    "description": "Enable utf8 validation when deserializing BSON documents.  Defaults to true.",
                    "type": "boolean"
                },
                "fieldsAsRaw": {
                    "$ref": "#/definitions/Document",
                    "description": "allow to specify if there what fields we wish to return as unserialized raw buffer."
                },
                "ignoreUndefined": {
                    "description": "serialize will not emit undefined fields **(default:true)**",
                    "type": "boolean"
                },
                "promoteBuffers": {
                    "description": "when deserializing a Binary will return it as a node.js Buffer instance.",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "when deserializing a Long will fit it into a Number if it's smaller than 53 bits.",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "when deserializing will promote BSON values to their Node.js closest equivalent types.",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "serializeFunctions": {
                    "description": "serialize the javascript functions **(default:false)**.",
                    "type": "boolean"
                },
                "useBigInt64": {
                    "description": "when deserializing a Long will return as a BigInt.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "BaseCrudController": {
            "oneOf": [
                {
                    "$ref": "#/definitions/ItemController"
                }
            ]
        },
        "BaseCrudService": {
            "oneOf": [
                {
                    "$ref": "#/definitions/ItemService"
                }
            ]
        },
        "BaseCrudSqlRepository": {
            "properties": {
                "create": {
                    "type": "object"
                },
                "dataSource": {
                    "$ref": "#/definitions/DataSource"
                },
                "delete": {
                    "type": "object"
                },
                "entityName": {
                    "type": "string"
                },
                "findBy": {
                    "type": "object"
                },
                "findByIdOrFail": {
                    "type": "object"
                },
                "getRepository": {
                    "type": "object"
                },
                "update": {
                    "type": "object"
                }
            },
            "required": [
                "create",
                "dataSource",
                "delete",
                "entityName",
                "findBy",
                "findByIdOrFail",
                "getRepository",
                "update"
            ],
            "type": "object"
        },
        "BaseDataSourceOptions": {
            "description": "BaseDataSourceOptions is set of DataSourceOptions shared by all database types.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "$ref": "#/definitions/DatabaseType",
                    "description": "Database type. This value is required."
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "BetterSqlite3ConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Storage type or path to the storage.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"better-sqlite3\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "enableWAL": {
                    "description": "Enables WAL mode. By default its disabled.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "fileMustExist": {
                    "description": "If the database does not exist, an Error will be thrown instead of creating a new file.\nThis option does not affect in-memory or readonly database connections.\nDefault: false.",
                    "type": "boolean"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "key": {
                    "description": "Encryption key for for SQLCipher.",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "nativeBinding": {
                    "description": "Relative or absolute path to the native addon (better_sqlite3.node).",
                    "type": "string"
                },
                "prepareDatabase": {
                    "description": "Function to run before a database is used in typeorm.\nYou can set pragmas, register plugins or register\nfunctions or aggregates in this function.",
                    "type": "object"
                },
                "readonly": {
                    "description": "Open the database connection in readonly mode.\nDefault: false.",
                    "type": "boolean"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "statementCacheSize": {
                    "description": "Cache size of sqlite statement to speed up queries.\nDefault: 100.",
                    "type": "number"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "timeout": {
                    "description": "The number of milliseconds to wait when executing queries\non a locked database, before throwing a SQLITE_BUSY error.\nDefault: 5000.",
                    "type": "number"
                },
                "type": {
                    "const": "better-sqlite3",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "verbose": {
                    "$ref": "#/definitions/Function",
                    "description": "Provide a function that gets called with every SQL string executed by the database connection."
                }
            },
            "required": [
                "database",
                "type"
            ],
            "type": "object"
        },
        "BinarySchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/BinarySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/BinarySchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "BodyValidator": {
            "type": "object"
        },
        "Boolean": {
            "type": "object"
        },
        "BooleanConstructor": {
            "properties": {
                "prototype": {
                    "$ref": "#/definitions/Boolean"
                }
            },
            "required": [
                "prototype"
            ],
            "type": "object"
        },
        "BooleanSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/BooleanSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/BooleanSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "Broadcaster": {
            "description": "Broadcaster provides a helper methods to broadcast events to the subscribers.",
            "properties": {
                "queryRunner": {}
            },
            "required": [
                "queryRunner"
            ],
            "type": "object"
        },
        "CapacitorConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name (capacitor-sqlite will add the suffix `SQLite.db`)",
                    "type": "string"
                },
                "driver": {
                    "description": "The capacitor-sqlite instance. For example, `new SQLiteConnection(CapacitorSQLite)`."
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "journalMode": {
                    "description": "The SQLite journal mode (optional)",
                    "enum": [
                        "DELETE",
                        "MEMORY",
                        "OFF",
                        "PERSIST",
                        "TRUNCATE",
                        "WAL"
                    ],
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "mode": {
                    "description": "Set the mode for database encryption",
                    "enum": [
                        "encryption",
                        "newsecret",
                        "no-encryption",
                        "secret"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "capacitor",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "version": {
                    "description": "Database version",
                    "type": "number"
                }
            },
            "required": [
                "database",
                "driver",
                "type"
            ],
            "type": "object"
        },
        "CheckMetadata": {
            "description": "Check metadata contains all information about table's check constraints.",
            "properties": {
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the class to which this check constraint is applied."
                },
                "expression": {
                    "description": "Check expression.",
                    "type": "string"
                },
                "givenName": {
                    "description": "User specified check constraint name.",
                    "type": "string"
                },
                "name": {
                    "description": "Final check constraint name.\nIf check constraint name was given by a user then it stores normalized (by naming strategy) givenName.\nIf check constraint name was not given then its generated.",
                    "type": "string"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                }
            },
            "required": [
                "entityMetadata",
                "expression",
                "name"
            ],
            "type": "object"
        },
        "ClientApi<any>": {
            "description": "Client API\nThe Client object provides the following methods:",
            "type": "object"
        },
        "ClientMetadata": {
            "properties": {
                "application": {
                    "properties": {
                        "name": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "name"
                    ],
                    "type": "object"
                },
                "driver": {
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "name",
                        "version"
                    ],
                    "type": "object"
                },
                "os": {
                    "properties": {
                        "architecture": {
                            "type": "string"
                        },
                        "name": {
                            "$ref": "#/definitions/global.NodeJS.Platform"
                        },
                        "type": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "architecture",
                        "name",
                        "type",
                        "version"
                    ],
                    "type": "object"
                },
                "platform": {
                    "type": "string"
                }
            },
            "required": [
                "driver",
                "os",
                "platform"
            ],
            "type": "object"
        },
        "ClientOptions": {
            "properties": {
                "partition": {
                    "description": "this will store items under keys that start with this value.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ClosureTreeOptions": {
            "properties": {
                "ancestorColumnName": {
                    "type": "object"
                },
                "closureTableName": {
                    "type": "string"
                },
                "descendantColumnName": {
                    "type": "object"
                }
            },
            "type": "object"
        },
        "CockroachConnectionCredentialsOptions": {
            "description": "Cockroachdb specific connection credential options.",
            "properties": {
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "ssl": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TlsOptions"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Object with ssl parameters"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "CockroachConnectionOptions": {
            "description": "Cockroachdb-specific connection options.",
            "properties": {
                "applicationName": {
                    "description": "sets the application_name var to help db administrators identify\nthe service using this connection. Defaults to 'undefined'",
                    "type": "string"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to `require(\"pg\")`."
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "maxTransactionRetries": {
                    "description": "Max number of transaction retries in case of 40001 error.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "nativeDriver": {
                    "description": "The driver object\nThis defaults to `require(\"pg-native\")`."
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "poolErrorHandler": {
                    "description": "Function handling errors thrown by drivers pool.\nDefaults to logging error with `warn` level.",
                    "type": "object"
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "defaultMode": {
                            "default": "slave",
                            "description": "Default connection pool to use for SELECT queries",
                            "enum": [
                                "master",
                                "slave"
                            ],
                            "type": "string"
                        },
                        "master": {
                            "$ref": "#/definitions/CockroachConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/CockroachConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "schema": {
                    "description": "Schema name.",
                    "type": "string"
                },
                "ssl": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TlsOptions"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Object with ssl parameters"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "timeTravelQueries": {
                    "description": "Enable time travel queries on cockroachdb.\nhttps://www.cockroachlabs.com/docs/stable/as-of-system-time.html",
                    "type": "boolean"
                },
                "type": {
                    "const": "cockroachdb",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "timeTravelQueries",
                "type"
            ],
            "type": "object"
        },
        "ColumnMetadata": {
            "description": "This metadata contains all information about entity's column.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "asExpression": {
                    "description": "Generated column expression.",
                    "type": "string"
                },
                "charset": {
                    "description": "Defines column character set.",
                    "type": "string"
                },
                "closureType": {
                    "description": "Column type in the case if this column is in the closure table.\nColumn can be ancestor or descendant in the closure tables.",
                    "enum": [
                        "ancestor",
                        "descendant"
                    ],
                    "type": "string"
                },
                "collation": {
                    "description": "Defines column collation.",
                    "type": "string"
                },
                "comment": {
                    "description": "Column comment.\nThis feature is not supported by all databases.",
                    "type": "string"
                },
                "databaseName": {
                    "description": "Complete column name in the database including its embedded prefixes.",
                    "type": "string"
                },
                "databaseNameWithoutPrefixes": {
                    "description": "Database name in the database without embedded prefixes applied.",
                    "type": "string"
                },
                "databasePath": {
                    "description": "Gets full path to this column database name (including column database name).\nFull path is relevant when column is used in embeds (one or multiple nested).\nFor example it will return \"counters.subcounters.likes\".\nIf property is not in embeds then it returns just database name of the column.",
                    "type": "string"
                },
                "default": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Record<string,object>"
                        },
                        {
                            "items": {
                                "type": [
                                    "string",
                                    "number",
                                    "boolean"
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": [
                                "null",
                                "string",
                                "number",
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "Default database value."
                },
                "embeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Embedded metadata where this column metadata is.\nIf this column is not in embed then this property value is undefined."
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata where this column metadata is.\n\nFor example for"
                },
                "enum": {
                    "description": "Array of possible enumerated values.\n\n`postgres` and `mysql` store enum values as strings but we want to keep support\nfor numeric and heterogeneous based typescript enums, so we need (string|number)[]",
                    "items": {
                        "type": [
                            "string",
                            "number"
                        ]
                    },
                    "type": "array"
                },
                "enumName": {
                    "description": "Exact name of enum",
                    "type": "string"
                },
                "foreignKeyConstraintName": {
                    "description": "If this column is foreign key then this specifies the name for it.",
                    "type": "string"
                },
                "generatedIdentity": {
                    "description": "Identity column type. Supports only in Postgres 10+.",
                    "enum": [
                        "ALWAYS",
                        "BY DEFAULT"
                    ],
                    "type": "string"
                },
                "generatedType": {
                    "description": "Generated column type.",
                    "enum": [
                        "STORED",
                        "VIRTUAL"
                    ],
                    "type": "string"
                },
                "generationStrategy": {
                    "description": "Specifies generation strategy if this column will use auto increment.",
                    "enum": [
                        "increment",
                        "rowid",
                        "uuid"
                    ],
                    "type": "string"
                },
                "givenDatabaseName": {
                    "description": "Database name set by entity metadata builder, not yet passed naming strategy process and without embedded prefixes.",
                    "type": "string"
                },
                "hstoreType": {
                    "description": "Return type of HSTORE column.\nReturns value as string or as object.",
                    "enum": [
                        "object",
                        "string"
                    ],
                    "type": "string"
                },
                "isArray": {
                    "description": "Indicates if this column is an array.",
                    "type": "boolean"
                },
                "isCreateDate": {
                    "description": "Indicates if this column contains an entity creation date.",
                    "type": "boolean"
                },
                "isDeleteDate": {
                    "description": "Indicates if this column contains an entity delete date.",
                    "type": "boolean"
                },
                "isDiscriminator": {
                    "description": "Indicates if column is discriminator. Discriminator columns are not mapped to the entity.",
                    "type": "boolean"
                },
                "isGenerated": {
                    "description": "Indicates if this column is generated (auto increment or generated other way).",
                    "type": "boolean"
                },
                "isInsert": {
                    "description": "Indicates if column is inserted by default or not.",
                    "type": "boolean"
                },
                "isMaterializedPath": {
                    "description": "Indicates if this column is materialized path's path column.\nUsed only in tree entities with materialized path type.",
                    "type": "boolean"
                },
                "isNestedSetLeft": {
                    "description": "Indicates if this column is nested set's left column.\nUsed only in tree entities with nested-set type.",
                    "type": "boolean"
                },
                "isNestedSetRight": {
                    "description": "Indicates if this column is nested set's right column.\nUsed only in tree entities with nested-set type.",
                    "type": "boolean"
                },
                "isNullable": {
                    "description": "Indicates if column can contain nulls or not.",
                    "type": "boolean"
                },
                "isObjectId": {
                    "description": "Indicates if this column contains an object id.",
                    "type": "boolean"
                },
                "isPrimary": {
                    "description": "Indicates if this column is a primary key.",
                    "type": "boolean"
                },
                "isSelect": {
                    "description": "Indicates if column is selected by query builder or not.",
                    "type": "boolean"
                },
                "isTreeLevel": {
                    "description": "Indicates if column is tree-level column. Tree-level columns are used in closure entities.",
                    "type": "boolean"
                },
                "isUpdate": {
                    "description": "Indicates if column allows updates or not.",
                    "type": "boolean"
                },
                "isUpdateDate": {
                    "description": "Indicates if this column contains an entity update date.",
                    "type": "boolean"
                },
                "isVersion": {
                    "description": "Indicates if this column contains an entity version.",
                    "type": "boolean"
                },
                "isVirtual": {
                    "description": "Indicates if column is virtual. Virtual columns are not mapped to the entity.",
                    "type": "boolean"
                },
                "isVirtualProperty": {
                    "description": "Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\nThis property is used in tandem the virtual column decorator.",
                    "type": "boolean"
                },
                "length": {
                    "description": "Type's length in the database.",
                    "type": "string"
                },
                "onUpdate": {
                    "description": "ON UPDATE trigger. Works only for MySQL.",
                    "type": "string"
                },
                "precision": {
                    "description": "The precision for a decimal (exact numeric) column (applies only for decimal column),\nwhich is the maximum number of digits that are stored for the values.",
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "primaryKeyConstraintName": {
                    "description": "If this column is primary key then this specifies the name for it.",
                    "type": "string"
                },
                "propertyAliasName": {
                    "description": "Same as property path, but dots are replaced with '_'.\nUsed in query builder statements.",
                    "type": "string"
                },
                "propertyName": {
                    "description": "Class's property name on which this column is applied.",
                    "type": "string"
                },
                "propertyPath": {
                    "description": "Gets full path to this column property (including column property name).\nFull path is relevant when column is used in embeds (one or multiple nested).\nFor example it will return \"counters.subcounters.likes\".\nIf property is not in embeds then it returns just property name of the column.",
                    "type": "string"
                },
                "query": {
                    "description": "Query to be used to populate the column data. This query is used when generating the relational db script.\nThe query function is called with the current entities alias either defined by the Entity Decorator or automatically",
                    "type": "object"
                },
                "referencedColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "If this column is foreign key then it references some other column,\nand this property will contain reference to this column."
                },
                "relationMetadata": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "If column is a foreign key of some relation then this relation's metadata will be there.\nIf this column does not have a foreign key then this property value is undefined."
                },
                "scale": {
                    "description": "The scale for a decimal (exact numeric) column (applies only for decimal column),\nwhich represents the number of digits to the right of the decimal point and must not be greater than precision.",
                    "type": "number"
                },
                "spatialFeatureType": {
                    "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)",
                    "type": "string"
                },
                "srid": {
                    "description": "SRID (Spatial Reference ID (EPSG code))",
                    "type": "number"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class where column decorator is used.\nThis may not be always equal to entity metadata (for example embeds or inheritance cases)."
                },
                "transformer": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValueTransformer"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValueTransformer"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Specifies a value transformer that is to be used to (un)marshal\nthis column when reading or writing to the database."
                },
                "type": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "The database type of the column."
                },
                "unsigned": {
                    "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL.",
                    "type": "boolean"
                },
                "width": {
                    "description": "Type's display width in the database.",
                    "type": "number"
                },
                "zerofill": {
                    "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\nIf you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column",
                    "type": "boolean"
                }
            },
            "required": [
                "@instanceof",
                "databaseName",
                "databaseNameWithoutPrefixes",
                "databasePath",
                "entityMetadata",
                "isArray",
                "isCreateDate",
                "isDeleteDate",
                "isDiscriminator",
                "isGenerated",
                "isInsert",
                "isMaterializedPath",
                "isNestedSetLeft",
                "isNestedSetRight",
                "isNullable",
                "isObjectId",
                "isPrimary",
                "isSelect",
                "isTreeLevel",
                "isUpdate",
                "isUpdateDate",
                "isVersion",
                "isVirtual",
                "isVirtualProperty",
                "length",
                "propertyAliasName",
                "propertyName",
                "propertyPath",
                "target",
                "type",
                "unsigned",
                "zerofill"
            ],
            "type": "object"
        },
        "ColumnOptions": {
            "description": "Describes all column's options.",
            "properties": {
                "array": {
                    "description": "Indicates if this column is an array.\nCan be simply set to true or array length can be specified.\nSupported only by postgres.",
                    "type": "boolean"
                },
                "asExpression": {
                    "description": "Generated column expression.",
                    "type": "string"
                },
                "charset": {
                    "description": "Defines a column character set.\nNot supported by all database types.",
                    "type": "string"
                },
                "collation": {
                    "description": "Defines a column collation.",
                    "type": "string"
                },
                "comment": {
                    "description": "Column comment. Not supported by all database types.",
                    "type": "string"
                },
                "default": {
                    "description": "Default database value."
                },
                "enum": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Object"
                        },
                        {
                            "items": {
                                "type": [
                                    "string",
                                    "number"
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Array of possible enumerated values."
                },
                "enumName": {
                    "description": "Exact name of enum",
                    "type": "string"
                },
                "foreignKeyConstraintName": {
                    "description": "If this column is foreign key then this specifies the name for it.",
                    "type": "string"
                },
                "generated": {
                    "description": "Specifies if this column will use auto increment (sequence, generated identity, rowid).\nNote that in some databases only one column in entity can be marked as generated, and it must be a primary column.",
                    "enum": [
                        false,
                        "identity",
                        "increment",
                        "rowid",
                        true,
                        "uuid"
                    ]
                },
                "generatedIdentity": {
                    "description": "Identity column type. Supports only in Postgres 10+.",
                    "enum": [
                        "ALWAYS",
                        "BY DEFAULT"
                    ],
                    "type": "string"
                },
                "generatedType": {
                    "description": "Generated column type.",
                    "enum": [
                        "STORED",
                        "VIRTUAL"
                    ],
                    "type": "string"
                },
                "hstoreType": {
                    "description": "Return type of HSTORE column.\nReturns value as string or as object.",
                    "enum": [
                        "object",
                        "string"
                    ],
                    "type": "string"
                },
                "insert": {
                    "description": "Indicates if column is inserted by default.\nDefault value is \"true\".",
                    "type": "boolean"
                },
                "length": {
                    "description": "Column type's length. Used only on some column types.\nFor example type = \"string\" and length = \"100\" means that ORM will create a column with type varchar(100).",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "name": {
                    "description": "Column name in the database.",
                    "type": "string"
                },
                "nullable": {
                    "description": "Indicates if column's value can be set to NULL.\nDefault value is \"false\".",
                    "type": "boolean"
                },
                "onUpdate": {
                    "description": "ON UPDATE trigger. Works only for MySQL.",
                    "type": "string"
                },
                "precision": {
                    "description": "The precision for a decimal (exact numeric) column (applies only for decimal column), which is the maximum\nnumber of digits that are stored for the values.",
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "primary": {
                    "description": "Indicates if this column is a primary key.\nSame can be achieved when",
                    "type": "boolean"
                },
                "primaryKeyConstraintName": {
                    "description": "If this column is primary key then this specifies the name for it.",
                    "type": "string"
                },
                "readonly": {
                    "description": "Indicates if column value is not updated by \"save\" operation.\nIt means you'll be able to write this value only when you first time insert the object.\nDefault value is \"false\".",
                    "type": "boolean"
                },
                "scale": {
                    "description": "The scale for a decimal (exact numeric) column (applies only for decimal column), which represents the number\nof digits to the right of the decimal point and must not be greater than precision.",
                    "type": "number"
                },
                "select": {
                    "description": "Indicates if column is always selected by QueryBuilder and find operations.\nDefault value is \"true\".",
                    "type": "boolean"
                },
                "spatialFeatureType": {
                    "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)",
                    "type": "string"
                },
                "srid": {
                    "description": "SRID (Spatial Reference ID (EPSG code))",
                    "type": "number"
                },
                "transformer": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ValueTransformer"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ValueTransformer"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Specifies a value transformer that is to be used to (un)marshal\nthis column when reading or writing to the database."
                },
                "type": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/StringConstructor"
                        },
                        {
                            "$ref": "#/definitions/BooleanConstructor"
                        },
                        {
                            "$ref": "#/definitions/NumberConstructor"
                        },
                        {
                            "$ref": "#/definitions/DateConstructor"
                        },
                        {
                            "enum": [
                                "alphanum",
                                "array",
                                "bfile",
                                "bigint",
                                "binary",
                                "bit",
                                "bit varying",
                                "blob",
                                "bool",
                                "boolean",
                                "box",
                                "bytea",
                                "bytes",
                                "char",
                                "char varying",
                                "character",
                                "character varying",
                                "cidr",
                                "circle",
                                "citext",
                                "clob",
                                "cube",
                                "date",
                                "datemultirange",
                                "daterange",
                                "datetime",
                                "datetime2",
                                "datetimeoffset",
                                "dec",
                                "decimal",
                                "double",
                                "double precision",
                                "enum",
                                "fixed",
                                "float",
                                "float4",
                                "float64",
                                "float8",
                                "geography",
                                "geometry",
                                "geometrycollection",
                                "hierarchyid",
                                "hstore",
                                "image",
                                "inet",
                                "inet4",
                                "inet6",
                                "int",
                                "int2",
                                "int4",
                                "int4multirange",
                                "int4range",
                                "int64",
                                "int8",
                                "int8multirange",
                                "int8range",
                                "integer",
                                "interval",
                                "interval day to second",
                                "interval year to month",
                                "json",
                                "jsonb",
                                "line",
                                "linestring",
                                "long",
                                "long raw",
                                "longblob",
                                "longtext",
                                "lseg",
                                "ltree",
                                "macaddr",
                                "mediumblob",
                                "mediumint",
                                "mediumtext",
                                "money",
                                "multilinestring",
                                "multipoint",
                                "multipolygon",
                                "national char",
                                "national varchar",
                                "native character",
                                "nchar",
                                "nclob",
                                "ntext",
                                "number",
                                "numeric",
                                "nummultirange",
                                "numrange",
                                "nvarchar",
                                "nvarchar2",
                                "path",
                                "point",
                                "polygon",
                                "raw",
                                "real",
                                "rowid",
                                "rowversion",
                                "seconddate",
                                "set",
                                "shorttext",
                                "simple-array",
                                "simple-enum",
                                "simple-json",
                                "smalldatetime",
                                "smalldecimal",
                                "smallint",
                                "smallmoney",
                                "sql_variant",
                                "st_geometry",
                                "st_point",
                                "string",
                                "text",
                                "time",
                                "time with time zone",
                                "time without time zone",
                                "timestamp",
                                "timestamp with local time zone",
                                "timestamp with time zone",
                                "timestamp without time zone",
                                "timestamptz",
                                "timetz",
                                "tinyblob",
                                "tinyint",
                                "tinytext",
                                "tsmultirange",
                                "tsquery",
                                "tsrange",
                                "tstzmultirange",
                                "tstzrange",
                                "tsvector",
                                "uniqueidentifier",
                                "unsigned big int",
                                "urowid",
                                "uuid",
                                "varbinary",
                                "varbit",
                                "varchar",
                                "varchar2",
                                "varying character",
                                "xml",
                                "year"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Column type. Must be one of the value from the ColumnTypes class."
                },
                "unique": {
                    "description": "Specifies if column's value must be unique or not.",
                    "type": "boolean"
                },
                "unsigned": {
                    "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL.",
                    "type": "boolean"
                },
                "update": {
                    "description": "Indicates if column value is updated by \"save\" operation.\nIf false, you'll be able to write this value only when you first time insert the object.\nDefault value is \"true\".",
                    "type": "boolean"
                },
                "width": {
                    "description": "Column type's display width. Used only on some column types in MySQL.\nFor example, INT(4) specifies an INT with a display width of four digits.",
                    "type": "number"
                },
                "zerofill": {
                    "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\nIf you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to this column",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "ColumnType": {
            "anyOf": [
                {
                    "$ref": "#/definitions/StringConstructor"
                },
                {
                    "$ref": "#/definitions/BooleanConstructor"
                },
                {
                    "$ref": "#/definitions/NumberConstructor"
                },
                {
                    "$ref": "#/definitions/DateConstructor"
                },
                {
                    "enum": [
                        "alphanum",
                        "array",
                        "bfile",
                        "bigint",
                        "binary",
                        "bit",
                        "bit varying",
                        "blob",
                        "bool",
                        "boolean",
                        "box",
                        "bytea",
                        "bytes",
                        "char",
                        "char varying",
                        "character",
                        "character varying",
                        "cidr",
                        "circle",
                        "citext",
                        "clob",
                        "cube",
                        "date",
                        "datemultirange",
                        "daterange",
                        "datetime",
                        "datetime2",
                        "datetimeoffset",
                        "dec",
                        "decimal",
                        "double",
                        "double precision",
                        "enum",
                        "fixed",
                        "float",
                        "float4",
                        "float64",
                        "float8",
                        "geography",
                        "geometry",
                        "geometrycollection",
                        "hierarchyid",
                        "hstore",
                        "image",
                        "inet",
                        "inet4",
                        "inet6",
                        "int",
                        "int2",
                        "int4",
                        "int4multirange",
                        "int4range",
                        "int64",
                        "int8",
                        "int8multirange",
                        "int8range",
                        "integer",
                        "interval",
                        "interval day to second",
                        "interval year to month",
                        "json",
                        "jsonb",
                        "line",
                        "linestring",
                        "long",
                        "long raw",
                        "longblob",
                        "longtext",
                        "lseg",
                        "ltree",
                        "macaddr",
                        "mediumblob",
                        "mediumint",
                        "mediumtext",
                        "money",
                        "multilinestring",
                        "multipoint",
                        "multipolygon",
                        "national char",
                        "national varchar",
                        "native character",
                        "nchar",
                        "nclob",
                        "ntext",
                        "number",
                        "numeric",
                        "nummultirange",
                        "numrange",
                        "nvarchar",
                        "nvarchar2",
                        "path",
                        "point",
                        "polygon",
                        "raw",
                        "real",
                        "rowid",
                        "rowversion",
                        "seconddate",
                        "set",
                        "shorttext",
                        "simple-array",
                        "simple-enum",
                        "simple-json",
                        "smalldatetime",
                        "smalldecimal",
                        "smallint",
                        "smallmoney",
                        "sql_variant",
                        "st_geometry",
                        "st_point",
                        "string",
                        "text",
                        "time",
                        "time with time zone",
                        "time without time zone",
                        "timestamp",
                        "timestamp with local time zone",
                        "timestamp with time zone",
                        "timestamp without time zone",
                        "timestamptz",
                        "timetz",
                        "tinyblob",
                        "tinyint",
                        "tinytext",
                        "tsmultirange",
                        "tsquery",
                        "tsrange",
                        "tstzmultirange",
                        "tstzrange",
                        "tsvector",
                        "uniqueidentifier",
                        "unsigned big int",
                        "urowid",
                        "uuid",
                        "varbinary",
                        "varbit",
                        "varchar",
                        "varchar2",
                        "varying character",
                        "xml",
                        "year"
                    ],
                    "type": "string"
                }
            ],
            "description": "Any column type column can be."
        },
        "ContainerOptions": {
            "description": "The options for the createContainer function.",
            "properties": {
                "injectionMode": {
                    "description": "Injection mode type.",
                    "enum": [
                        "CLASSIC",
                        "PROXY"
                    ],
                    "type": "string"
                },
                "require": {
                    "type": "object"
                },
                "strict": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Context": {
            "additionalProperties": {},
            "properties": {
                "key": {
                    "type": "string"
                },
                "label": {
                    "type": "string"
                },
                "value": {}
            },
            "type": "object"
        },
        "CordovaConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to `window.sqlitePlugin`"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "location": {
                    "description": "Storage Location",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "cordova",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "location",
                "type"
            ],
            "type": "object"
        },
        "CteCapabilities": {
            "properties": {
                "enabled": {
                    "description": "Are CTEs supported at all?",
                    "type": "boolean"
                },
                "materializedHint": {
                    "description": "Is MATERIALIZED clause supported?",
                    "type": "boolean"
                },
                "requiresRecursiveHint": {
                    "description": "Is RECURSIVE clause required for recursive CTEs?",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Are RETURNING clauses supported in CTEs?",
                    "type": "boolean"
                }
            },
            "required": [
                "enabled"
            ],
            "type": "object"
        },
        "CustomError": {
            "properties": {
                "e": {
                    "$ref": "#/definitions/Error"
                },
                "httpCode": {
                    "default": 500,
                    "type": "number"
                },
                "message": {},
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "required": [
                "httpCode",
                "message",
                "name"
            ],
            "type": "object"
        },
        "DataSource": {
            "description": "DataSource is a pre-defined connection configuration to a specific database.\nYou can have multiple data sources connected (with multiple connections in it),\nconnected to multiple databases in your application.\n\nBefore, it was called `Connection`, but now `Connection` is deprecated\nbecause `Connection` isn't the best name for what it's actually is.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "driver": {
                    "$ref": "#/definitions/Driver",
                    "description": "Database driver used by this connection."
                },
                "entityMetadatas": {
                    "description": "All entity metadatas that are registered for this connection.",
                    "items": {
                        "$ref": "#/definitions/EntityMetadata"
                    },
                    "type": "array"
                },
                "entityMetadatasMap": {
                    "$ref": "#/definitions/Map<EntityTarget<any>,EntityMetadata>",
                    "description": "All entity metadatas that are registered for this connection.\nThis is a copy of #.entityMetadatas property -> used for more performant searches."
                },
                "isConnected": {
                    "description": "Indicates if DataSource is initialized or not.",
                    "type": "boolean"
                },
                "isInitialized": {
                    "description": "Indicates if DataSource is initialized or not.",
                    "type": "boolean"
                },
                "logger": {
                    "$ref": "#/definitions/Logger",
                    "description": "Logger used to log orm events."
                },
                "manager": {
                    "$ref": "#/definitions/EntityManager",
                    "description": "EntityManager of this connection."
                },
                "metadataTableName": {
                    "description": "Name for the metadata table",
                    "type": "string"
                },
                "migrations": {
                    "description": "Migration instances that are registered for this connection.",
                    "items": {
                        "$ref": "#/definitions/MigrationInterface"
                    },
                    "type": "array"
                },
                "mongoManager": {
                    "$ref": "#/definitions/MongoEntityManager",
                    "description": "Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\nwith any entity in this connection.\n\nAvailable only in mongodb connections."
                },
                "name": {
                    "description": "Connection name.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy used in the connection."
                },
                "options": {
                    "$ref": "#/definitions/DataSourceOptions",
                    "description": "Connection options."
                },
                "queryResultCache": {
                    "$ref": "#/definitions/QueryResultCache",
                    "description": "Used to work with query result cache."
                },
                "relationIdLoader": {
                    "$ref": "#/definitions/RelationIdLoader"
                },
                "relationLoader": {
                    "$ref": "#/definitions/RelationLoader",
                    "description": "Used to load relations and work with lazy relations."
                },
                "sqljsManager": {
                    "$ref": "#/definitions/SqljsEntityManager",
                    "description": "Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n\nAvailable only in connection with the sqljs driver."
                },
                "subscribers": {
                    "description": "Entity subscriber instances that are registered for this connection.",
                    "items": {
                        "$ref": "#/definitions/EntitySubscriberInterface<any>"
                    },
                    "type": "array"
                }
            },
            "required": [
                "@instanceof",
                "driver",
                "entityMetadatas",
                "entityMetadatasMap",
                "isConnected",
                "isInitialized",
                "logger",
                "manager",
                "metadataTableName",
                "migrations",
                "mongoManager",
                "name",
                "namingStrategy",
                "options",
                "relationIdLoader",
                "relationLoader",
                "sqljsManager",
                "subscribers"
            ],
            "type": "object"
        },
        "DataSourceOptions": {
            "anyOf": [
                {
                    "$ref": "#/definitions/CockroachConnectionOptions"
                },
                {
                    "$ref": "#/definitions/MysqlConnectionOptions"
                },
                {
                    "$ref": "#/definitions/PostgresConnectionOptions"
                },
                {
                    "$ref": "#/definitions/SqliteConnectionOptions"
                },
                {
                    "$ref": "#/definitions/SqlServerConnectionOptions"
                },
                {
                    "$ref": "#/definitions/OracleConnectionOptions"
                },
                {
                    "$ref": "#/definitions/MongoConnectionOptions"
                },
                {
                    "$ref": "#/definitions/CordovaConnectionOptions"
                },
                {
                    "$ref": "#/definitions/SqljsConnectionOptions"
                },
                {
                    "$ref": "#/definitions/ReactNativeConnectionOptions"
                },
                {
                    "$ref": "#/definitions/NativescriptConnectionOptions"
                },
                {
                    "$ref": "#/definitions/ExpoConnectionOptions"
                },
                {
                    "$ref": "#/definitions/AuroraMysqlConnectionOptions"
                },
                {
                    "$ref": "#/definitions/SapConnectionOptions"
                },
                {
                    "$ref": "#/definitions/AuroraPostgresConnectionOptions"
                },
                {
                    "$ref": "#/definitions/BetterSqlite3ConnectionOptions"
                },
                {
                    "$ref": "#/definitions/CapacitorConnectionOptions"
                },
                {
                    "$ref": "#/definitions/SpannerConnectionOptions"
                }
            ],
            "description": "DataSourceOptions is an interface with settings and options for specific DataSource."
        },
        "DataTypeDefaults": {
            "additionalProperties": {
                "properties": {
                    "length": {
                        "type": "number"
                    },
                    "precision": {
                        "type": "number"
                    },
                    "scale": {
                        "type": "number"
                    },
                    "width": {
                        "type": "number"
                    }
                },
                "type": "object"
            },
            "type": "object"
        },
        "DataView": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "buffer": {
                    "$ref": "#/definitions/ArrayBuffer"
                },
                "byteLength": {
                    "type": "number"
                },
                "byteOffset": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "buffer",
                "byteLength",
                "byteOffset"
            ],
            "type": "object"
        },
        "DatabaseType": {
            "description": "Database type.",
            "enum": [
                "aurora-mysql",
                "aurora-postgres",
                "better-sqlite3",
                "capacitor",
                "cockroachdb",
                "cordova",
                "expo",
                "mariadb",
                "mongodb",
                "mssql",
                "mysql",
                "nativescript",
                "oracle",
                "postgres",
                "react-native",
                "sap",
                "spanner",
                "sqlite",
                "sqljs"
            ],
            "type": "string"
        },
        "DateConstructor": {
            "properties": {
                "prototype": {
                    "format": "date-time",
                    "type": "string"
                }
            },
            "required": [
                "prototype"
            ],
            "type": "object"
        },
        "DateSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/DateSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/DateSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "DefaultAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "password": {
                            "description": "Password to use for sql server login.",
                            "type": "string"
                        },
                        "userName": {
                            "description": "User name to use for sql server login.",
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "type": {
                    "const": "default",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "Document": {
            "additionalProperties": {},
            "type": "object"
        },
        "Driver": {
            "description": "Driver organizes TypeORM communication with specific database management system.",
            "properties": {
                "cteCapabilities": {
                    "$ref": "#/definitions/CteCapabilities"
                },
                "dataTypeDefaults": {
                    "$ref": "#/definitions/DataTypeDefaults",
                    "description": "Default values of length, precision and scale depends on column data type.\nUsed in the cases when length/precision/scale is not specified by user."
                },
                "database": {
                    "description": "Database name used to perform all write queries.\n\ntodo: probably move into query runner.",
                    "type": "string"
                },
                "dummyTableName": {
                    "description": "Dummy table name",
                    "type": "string"
                },
                "isReplicated": {
                    "description": "Indicates if replication is enabled.",
                    "type": "boolean"
                },
                "mappedDataTypes": {
                    "$ref": "#/definitions/MappedColumnTypes",
                    "description": "Orm has special columns and we need to know what database column types should be for those types.\nColumn types are driver dependant."
                },
                "maxAliasLength": {
                    "description": "Max length allowed by the DBMS for aliases (execution of queries).",
                    "type": "number"
                },
                "options": {
                    "$ref": "#/definitions/BaseDataSourceOptions",
                    "description": "Connection options."
                },
                "parametersPrefix": {
                    "description": "The prefix used for the parameters",
                    "type": "string"
                },
                "schema": {
                    "description": "Schema name used to perform all write queries.",
                    "type": "string"
                },
                "spatialTypes": {
                    "description": "Gets list of spatial column data types.",
                    "items": {
                        "$ref": "#/definitions/ColumnType"
                    },
                    "type": "array"
                },
                "supportedDataTypes": {
                    "description": "Gets list of supported column data types by a driver.",
                    "items": {
                        "$ref": "#/definitions/ColumnType"
                    },
                    "type": "array"
                },
                "supportedOnDeleteTypes": {
                    "description": "Returns list of supported onDelete types by driver",
                    "items": {
                        "$ref": "#/definitions/OnDeleteType"
                    },
                    "type": "array"
                },
                "supportedOnUpdateTypes": {
                    "description": "Returns list of supported onUpdate types by driver",
                    "items": {
                        "$ref": "#/definitions/OnUpdateType"
                    },
                    "type": "array"
                },
                "supportedUpsertTypes": {
                    "description": "Returns type of upsert supported by driver if any",
                    "items": {
                        "$ref": "#/definitions/UpsertType"
                    },
                    "type": "array"
                },
                "transactionSupport": {
                    "description": "Represent transaction support by this driver",
                    "enum": [
                        "nested",
                        "none",
                        "simple"
                    ],
                    "type": "string"
                },
                "treeSupport": {
                    "description": "Indicates if tree tables are supported by this driver.",
                    "type": "boolean"
                },
                "version": {
                    "description": "Database version/release. Often requires a SQL query to the DB, so it is not always set",
                    "type": "string"
                },
                "withLengthColumnTypes": {
                    "description": "Gets list of column data types that support length by a driver.",
                    "items": {
                        "$ref": "#/definitions/ColumnType"
                    },
                    "type": "array"
                },
                "withPrecisionColumnTypes": {
                    "description": "Gets list of column data types that support precision by a driver.",
                    "items": {
                        "$ref": "#/definitions/ColumnType"
                    },
                    "type": "array"
                },
                "withScaleColumnTypes": {
                    "description": "Gets list of column data types that support scale by a driver.",
                    "items": {
                        "$ref": "#/definitions/ColumnType"
                    },
                    "type": "array"
                }
            },
            "required": [
                "cteCapabilities",
                "dataTypeDefaults",
                "isReplicated",
                "mappedDataTypes",
                "options",
                "spatialTypes",
                "supportedDataTypes",
                "supportedUpsertTypes",
                "transactionSupport",
                "treeSupport",
                "withLengthColumnTypes",
                "withPrecisionColumnTypes",
                "withScaleColumnTypes"
            ],
            "type": "object"
        },
        "DriverInfo": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "platform": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Duplex": {
            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
                    "type": "boolean"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "allowHalfOpen",
                "closed",
                "destroyed",
                "errored",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "EmbeddedMetadata": {
            "description": "Contains all information about entity's embedded property.",
            "properties": {
                "columns": {
                    "description": "Columns inside this embed.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "columnsFromTree": {
                    "description": "Embed metadatas from all levels of the parent tree.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\nthis method will return [embed metadata of data, embed metadata of information, embed metadata of counters]",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "customPrefix": {
                    "description": "Prefix of the embedded, used instead of propertyName.\nIf set to empty string or false, then prefix is not set at all.",
                    "type": [
                        "string",
                        "boolean"
                    ]
                },
                "embeddedMetadataTree": {
                    "description": "Returns embed metadatas from all levels of the parent tree.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\nthis method will return [embed metadata of data, embed metadata of information, embed metadata of counters]",
                    "items": {
                        "$ref": "#/definitions/EmbeddedMetadata"
                    },
                    "type": "array"
                },
                "embeddeds": {
                    "description": "Nested embeddable in this embeddable (which has current embedded as parent embedded).",
                    "items": {
                        "$ref": "#/definitions/EmbeddedMetadata"
                    },
                    "type": "array"
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata where this embedded is."
                },
                "indices": {
                    "description": "Indices applied to the embed columns.",
                    "items": {
                        "$ref": "#/definitions/IndexMetadata"
                    },
                    "type": "array"
                },
                "indicesFromTree": {
                    "description": "Indices of this embed and all indices from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/IndexMetadata"
                    },
                    "type": "array"
                },
                "isAlwaysUsingConstructor": {
                    "description": "Indicates if the entity should be instantiated using the constructor\nor via allocating a new object via `Object.create()`.",
                    "type": "boolean"
                },
                "isArray": {
                    "description": "Indicates if this embedded is in array mode.\n\nThis option works only in mongodb.",
                    "type": "boolean"
                },
                "listeners": {
                    "description": "Entity listeners inside this embed.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "listenersFromTree": {
                    "description": "Relations of this embed and all relations from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "parentEmbeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Parent embedded in the case if this embedded inside other embedded."
                },
                "parentPrefixes": {
                    "description": "Returns array of prefixes of current embed and all its parent embeds.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "parentPropertyNames": {
                    "description": "Returns array of property names of current embed and all its parent embeds.\n\nexample: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeds\nwe need to get value of \"id\" column from the post real entity object.\nthis method will return [\"data\", \"information\", \"counters\"]",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "prefix": {
                    "description": "Gets the prefix of the columns.\nBy default its a property name of the class where this prefix is.\nBut if custom prefix is set then it takes its value as a prefix.\nHowever if custom prefix is set to empty string or false, then prefix to column is not applied at all.",
                    "type": "string"
                },
                "propertyName": {
                    "description": "Property name on which this embedded is attached.",
                    "type": "string"
                },
                "propertyPath": {
                    "description": "Gets full path to this embedded property (including embedded property name).\nFull path is relevant when embedded is used inside other embeds (one or multiple nested).\nFor example it will return \"counters.subcounters\".",
                    "type": "string"
                },
                "relationCounts": {
                    "description": "Relation counts inside this embed.",
                    "items": {
                        "$ref": "#/definitions/RelationCountMetadata"
                    },
                    "type": "array"
                },
                "relationCountsFromTree": {
                    "description": "Relation counts of this embed and all relation counts from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/RelationCountMetadata"
                    },
                    "type": "array"
                },
                "relationIds": {
                    "description": "Relation ids inside this embed.",
                    "items": {
                        "$ref": "#/definitions/RelationIdMetadata"
                    },
                    "type": "array"
                },
                "relationIdsFromTree": {
                    "description": "Relation ids of this embed and all relation ids from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/RelationIdMetadata"
                    },
                    "type": "array"
                },
                "relations": {
                    "description": "Relations inside this embed.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "relationsFromTree": {
                    "description": "Relations of this embed and all relations from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "type": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Embedded target type."
                },
                "uniques": {
                    "description": "Uniques applied to the embed columns.",
                    "items": {
                        "$ref": "#/definitions/UniqueMetadata"
                    },
                    "type": "array"
                },
                "uniquesFromTree": {
                    "description": "Uniques of this embed and all uniques from its child embeds.",
                    "items": {
                        "$ref": "#/definitions/UniqueMetadata"
                    },
                    "type": "array"
                }
            },
            "required": [
                "columns",
                "columnsFromTree",
                "embeddedMetadataTree",
                "embeddeds",
                "entityMetadata",
                "indices",
                "indicesFromTree",
                "isAlwaysUsingConstructor",
                "isArray",
                "listeners",
                "listenersFromTree",
                "parentPrefixes",
                "parentPropertyNames",
                "prefix",
                "propertyName",
                "propertyPath",
                "relationCounts",
                "relationCountsFromTree",
                "relationIds",
                "relationIdsFromTree",
                "relations",
                "relationsFromTree",
                "type",
                "uniques",
                "uniquesFromTree"
            ],
            "type": "object"
        },
        "EnginePrototype<any>": {
            "description": "A prototype CatBox engine function",
            "type": "object"
        },
        "EntityListenerMetadata": {
            "description": "This metadata contains all information about entity's listeners.",
            "properties": {
                "embeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Embedded metadata of the listener, in the case if listener is in embedded."
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the listener."
                },
                "propertyName": {
                    "description": "Target's property name to which this metadata is applied.",
                    "type": "string"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied.\nThis can be different then entityMetadata.target in the case if listener is in the embedded."
                },
                "type": {
                    "$ref": "#/definitions/EventListenerType",
                    "description": "The type of the listener."
                }
            },
            "required": [
                "entityMetadata",
                "propertyName",
                "target",
                "type"
            ],
            "type": "object"
        },
        "EntityManager": {
            "description": "Entity manager supposed to work with any entity, automatically find its repository and call its methods,\nwhatever entity type are you passing.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "callAggregateFun": {},
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection used by this entity manager."
                },
                "plainObjectToEntityTransformer": {
                    "$ref": "#/definitions/PlainObjectToNewEntityTransformer",
                    "description": "Plain to object transformer used in create and merge operations."
                },
                "queryRunner": {
                    "$ref": "#/definitions/QueryRunner",
                    "description": "Custom query runner to be used for operations in this entity manager.\nUsed only in non-global entity manager."
                },
                "repositories": {
                    "$ref": "#/definitions/Map<EntityTarget<any>,Repository<any>>",
                    "description": "Once created and then reused by repositories.\nCreated as a future replacement for the #repositories to provide a bit more perf optimization."
                },
                "treeRepositories": {
                    "description": "Once created and then reused by repositories.",
                    "items": {
                        "$ref": "#/definitions/TreeRepository<any>"
                    },
                    "type": "array"
                }
            },
            "required": [
                "@instanceof",
                "callAggregateFun",
                "connection",
                "plainObjectToEntityTransformer",
                "repositories",
                "treeRepositories"
            ],
            "type": "object"
        },
        "EntityMetadata": {
            "description": "Contains all entity metadata.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "afterInsertListeners": {
                    "description": "Listener metadatas with \"AFTER INSERT\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "afterLoadListeners": {
                    "description": "Listener metadatas with \"AFTER LOAD\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "afterRecoverListeners": {
                    "description": "Listener metadatas with \"AFTER RECOVER\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "afterRemoveListeners": {
                    "description": "Listener metadatas with \"AFTER REMOVE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "afterSoftRemoveListeners": {
                    "description": "Listener metadatas with \"AFTER SOFT REMOVE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "afterUpdateListeners": {
                    "description": "Listener metadatas with \"AFTER UPDATE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "allEmbeddeds": {
                    "description": "All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.",
                    "items": {
                        "$ref": "#/definitions/EmbeddedMetadata"
                    },
                    "type": "array"
                },
                "ancestorColumns": {
                    "description": "Ancestor columns used only in closure junction tables.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "beforeInsertListeners": {
                    "description": "Listener metadatas with \"BEFORE INSERT\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "beforeRecoverListeners": {
                    "description": "Listener metadatas with \"BEFORE RECOVER\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "beforeRemoveListeners": {
                    "description": "Listener metadatas with \"BEFORE REMOVE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "beforeSoftRemoveListeners": {
                    "description": "Listener metadatas with \"BEFORE SOFT REMOVE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "beforeUpdateListeners": {
                    "description": "Listener metadatas with \"BEFORE UPDATE\" type.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "checks": {
                    "description": "Entity's check metadatas.",
                    "items": {
                        "$ref": "#/definitions/CheckMetadata"
                    },
                    "type": "array"
                },
                "childEntityMetadatas": {
                    "description": "Children entity metadatas. Used in inheritance patterns.",
                    "items": {
                        "$ref": "#/definitions/EntityMetadata"
                    },
                    "type": "array"
                },
                "closureJunctionTable": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "If entity's table is a closure-typed table, then this entity will have a closure junction table metadata."
                },
                "columns": {
                    "description": "Columns of the entity, including columns that are coming from the embeddeds of this entity.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "comment": {
                    "description": "Table comment. Not supported by all database types.",
                    "type": "string"
                },
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection where this entity metadata is created."
                },
                "createDateColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets entity column which contains a create date value."
                },
                "database": {
                    "description": "Database name.",
                    "type": "string"
                },
                "deleteDateColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets entity column which contains a delete date value."
                },
                "dependsOn": {
                    "$ref": "#/definitions/Set<string|Function>",
                    "description": "View's dependencies.\nUsed in views"
                },
                "descendantColumns": {
                    "description": "Descendant columns used only in closure junction tables.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "discriminatorColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets the discriminator column used to store entity identificator in single-table inheritance tables."
                },
                "discriminatorValue": {
                    "description": "If this entity metadata is a child table of some table, it should have a discriminator value.\nUsed to store a value in a discriminator column.",
                    "type": "string"
                },
                "eagerRelations": {
                    "description": "List of eager relations this metadata has.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "embeddeds": {
                    "description": "Entity's embedded metadatas.",
                    "items": {
                        "$ref": "#/definitions/EmbeddedMetadata"
                    },
                    "type": "array"
                },
                "engine": {
                    "description": "Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).",
                    "type": "string"
                },
                "exclusions": {
                    "description": "Entity's exclusion metadatas.",
                    "items": {
                        "$ref": "#/definitions/ExclusionMetadata"
                    },
                    "type": "array"
                },
                "expression": {
                    "description": "View's expression.\nUsed in views",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "foreignKeys": {
                    "description": "Entity's foreign key metadatas.",
                    "items": {
                        "$ref": "#/definitions/ForeignKeyMetadata"
                    },
                    "type": "array"
                },
                "generatedColumns": {
                    "description": "Gets the column with generated flag.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "givenTableName": {
                    "description": "Original user-given table name (taken from schema or",
                    "type": "string"
                },
                "hasMultiplePrimaryKeys": {
                    "description": "Checks if entity's table has multiple primary columns.",
                    "type": "boolean"
                },
                "hasNonNullableRelations": {
                    "description": "Checks if there any non-nullable column exist in this entity.",
                    "type": "boolean"
                },
                "hasUUIDGeneratedColumns": {
                    "description": "Indicates if this entity metadata has uuid generated columns.",
                    "type": "boolean"
                },
                "indices": {
                    "description": "Entity's index metadatas.",
                    "items": {
                        "$ref": "#/definitions/IndexMetadata"
                    },
                    "type": "array"
                },
                "inheritancePattern": {
                    "const": "STI",
                    "description": "If this entity metadata's table using one of the inheritance patterns,\nthen this will contain what pattern it uses.",
                    "type": "string"
                },
                "inheritanceTree": {
                    "description": "All \"inheritance tree\" from a target entity.\nFor example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\nIt also contains child entities for single table inheritance.",
                    "items": {
                        "$ref": "#/definitions/Function"
                    },
                    "type": "array"
                },
                "inverseColumns": {
                    "description": "In the case if this entity metadata is junction table's entity metadata,\nthis will contain all referenced columns of inverse entity.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "isAlwaysUsingConstructor": {
                    "description": "Indicates if the entity should be instantiated using the constructor\nor via allocating a new object via `Object.create()`.",
                    "type": "boolean"
                },
                "isClosureJunction": {
                    "description": "Checks if this table is a junction table of the closure table.\nThis type is for tables that contain junction metadata of the closure tables.",
                    "type": "boolean"
                },
                "isJunction": {
                    "description": "Indicates if this entity metadata of a junction table, or not.\nJunction table is a table created by many-to-many relationship.\n\nIts also possible to understand if entity is junction via tableType.",
                    "type": "boolean"
                },
                "lazyRelations": {
                    "description": "List of eager relations this metadata has.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "listeners": {
                    "description": "Entity listener metadatas.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "manyToManyRelations": {
                    "description": "Gets only many-to-many relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "manyToOneRelations": {
                    "description": "Gets only many-to-one relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "materializedPathColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Materialized path column.\nUsed only in tree entities with materialized path pattern applied."
                },
                "name": {
                    "description": "Entity's name.\nEqual to entity target class's name if target is set to table.\nIf target class is not then then it equals to table name.",
                    "type": "string"
                },
                "nestedSetLeftColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Nested set's left value column.\nUsed only in tree entities with nested set pattern applied."
                },
                "nestedSetRightColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Nested set's right value column.\nUsed only in tree entities with nested set pattern applied."
                },
                "nonVirtualColumns": {
                    "description": "All columns except for virtual columns.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "objectIdColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets the object id column used with mongodb database."
                },
                "oneToManyRelations": {
                    "description": "Gets only one-to-many relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "oneToOneRelations": {
                    "description": "Gets only one-to-one relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "orderBy": {
                    "additionalProperties": {
                        "anyOf": [
                            {
                                "properties": {
                                    "nulls": {
                                        "enum": [
                                            "NULLS FIRST",
                                            "NULLS LAST"
                                        ],
                                        "type": "string"
                                    },
                                    "order": {
                                        "enum": [
                                            "ASC",
                                            "DESC"
                                        ],
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "order"
                                ],
                                "type": "object"
                            },
                            {
                                "enum": [
                                    "ASC",
                                    "DESC"
                                ],
                                "type": "string"
                            }
                        ]
                    },
                    "description": "Specifies a default order by used for queries from this table when no explicit order by is specified.",
                    "type": "object"
                },
                "ownColumns": {
                    "description": "Entity's column metadatas defined by user.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "ownIndices": {
                    "description": "Entity's own indices.",
                    "items": {
                        "$ref": "#/definitions/IndexMetadata"
                    },
                    "type": "array"
                },
                "ownListeners": {
                    "description": "Entity's own listener metadatas.",
                    "items": {
                        "$ref": "#/definitions/EntityListenerMetadata"
                    },
                    "type": "array"
                },
                "ownRelations": {
                    "description": "Entity's relation metadatas.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "ownUniques": {
                    "description": "Entity's own uniques.",
                    "items": {
                        "$ref": "#/definitions/UniqueMetadata"
                    },
                    "type": "array"
                },
                "ownerColumns": {
                    "description": "In the case if this entity metadata is junction table's entity metadata,\nthis will contain all referenced columns of owner entity.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "ownerManyToManyRelations": {
                    "description": "Gets only owner many-to-many relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "ownerOneToOneRelations": {
                    "description": "Gets only owner one-to-one relations of the entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "parentClosureEntityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "If this is entity metadata for a junction closure table then its owner closure table metadata will be set here."
                },
                "parentEntityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Parent's entity metadata. Used in inheritance patterns."
                },
                "primaryColumns": {
                    "description": "Gets the primary columns.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "propertiesMap": {
                    "$ref": "#/definitions/ObjectLiteral",
                    "description": "Map of columns and relations of the entity.\n\nexample: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\nThis method will create following object:\n{ id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }"
                },
                "relationCounts": {
                    "description": "Entity's relation id metadatas.",
                    "items": {
                        "$ref": "#/definitions/RelationCountMetadata"
                    },
                    "type": "array"
                },
                "relationIds": {
                    "description": "Entity's relation id metadatas.",
                    "items": {
                        "$ref": "#/definitions/RelationIdMetadata"
                    },
                    "type": "array"
                },
                "relations": {
                    "description": "Relations of the entity, including relations that are coming from the embeddeds of this entity.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "relationsWithJoinColumns": {
                    "description": "Gets only owner one-to-one and many-to-one relations.",
                    "items": {
                        "$ref": "#/definitions/RelationMetadata"
                    },
                    "type": "array"
                },
                "schema": {
                    "description": "Schema name. Used in Postgres and Sql Server.",
                    "type": "string"
                },
                "synchronize": {
                    "description": "Indicates if schema will be synchronized for this entity or not.",
                    "type": "boolean"
                },
                "tableMetadataArgs": {
                    "$ref": "#/definitions/TableMetadataArgs",
                    "description": "Metadata arguments used to build this entity metadata."
                },
                "tableName": {
                    "description": "Entity table name in the database.\nThis is final table name of the entity.\nThis name already passed naming strategy, and generated based on\nmultiple criteria, including user table name and global table prefix.",
                    "type": "string"
                },
                "tableNameWithoutPrefix": {
                    "description": "Gets the table name without global table prefix.\nWhen querying table you need a table name with prefix, but in some scenarios,\nfor example when you want to name a junction table that contains names of two other tables,\nyou may want a table name without prefix.",
                    "type": "string"
                },
                "tablePath": {
                    "description": "Entity table path. Contains database name, schema name and table name.\nE.g. myDB.mySchema.myTable",
                    "type": "string"
                },
                "tableType": {
                    "$ref": "#/definitions/TableType",
                    "description": "Table type. Tables can be closure, junction, etc."
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which this entity metadata is bind.\nNote, that when using table inheritance patterns target can be different rather then table's target.\nFor virtual tables which lack of real entity (like junction tables) target is equal to their table name."
                },
                "targetName": {
                    "description": "Gets the name of the target.",
                    "type": "string"
                },
                "treeChildrenRelation": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "Tree children relation. Used only in tree-tables."
                },
                "treeLevelColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Special column that stores tree level in tree entities."
                },
                "treeOptions": {
                    "$ref": "#/definitions/ClosureTreeOptions",
                    "description": "Indicates if this entity is a tree, what options of tree it has."
                },
                "treeParentRelation": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "Tree parent relation. Used only in tree-tables."
                },
                "treeType": {
                    "description": "Indicates if this entity is a tree, what type of tree it is.",
                    "enum": [
                        "adjacency-list",
                        "closure-table",
                        "materialized-path",
                        "nested-set"
                    ],
                    "type": "string"
                },
                "uniques": {
                    "description": "Entity's unique metadatas.",
                    "items": {
                        "$ref": "#/definitions/UniqueMetadata"
                    },
                    "type": "array"
                },
                "updateDateColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets entity column which contains an update date value."
                },
                "versionColumn": {
                    "$ref": "#/definitions/ColumnMetadata",
                    "description": "Gets entity column which contains an entity version."
                },
                "withoutRowid": {
                    "description": "Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement",
                    "type": "boolean"
                }
            },
            "required": [
                "@instanceof",
                "afterInsertListeners",
                "afterLoadListeners",
                "afterRecoverListeners",
                "afterRemoveListeners",
                "afterSoftRemoveListeners",
                "afterUpdateListeners",
                "allEmbeddeds",
                "ancestorColumns",
                "beforeInsertListeners",
                "beforeRecoverListeners",
                "beforeRemoveListeners",
                "beforeSoftRemoveListeners",
                "beforeUpdateListeners",
                "checks",
                "childEntityMetadatas",
                "closureJunctionTable",
                "columns",
                "connection",
                "descendantColumns",
                "eagerRelations",
                "embeddeds",
                "exclusions",
                "foreignKeys",
                "generatedColumns",
                "hasMultiplePrimaryKeys",
                "hasNonNullableRelations",
                "hasUUIDGeneratedColumns",
                "indices",
                "inheritanceTree",
                "inverseColumns",
                "isAlwaysUsingConstructor",
                "isClosureJunction",
                "isJunction",
                "lazyRelations",
                "listeners",
                "manyToManyRelations",
                "manyToOneRelations",
                "name",
                "nonVirtualColumns",
                "oneToManyRelations",
                "oneToOneRelations",
                "ownColumns",
                "ownIndices",
                "ownListeners",
                "ownRelations",
                "ownUniques",
                "ownerColumns",
                "ownerManyToManyRelations",
                "ownerOneToOneRelations",
                "parentClosureEntityMetadata",
                "parentEntityMetadata",
                "primaryColumns",
                "propertiesMap",
                "relationCounts",
                "relationIds",
                "relations",
                "relationsWithJoinColumns",
                "synchronize",
                "tableMetadataArgs",
                "tableName",
                "tableNameWithoutPrefix",
                "tablePath",
                "tableType",
                "target",
                "targetName",
                "uniques"
            ],
            "type": "object"
        },
        "EntitySchema<any>": {
            "description": "Interface for entity metadata mappings stored inside \"schemas\" instead of models decorated by decorators.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "options": {
                    "$ref": "#/definitions/EntitySchemaOptions<any>"
                }
            },
            "required": [
                "@instanceof",
                "options"
            ],
            "type": "object"
        },
        "EntitySchemaCheckOptions": {
            "properties": {
                "expression": {
                    "description": "Check expression.",
                    "type": "string"
                },
                "name": {
                    "description": "Check constraint name.",
                    "type": "string"
                }
            },
            "required": [
                "expression"
            ],
            "type": "object"
        },
        "EntitySchemaExclusionOptions": {
            "properties": {
                "expression": {
                    "description": "Exclusion expression.",
                    "type": "string"
                },
                "name": {
                    "description": "Exclusion constraint name.",
                    "type": "string"
                }
            },
            "required": [
                "expression"
            ],
            "type": "object"
        },
        "EntitySchemaIndexOptions": {
            "properties": {
                "columns": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "Index column names."
                },
                "fulltext": {
                    "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing.\nWorks only in MySQL.",
                    "type": "boolean"
                },
                "name": {
                    "description": "Index name.",
                    "type": "string"
                },
                "nullFiltered": {
                    "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\nIn these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\na normal index that includes NULL values.\n\nWorks only in Spanner.",
                    "type": "boolean"
                },
                "parser": {
                    "description": "Fulltext parser.\nWorks only in MySQL.",
                    "type": "string"
                },
                "sparse": {
                    "description": "If true, the index only references documents with the specified field.\nThese indexes use less space but behave differently in some situations (particularly sorts).\nThis option is only supported for mongodb database.",
                    "type": "boolean"
                },
                "spatial": {
                    "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\nWorks only in MySQL and PostgreSQL.",
                    "type": "boolean"
                },
                "synchronize": {
                    "description": "Indicates if index must sync with database index.",
                    "type": "boolean"
                },
                "unique": {
                    "description": "Indicates if this index must be unique or not.",
                    "type": "boolean"
                },
                "where": {
                    "description": "Index filter condition.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "EntitySchemaInheritanceOptions": {
            "properties": {
                "column": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ColumnOptions"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Inheritance discriminator column."
                },
                "pattern": {
                    "const": "STI",
                    "description": "Inheritance pattern.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "EntitySchemaOptions<any>": {
            "description": "Interface for entity metadata mappings stored inside \"schemas\" instead of models decorated by decorators.",
            "properties": {
                "checks": {
                    "description": "Entity check options.",
                    "items": {
                        "$ref": "#/definitions/EntitySchemaCheckOptions"
                    },
                    "type": "array"
                },
                "columns": {
                    "$ref": "#/definitions/{[x:string]:EntitySchemaColumnOptions|undefined;}",
                    "description": "Entity column's options."
                },
                "database": {
                    "description": "Database name. Used in MySql and Sql Server.",
                    "type": "string"
                },
                "discriminatorValue": {
                    "description": "Custom discriminator value for Single Table Inheritance.",
                    "type": "string"
                },
                "embeddeds": {
                    "$ref": "#/definitions/{[x:string]:EntitySchemaEmbeddedColumnOptions;}",
                    "description": "Embedded Entities options"
                },
                "exclusions": {
                    "description": "Entity exclusion options.",
                    "items": {
                        "$ref": "#/definitions/EntitySchemaExclusionOptions"
                    },
                    "type": "array"
                },
                "expression": {
                    "description": "View expression.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "indices": {
                    "description": "Entity indices options.",
                    "items": {
                        "$ref": "#/definitions/EntitySchemaIndexOptions"
                    },
                    "type": "array"
                },
                "inheritance": {
                    "$ref": "#/definitions/EntitySchemaInheritanceOptions",
                    "description": "Inheritance options."
                },
                "name": {
                    "description": "Entity name.",
                    "type": "string"
                },
                "orderBy": {
                    "additionalProperties": {
                        "anyOf": [
                            {
                                "properties": {
                                    "nulls": {
                                        "enum": [
                                            "NULLS FIRST",
                                            "NULLS LAST"
                                        ],
                                        "type": "string"
                                    },
                                    "order": {
                                        "enum": [
                                            "ASC",
                                            "DESC"
                                        ],
                                        "type": "string"
                                    }
                                },
                                "required": [
                                    "order"
                                ],
                                "type": "object"
                            },
                            {
                                "enum": [
                                    "ASC",
                                    "DESC"
                                ],
                                "type": "string"
                            }
                        ]
                    },
                    "description": "Specifies a property name by which queries will perform ordering by default when fetching rows.",
                    "type": "object"
                },
                "relationIds": {
                    "$ref": "#/definitions/{[x:string]:EntitySchemaRelationIdOptions|undefined;}",
                    "description": "Entity relation id options."
                },
                "relations": {
                    "$ref": "#/definitions/{[x:string]:EntitySchemaRelationOptions|undefined;}",
                    "description": "Entity relation's options."
                },
                "schema": {
                    "description": "Schema name. Used in Postgres and Sql Server.",
                    "type": "string"
                },
                "synchronize": {
                    "description": "Indicates if schema synchronization is enabled or disabled for this entity.\nIf it will be set to false then schema sync will and migrations ignore this entity.\nBy default schema synchronization is enabled for all entities.",
                    "type": "boolean"
                },
                "tableName": {
                    "description": "Table name.",
                    "type": "string"
                },
                "target": {
                    "$ref": "#/definitions/Function",
                    "description": "Target bind to this entity schema. Optional."
                },
                "type": {
                    "description": "Table type.",
                    "enum": [
                        "closure",
                        "closure-junction",
                        "entity-child",
                        "junction",
                        "regular",
                        "view"
                    ],
                    "type": "string"
                },
                "uniques": {
                    "description": "Entity uniques options.",
                    "items": {
                        "$ref": "#/definitions/EntitySchemaUniqueOptions"
                    },
                    "type": "array"
                },
                "withoutRowid": {
                    "description": "If set to 'true' this option disables Sqlite's default behaviour of secretly creating\nan integer primary key column named 'rowid' on table creation.",
                    "type": "boolean"
                }
            },
            "required": [
                "columns",
                "name"
            ],
            "type": "object"
        },
        "EntitySchemaUniqueOptions": {
            "properties": {
                "columns": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "Unique column names."
                },
                "deferrable": {
                    "description": "Indicate if unique constraints can be deferred.",
                    "enum": [
                        "INITIALLY DEFERRED",
                        "INITIALLY IMMEDIATE"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Unique constraint name.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "EntitySubscriberInterface<any>": {
            "description": "Classes that implement this interface are subscribers that subscribe for the specific events in the ORM.",
            "type": "object"
        },
        "EntityTarget<any>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/Function"
                },
                {
                    "$ref": "#/definitions/EntitySchema<any>"
                },
                {
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "type": {}
                    },
                    "required": [
                        "name",
                        "type"
                    ],
                    "type": "object"
                },
                {
                    "type": [
                        "string",
                        "object"
                    ]
                }
            ],
            "description": "Entity target."
        },
        "Error": {
            "properties": {
                "message": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "stack": {
                    "type": "string"
                }
            },
            "required": [
                "message",
                "name"
            ],
            "type": "object"
        },
        "ErrorFormattingOptions": {
            "properties": {
                "escapeHtml": {
                    "default": false,
                    "description": "when true, error message templates will escape special characters to HTML entities, for security purposes.",
                    "type": "boolean"
                },
                "label": {
                    "description": "defines the value used to set the label context variable.",
                    "enum": [
                        false,
                        "key",
                        "path"
                    ]
                },
                "language": {
                    "description": "The preferred language code for error messages.\nThe value is matched against keys at the root of the messages object, and then the error code as a child key of that.\nCan be a reference to the value, global context, or local context which is the root value passed to the validation function.\n\nNote that references to the value are usually not what you want as they move around the value structure relative to where the error happens.\nInstead, either use the global context, or the absolute value (e.g. `Joi.ref('/variable')`)",
                    "type": "string"
                },
                "render": {
                    "default": true,
                    "description": "when false, skips rendering error templates. Useful when error messages are generated elsewhere to save processing time.",
                    "type": "boolean"
                },
                "stack": {
                    "default": false,
                    "description": "when true, the main error will possess a stack trace, otherwise it will be disabled.\nDefaults to false for performances reasons. Has no effect on platforms other than V8/node.js as it uses the Stack trace API.",
                    "type": "boolean"
                },
                "wrap": {
                    "description": "overrides the way values are wrapped (e.g. `[]` around arrays, `\"\"` around labels).\nEach key can be set to a string with one (same character before and after the value) or two characters (first character\nbefore and second character after), or `false` to disable wrapping.",
                    "properties": {
                        "array": {
                            "anyOf": [
                                {
                                    "const": false,
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "default": "'[]'",
                            "description": "the characters used around array values. Defaults to `'[]'`"
                        },
                        "label": {
                            "anyOf": [
                                {
                                    "const": false,
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "default": "'\"'",
                            "description": "the characters used around `{#label}` references. Defaults to `'\"'`."
                        },
                        "string": {
                            "anyOf": [
                                {
                                    "const": false,
                                    "type": "boolean"
                                },
                                {
                                    "type": "string"
                                }
                            ],
                            "default": false,
                            "description": "the characters used around array string values. Defaults to no wrapping."
                        }
                    },
                    "type": "object"
                }
            },
            "type": "object"
        },
        "ErrorManager": {
            "type": "object"
        },
        "EventEmitterAsyncResource": {
            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves.",
            "properties": {
                "asyncId": {
                    "description": "The unique `asyncId` assigned to the resource.",
                    "type": "number"
                },
                "asyncResource": {
                    "$ref": "#/definitions/EventEmitterReferencingAsyncResource",
                    "description": "The returned `AsyncResource` object has an additional `eventEmitter` property\nthat provides a reference to this `EventEmitterAsyncResource`."
                },
                "triggerAsyncId": {
                    "description": "The same triggerAsyncId that is passed to the AsyncResource constructor.",
                    "type": "number"
                }
            },
            "required": [
                "asyncId",
                "asyncResource",
                "triggerAsyncId"
            ],
            "type": "object"
        },
        "EventEmitterReferencingAsyncResource": {
            "properties": {
                "eventEmitter": {
                    "$ref": "#/definitions/EventEmitterAsyncResource"
                }
            },
            "required": [
                "eventEmitter"
            ],
            "type": "object"
        },
        "EventListenerType": {
            "description": "All types that entity listener can be.",
            "enum": [
                "after-insert",
                "after-load",
                "after-recover",
                "after-remove",
                "after-soft-remove",
                "after-update",
                "before-insert",
                "before-recover",
                "before-remove",
                "before-soft-remove",
                "before-update"
            ],
            "type": "string"
        },
        "ExclusionMetadata": {
            "description": "Exclusion metadata contains all information about table's exclusion constraints.",
            "properties": {
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the class to which this exclusion constraint is applied."
                },
                "expression": {
                    "description": "Exclusion expression.",
                    "type": "string"
                },
                "givenName": {
                    "description": "User specified exclusion constraint name.",
                    "type": "string"
                },
                "name": {
                    "description": "Final exclusion constraint name.\nIf exclusion constraint name was given by a user then it stores normalized (by naming strategy) givenName.\nIf exclusion constraint name was not given then its generated.",
                    "type": "string"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                }
            },
            "required": [
                "entityMetadata",
                "expression",
                "name"
            ],
            "type": "object"
        },
        "ExpoConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name.",
                    "type": "string"
                },
                "driver": {
                    "description": "Driver module"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "expo",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "driver",
                "type"
            ],
            "type": "object"
        },
        "ForeignKeyMetadata": {
            "description": "Contains all information about entity's foreign key.",
            "properties": {
                "columnNames": {
                    "description": "Gets array of column names.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "columns": {
                    "description": "Array of columns of this foreign key.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "deferrable": {
                    "description": "When to check the constraints of a foreign key.",
                    "enum": [
                        "INITIALLY DEFERRED",
                        "INITIALLY IMMEDIATE"
                    ],
                    "type": "string"
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata where this foreign key is."
                },
                "givenName": {
                    "description": "User specified unique constraint name.",
                    "type": "string"
                },
                "name": {
                    "description": "Gets foreign key name.\nIf unique constraint name was given by a user then it stores givenName.\nIf unique constraint name was not given then its generated.",
                    "type": "string"
                },
                "onDelete": {
                    "description": "What to do with a relation on deletion of the row containing a foreign key.",
                    "enum": [
                        "CASCADE",
                        "DEFAULT",
                        "NO ACTION",
                        "RESTRICT",
                        "SET NULL"
                    ],
                    "type": "string"
                },
                "onUpdate": {
                    "description": "What to do with a relation on update of the row containing a foreign key.",
                    "enum": [
                        "CASCADE",
                        "DEFAULT",
                        "NO ACTION",
                        "RESTRICT",
                        "SET NULL"
                    ],
                    "type": "string"
                },
                "referencedColumnNames": {
                    "description": "Gets array of referenced column names.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "referencedColumns": {
                    "description": "Array of referenced columns.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "referencedEntityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata which this foreign key references."
                },
                "referencedTablePath": {
                    "description": "Gets the table name to which this foreign key is referenced.",
                    "type": "string"
                }
            },
            "required": [
                "columnNames",
                "columns",
                "entityMetadata",
                "name",
                "referencedColumnNames",
                "referencedColumns",
                "referencedEntityMetadata",
                "referencedTablePath"
            ],
            "type": "object"
        },
        "Function": {
            "properties": {
                "arguments": {},
                "caller": {
                    "$ref": "#/definitions/Function"
                },
                "length": {
                    "type": "number"
                },
                "name": {
                    "type": "string"
                },
                "prototype": {}
            },
            "required": [
                "arguments",
                "caller",
                "length",
                "name",
                "prototype"
            ],
            "type": "object"
        },
        "FunctionSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/FunctionSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/FunctionSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "HandlerDecorations": {
            "type": "object"
        },
        "HedgeOptions": {
            "properties": {
                "enabled": {
                    "description": "Explicitly enable or disable hedged reads.",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "HostAddress": {
            "properties": {
                "host": {
                    "type": "string"
                },
                "isIPv6": {
                    "type": "boolean"
                },
                "port": {
                    "type": "number"
                },
                "socketPath": {
                    "type": "string"
                }
            },
            "required": [
                "isIPv6"
            ],
            "type": "object"
        },
        "IncomingHttpHeaders": {
            "properties": {
                "accept": {
                    "type": "string"
                },
                "accept-language": {
                    "type": "string"
                },
                "accept-patch": {
                    "type": "string"
                },
                "accept-ranges": {
                    "type": "string"
                },
                "access-control-allow-credentials": {
                    "type": "string"
                },
                "access-control-allow-headers": {
                    "type": "string"
                },
                "access-control-allow-methods": {
                    "type": "string"
                },
                "access-control-allow-origin": {
                    "type": "string"
                },
                "access-control-expose-headers": {
                    "type": "string"
                },
                "access-control-max-age": {
                    "type": "string"
                },
                "access-control-request-headers": {
                    "type": "string"
                },
                "access-control-request-method": {
                    "type": "string"
                },
                "age": {
                    "type": "string"
                },
                "allow": {
                    "type": "string"
                },
                "alt-svc": {
                    "type": "string"
                },
                "authorization": {
                    "type": "string"
                },
                "cache-control": {
                    "type": "string"
                },
                "connection": {
                    "type": "string"
                },
                "content-disposition": {
                    "type": "string"
                },
                "content-encoding": {
                    "type": "string"
                },
                "content-language": {
                    "type": "string"
                },
                "content-length": {
                    "type": "string"
                },
                "content-location": {
                    "type": "string"
                },
                "content-range": {
                    "type": "string"
                },
                "content-type": {
                    "type": "string"
                },
                "cookie": {
                    "type": "string"
                },
                "date": {
                    "type": "string"
                },
                "etag": {
                    "type": "string"
                },
                "expect": {
                    "type": "string"
                },
                "expires": {
                    "type": "string"
                },
                "forwarded": {
                    "type": "string"
                },
                "from": {
                    "type": "string"
                },
                "host": {
                    "type": "string"
                },
                "if-match": {
                    "type": "string"
                },
                "if-modified-since": {
                    "type": "string"
                },
                "if-none-match": {
                    "type": "string"
                },
                "if-unmodified-since": {
                    "type": "string"
                },
                "last-modified": {
                    "type": "string"
                },
                "location": {
                    "type": "string"
                },
                "origin": {
                    "type": "string"
                },
                "pragma": {
                    "type": "string"
                },
                "proxy-authenticate": {
                    "type": "string"
                },
                "proxy-authorization": {
                    "type": "string"
                },
                "public-key-pins": {
                    "type": "string"
                },
                "range": {
                    "type": "string"
                },
                "referer": {
                    "type": "string"
                },
                "retry-after": {
                    "type": "string"
                },
                "sec-websocket-accept": {
                    "type": "string"
                },
                "sec-websocket-extensions": {
                    "type": "string"
                },
                "sec-websocket-key": {
                    "type": "string"
                },
                "sec-websocket-protocol": {
                    "type": "string"
                },
                "sec-websocket-version": {
                    "type": "string"
                },
                "set-cookie": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "strict-transport-security": {
                    "type": "string"
                },
                "tk": {
                    "type": "string"
                },
                "trailer": {
                    "type": "string"
                },
                "transfer-encoding": {
                    "type": "string"
                },
                "upgrade": {
                    "type": "string"
                },
                "user-agent": {
                    "type": "string"
                },
                "vary": {
                    "type": "string"
                },
                "via": {
                    "type": "string"
                },
                "warning": {
                    "type": "string"
                },
                "www-authenticate": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "IncomingMessage": {
            "description": "An `IncomingMessage` object is created by {@link Server} or {@link ClientRequest} and passed as the first argument to the `'request'` and `'response'` event respectively. It may be used to\naccess response\nstatus, headers, and data.\n\nDifferent from its `socket` value which is a subclass of `stream.Duplex`, the `IncomingMessage` itself extends `stream.Readable` and is created separately to\nparse and emit the incoming HTTP headers and payload, as the underlying socket\nmay be reused multiple times in case of keep-alive.",
            "properties": {
                "aborted": {
                    "description": "The `message.aborted` property will be `true` if the request has\nbeen aborted.",
                    "type": "boolean"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "complete": {
                    "description": "The `message.complete` property will be `true` if a complete HTTP message has\nbeen received and successfully parsed.\n\nThis property is particularly useful as a means of determining if a client or\nserver fully transmitted a message before a connection was terminated:\n\n```js\nconst req = http.request({\n  host: '127.0.0.1',\n  port: 8080,\n  method: 'POST',\n}, (res) => {\n  res.resume();\n  res.on('end', () => {\n    if (!res.complete)\n      console.error(\n        'The connection was terminated while the message was still being sent');\n  });\n});\n```",
                    "type": "boolean"
                },
                "connection": {
                    "$ref": "#/definitions/Socket",
                    "description": "Alias for `message.socket`."
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "headers": {
                    "$ref": "#/definitions/IncomingHttpHeaders",
                    "description": "The request/response headers object.\n\nKey-value pairs of header names and values. Header names are lower-cased.\n\n```js\n// Prints something like:\n//\n// { 'user-agent': 'curl/7.22.0',\n//   host: '127.0.0.1:8000',\n//   accept: '*' }\nconsole.log(request.headers);\n```\n\nDuplicates in raw headers are handled in the following ways, depending on the\nheader name:\n\n* Duplicates of `age`, `authorization`, `content-length`, `content-type`, `etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,\n`max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`, or `user-agent` are discarded.\nTo allow duplicate values of the headers listed above to be joined,\nuse the option `joinDuplicateHeaders` in {@link request} and {@link createServer}. See RFC 9110 Section 5.3 for more\ninformation.\n* `set-cookie` is always an array. Duplicates are added to the array.\n* For duplicate `cookie` headers, the values are joined together with `; `.\n* For all other headers, the values are joined together with `, `."
                },
                "headersDistinct": {
                    "$ref": "#/definitions/NodeJS.Dict<string[]>",
                    "description": "Similar to `message.headers`, but there is no join logic and the values are\nalways arrays of strings, even for headers received just once.\n\n```js\n// Prints something like:\n//\n// { 'user-agent': ['curl/7.22.0'],\n//   host: ['127.0.0.1:8000'],\n//   accept: ['*'] }\nconsole.log(request.headersDistinct);\n```"
                },
                "httpVersion": {
                    "description": "In case of server request, the HTTP version sent by the client. In the case of\nclient response, the HTTP version of the connected-to server.\nProbably either `'1.1'` or `'1.0'`.\n\nAlso `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.",
                    "type": "string"
                },
                "httpVersionMajor": {
                    "type": "number"
                },
                "httpVersionMinor": {
                    "type": "number"
                },
                "method": {
                    "description": "**Only valid for request obtained from {@link Server}.**\n\nThe request method as a string. Read only. Examples: `'GET'`, `'DELETE'`.",
                    "type": "string"
                },
                "rawHeaders": {
                    "description": "The raw request/response headers list exactly as they were received.\n\nThe keys and values are in the same list. It is _not_ a\nlist of tuples. So, the even-numbered offsets are key values, and the\nodd-numbered offsets are the associated values.\n\nHeader names are not lowercased, and duplicates are not merged.\n\n```js\n// Prints something like:\n//\n// [ 'user-agent',\n//   'this is invalid because there can be only one',\n//   'User-Agent',\n//   'curl/7.22.0',\n//   'Host',\n//   '127.0.0.1:8000',\n//   'ACCEPT',\n//   '*' ]\nconsole.log(request.rawHeaders);\n```",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "rawTrailers": {
                    "description": "The raw request/response trailer keys and values exactly as they were\nreceived. Only populated at the `'end'` event.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "socket": {
                    "$ref": "#/definitions/Socket",
                    "description": "The `net.Socket` object associated with the connection.\n\nWith HTTPS support, use `request.socket.getPeerCertificate()` to obtain the\nclient's authentication details.\n\nThis property is guaranteed to be an instance of the `net.Socket` class,\na subclass of `stream.Duplex`, unless the user specified a socket\ntype other than `net.Socket` or internally nulled."
                },
                "statusCode": {
                    "description": "**Only valid for response obtained from {@link ClientRequest}.**\n\nThe 3-digit HTTP response status code. E.G. `404`.",
                    "type": "number"
                },
                "statusMessage": {
                    "description": "**Only valid for response obtained from {@link ClientRequest}.**\n\nThe HTTP response status message (reason phrase). E.G. `OK` or `Internal Server Error`.",
                    "type": "string"
                },
                "trailers": {
                    "$ref": "#/definitions/NodeJS.Dict<string>",
                    "description": "The request/response trailers object. Only populated at the `'end'` event."
                },
                "trailersDistinct": {
                    "$ref": "#/definitions/NodeJS.Dict<string[]>",
                    "description": "Similar to `message.trailers`, but there is no join logic and the values are\nalways arrays of strings, even for headers received just once.\nOnly populated at the `'end'` event."
                },
                "url": {
                    "description": "**Only valid for request obtained from {@link Server}.**\n\nRequest URL string. This contains only the URL that is present in the actual\nHTTP request. Take the following request:\n\n```http\nGET /status?name=ryan HTTP/1.1\nAccept: text/plain\n```\n\nTo parse the URL into its parts:\n\n```js\nnew URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);\n```\n\nWhen `request.url` is `'/status?name=ryan'` and `process.env.HOST` is undefined:\n\n```console\n$ node\n> new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);\nURL {\n  href: 'http://localhost/status?name=ryan',\n  origin: 'http://localhost',\n  protocol: 'http:',\n  username: '',\n  password: '',\n  host: 'localhost',\n  hostname: 'localhost',\n  port: '',\n  pathname: '/status',\n  search: '?name=ryan',\n  searchParams: URLSearchParams { 'name' => 'ryan' },\n  hash: ''\n}\n```\n\nEnsure that you set `process.env.HOST` to the server's host name, or consider replacing this part entirely. If using `req.headers.host`, ensure proper\nvalidation is used, as clients may specify a custom `Host` header.",
                    "type": "string"
                }
            },
            "required": [
                "aborted",
                "closed",
                "complete",
                "connection",
                "destroyed",
                "errored",
                "headers",
                "headersDistinct",
                "httpVersion",
                "httpVersionMajor",
                "httpVersionMinor",
                "rawHeaders",
                "rawTrailers",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode",
                "socket",
                "trailers",
                "trailersDistinct"
            ],
            "type": "object"
        },
        "IndexMetadata": {
            "description": "Index metadata contains all information about table's index.",
            "properties": {
                "columnNamesWithOrderingMap": {
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "Map of column names with order set.\nUsed only by MongoDB driver.",
                    "type": "object"
                },
                "columns": {
                    "description": "Indexed columns.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "embeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Embedded metadata if this index was applied on embedded."
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the class to which this index is applied."
                },
                "expireAfterSeconds": {
                    "description": "Specifies a time to live, in seconds.\nThis option is only supported for mongodb database.",
                    "type": "number"
                },
                "givenColumnNames": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "User specified column names."
                },
                "givenName": {
                    "description": "User specified index name.",
                    "type": "string"
                },
                "isBackground": {
                    "description": "Builds the index in the background so that building an index an does not block other database activities.\nThis option is only supported for mongodb database.",
                    "type": "boolean"
                },
                "isConcurrent": {
                    "description": "Builds the index using the concurrently option.\nThis options is only supported for postgres database.",
                    "type": "boolean"
                },
                "isFulltext": {
                    "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing.\nWorks only in MySQL.",
                    "type": "boolean"
                },
                "isNullFiltered": {
                    "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\nIn these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\na normal index that includes NULL values.\n\nWorks only in Spanner.",
                    "type": "boolean"
                },
                "isSparse": {
                    "description": "If true, the index only references documents with the specified field.\nThese indexes use less space but behave differently in some situations (particularly sorts).\nThis option is only supported for mongodb database.",
                    "type": "boolean"
                },
                "isSpatial": {
                    "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\nWorks only in MySQL.",
                    "type": "boolean"
                },
                "isUnique": {
                    "description": "Indicates if this index must be unique.",
                    "type": "boolean"
                },
                "name": {
                    "description": "Final index name.\nIf index name was given by a user then it stores normalized (by naming strategy) givenName.\nIf index name was not given then its generated.",
                    "type": "string"
                },
                "parser": {
                    "description": "Fulltext parser.\nWorks only in MySQL.",
                    "type": "string"
                },
                "synchronize": {
                    "description": "Indicates if this index must synchronize with database index.",
                    "type": "boolean"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                },
                "where": {
                    "description": "Index filter condition.",
                    "type": "string"
                }
            },
            "required": [
                "columnNamesWithOrderingMap",
                "columns",
                "entityMetadata",
                "isFulltext",
                "isNullFiltered",
                "isSpatial",
                "isUnique",
                "name",
                "synchronize"
            ],
            "type": "object"
        },
        "Item": {
            "properties": {
                "id": {
                    "type": "number"
                },
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                }
            },
            "required": [
                "id",
                "name",
                "price"
            ],
            "type": "object"
        },
        "ItemController": {
            "properties": {
                "create": {
                    "type": "object"
                },
                "createDto": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/ItemCreateDto"
                        }
                    },
                    "required": [
                        "prototype"
                    ],
                    "type": "object"
                },
                "delete": {
                    "type": "object"
                },
                "findBy": {
                    "type": "object"
                },
                "findByIdOrFail": {
                    "type": "object"
                },
                "getService": {
                    "type": "object"
                },
                "logger": {
                    "$ref": "#/definitions/Logger_1"
                },
                "serviceName": {
                    "type": "string"
                },
                "update": {
                    "type": "object"
                },
                "updateDto": {
                    "properties": {
                        "prototype": {
                            "$ref": "#/definitions/ItemUpdateDto"
                        }
                    },
                    "required": [
                        "prototype"
                    ],
                    "type": "object"
                }
            },
            "required": [
                "create",
                "createDto",
                "delete",
                "findBy",
                "findByIdOrFail",
                "getService",
                "logger",
                "serviceName",
                "update",
                "updateDto"
            ],
            "type": "object"
        },
        "ItemCreateDto": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                }
            },
            "required": [
                "name",
                "price"
            ],
            "type": "object"
        },
        "ItemRepository": {
            "properties": {
                "create": {
                    "type": "object"
                },
                "dataSource": {
                    "$ref": "#/definitions/DataSource"
                },
                "delete": {
                    "type": "object"
                },
                "entityName": {
                    "type": "string"
                },
                "findBy": {
                    "type": "object"
                },
                "findByIdOrFail": {
                    "type": "object"
                },
                "getRepository": {
                    "type": "object"
                },
                "update": {
                    "type": "object"
                }
            },
            "required": [
                "create",
                "dataSource",
                "delete",
                "entityName",
                "findBy",
                "findByIdOrFail",
                "getRepository",
                "update"
            ],
            "type": "object"
        },
        "ItemService": {
            "properties": {
                "create": {
                    "type": "object"
                },
                "delete": {
                    "type": "object"
                },
                "findBy": {
                    "type": "object"
                },
                "findByIdOrFail": {
                    "type": "object"
                },
                "repository": {
                    "$ref": "#/definitions/ItemRepository"
                },
                "update": {
                    "type": "object"
                }
            },
            "required": [
                "create",
                "delete",
                "findBy",
                "findByIdOrFail",
                "repository",
                "update"
            ],
            "type": "object"
        },
        "ItemUpdateDto": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "price": {
                    "type": "number"
                }
            },
            "required": [
                "name",
                "price"
            ],
            "type": "object"
        },
        "Json.StringifyArguments": {
            "description": "For context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsjson)",
            "properties": {
                "escape": {
                    "type": "boolean"
                },
                "replacer": {
                    "$ref": "#/definitions/Json.StringifyReplacer",
                    "description": "the replacer function or array. Defaults to no action."
                },
                "space": {
                    "description": "number of spaces to indent nested object keys. Defaults to no indentation.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "suffix": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "Json.StringifyReplacer": {
            "anyOf": [
                {
                    "items": {
                        "type": [
                            "string",
                            "number"
                        ]
                    },
                    "type": "array"
                },
                {
                    "type": "object"
                }
            ]
        },
        "KeyObject": {
            "properties": {
                "passphrase": {
                    "description": "Optional passphrase.",
                    "type": "string"
                },
                "pem": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format."
                }
            },
            "required": [
                "pem"
            ],
            "type": "object"
        },
        "LanguageMessages": {
            "type": "object"
        },
        "LinkSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/LinkSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/LinkSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "LogLevel": {
            "description": "Log level.",
            "enum": [
                "error",
                "info",
                "log",
                "migration",
                "query",
                "schema",
                "warn"
            ],
            "type": "string"
        },
        "Logger": {
            "description": "Performs logging of the events in TypeORM.",
            "type": "object"
        },
        "Logger<never,boolean>": {
            "allOf": [
                {
                    "$ref": "#/definitions/default.BaseLogger"
                },
                {
                    "$ref": "#/definitions/LoggerExtras<never,boolean>"
                },
                {
                    "properties": {
                        "customLevels": {
                            "$ref": "#/definitions/{}_1",
                            "description": "Define additional logging levels."
                        },
                        "useOnlyCustomLevels": {
                            "description": "Use only defined `customLevels` and omit Pino's levels.",
                            "type": "boolean"
                        }
                    },
                    "required": [
                        "customLevels",
                        "useOnlyCustomLevels"
                    ],
                    "type": "object"
                },
                {
                    "$ref": "#/definitions/{error:default.LogFn;trace:default.LogFn;info:default.LogFn;warn:default.LogFn;debug:default.LogFn;fatal:default.LogFn;}"
                },
                {
                    "$ref": "#/definitions/{}_2"
                }
            ]
        },
        "LoggerExtras<never,boolean>": {
            "properties": {
                "levelVal": {
                    "description": "Returns the integer value for the logger instance's logging level.",
                    "type": "number"
                },
                "levels": {
                    "$ref": "#/definitions/default.LevelMapping"
                },
                "onChild": {
                    "description": "This can be used to modify the callback function on creation of a new child.",
                    "type": "object"
                },
                "useLevelLabels": {
                    "description": "Outputs the level as a string instead of integer.",
                    "type": "boolean"
                },
                "version": {
                    "description": "Exposes the Pino package version. Also available on the exported pino function.",
                    "type": "string"
                }
            },
            "required": [
                "levelVal",
                "levels",
                "onChild",
                "useLevelLabels",
                "version"
            ],
            "type": "object"
        },
        "Logger_1": {
            "properties": {
                "logger": {
                    "$ref": "#/definitions/Logger<never,boolean>"
                }
            },
            "required": [
                "logger"
            ],
            "type": "object"
        },
        "Map<EntityTarget<any>,EntityMetadata>": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "size"
            ],
            "type": "object"
        },
        "Map<EntityTarget<any>,Repository<any>>": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "size"
            ],
            "type": "object"
        },
        "Map<string|symbol,CacheEntry<any>>": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "size"
            ],
            "type": "object"
        },
        "MappedColumnTypes": {
            "description": "Orm has special columns and we need to know what database column types should be for those types.\nColumn types are driver dependant.",
            "properties": {
                "cacheDuration": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for duration column in query result cache table."
                },
                "cacheId": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for identifier column in query result cache table."
                },
                "cacheIdentifier": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for identifier column in query result cache table."
                },
                "cacheQuery": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for query column in query result cache table."
                },
                "cacheResult": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for result column in query result cache table."
                },
                "cacheTime": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for time column in query result cache table."
                },
                "createDate": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for the create date column."
                },
                "createDateDefault": {
                    "description": "Default value should be used by a database for \"created date\" column.",
                    "type": "string"
                },
                "createDatePrecision": {
                    "description": "Precision of datetime column. Used in MySql to define milliseconds.",
                    "type": "number"
                },
                "deleteDate": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for the delete date column."
                },
                "deleteDateNullable": {
                    "description": "Nullable value should be used by a database for \"deleted date\" column.",
                    "type": "boolean"
                },
                "deleteDatePrecision": {
                    "description": "Precision of datetime column. Used in MySql to define milliseconds.",
                    "type": "number"
                },
                "metadataDatabase": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata database name column in typeorm metadata table."
                },
                "metadataName": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata name column in typeorm metadata table."
                },
                "metadataSchema": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata schema name column in typeorm metadata table."
                },
                "metadataTable": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata table name column in typeorm metadata table."
                },
                "metadataType": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata type column in typeorm metadata table.\nStores type of metadata. E.g. 'VIEW' or 'CHECK'"
                },
                "metadataValue": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for metadata value column in typeorm metadata table."
                },
                "migrationId": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type of id column used for migrations table."
                },
                "migrationName": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for migration name column used for migrations table."
                },
                "migrationTimestamp": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type of timestamp column used for migrations table."
                },
                "treeLevel": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for the tree level column."
                },
                "updateDate": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for the update date column."
                },
                "updateDateDefault": {
                    "description": "Default value should be used by a database for \"updated date\" column.",
                    "type": "string"
                },
                "updateDatePrecision": {
                    "description": "Precision of datetime column. Used in MySql to define milliseconds.",
                    "type": "number"
                },
                "version": {
                    "$ref": "#/definitions/ColumnType",
                    "description": "Column type for the version column."
                }
            },
            "required": [
                "cacheDuration",
                "cacheId",
                "cacheIdentifier",
                "cacheQuery",
                "cacheResult",
                "cacheTime",
                "createDate",
                "createDateDefault",
                "deleteDate",
                "deleteDateNullable",
                "metadataDatabase",
                "metadataName",
                "metadataSchema",
                "metadataTable",
                "metadataType",
                "metadataValue",
                "migrationId",
                "migrationName",
                "migrationTimestamp",
                "treeLevel",
                "updateDate",
                "updateDateDefault",
                "version"
            ],
            "type": "object"
        },
        "MigrationInterface": {
            "description": "Migrations should implement this interface and all its methods.",
            "properties": {
                "name": {
                    "description": "Optional migration name, defaults to class name.",
                    "type": "string"
                },
                "transaction": {
                    "description": "Optional flag to determine whether to run the migration in a transaction or not.\nCan only be used when `migrationsTransactionMode` is either \"each\" or \"none\"\nDefaults to `true` when `migrationsTransactionMode` is \"each\"\nDefaults to `false` when `migrationsTransactionMode` is \"none\"",
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "Mimos<{}>": {
            "type": "object"
        },
        "MimosDeclaration<P>": {
            "properties": {
                "charset": {
                    "description": "Charset for type.",
                    "type": "string"
                },
                "compressible": {
                    "description": "Boolean that indicates if the contents is likely to become smaller if\ngzip or similar compression is applied.",
                    "type": "boolean"
                },
                "extensions": {
                    "description": "Array of strings with possible lowercased file extensions, without the\ndot.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "predicate": {
                    "description": "Method with signature `function(mime)`.\n\nWhen this mime type is found in the database, this function will run.\nThis allows you make customizations to `mime` based on developer criteria.",
                    "type": "object"
                },
                "source": {
                    "description": "String with identifier for the source of the data.",
                    "enum": [
                        "apache",
                        "iana",
                        "nginx"
                    ],
                    "type": "string"
                },
                "type": {
                    "description": "The `type` value of result objects, defaults to `key`.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MimosOptions<{}>": {
            "properties": {
                "override": {
                    "additionalProperties": {
                        "allOf": [
                            {
                                "$ref": "#/definitions/MimosDeclaration<P>"
                            },
                            {
                                "$ref": "#/definitions/P"
                            }
                        ]
                    },
                    "description": "An object hash that is merged into the built-in mime information from\n{@link https://github.com/jshttp/mime-db}.\n\nEach key value pair represents a single mime object override.\n\nEach override entry should follow this schema:\n * The key is the lower-cased correct mime-type. (Ex. \"application/javascript\").\n * The value should be an object following the structure from\n   {@link https://github.com/jshttp/mime-db#data-structure} with additional\n   optional values:\n    * type - Specify the `type` value of result objects, defaults to `key`.\n    * predicate - Method that is called with mime entry on lookup, that\n      must return an entry. This allows you make customizations to `mime`\n      based on developer criteria.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "MongoClient": {
            "description": "The **MongoClient** class is a class that allows for making Connections to MongoDB.",
            "properties": {
                "autoEncrypter": {
                    "$ref": "#/definitions/AutoEncrypter"
                },
                "bsonOptions": {
                    "$ref": "#/definitions/BSONSerializeOptions"
                },
                "options": {
                    "$ref": "#/definitions/MongoOptions"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                },
                "serverApi": {
                    "$ref": "#/definitions/ServerApi"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                }
            },
            "required": [
                "bsonOptions",
                "options",
                "readPreference"
            ],
            "type": "object"
        },
        "MongoConnectionOptions": {
            "description": "MongoDB specific connection options.\nSynced with http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html",
            "properties": {
                "acceptableLatencyMS": {
                    "description": "Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms).\nDefault: 15",
                    "type": "number"
                },
                "appname": {
                    "description": "The name of the application that created this MongoClient instance. MongoDB 3.4 and newer will print this value in the server log upon establishing each connection. It is also recorded in the slow query log and profile collections",
                    "type": "string"
                },
                "authMechanism": {
                    "description": "Sets the authentication mechanism that MongoDB will use to authenticate the connection",
                    "type": "string"
                },
                "authSource": {
                    "description": "If the database authentication is dependent on another databaseName.",
                    "type": "string"
                },
                "autoEncryption": {
                    "description": "Automatic Client-Side Field Level Encryption configuration."
                },
                "autoReconnect": {
                    "description": "Reconnect on error. Default: true",
                    "type": "boolean"
                },
                "auto_reconnect": {
                    "description": "Enable auto reconnecting for single server instances. Default: true",
                    "type": "boolean"
                },
                "bufferMaxEntries": {
                    "description": "Sets a cap on how many operations the driver will buffer up before giving up on getting a working connection,\ndefault is -1 which is unlimited.",
                    "type": "number"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "checkServerIdentity": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function\nDefault: true"
                },
                "compression": {
                    "description": "Type of compression to use: snappy or zlib"
                },
                "connectTimeoutMS": {
                    "description": "TCP Connection timeout setting. Default: 30000",
                    "type": "number"
                },
                "connectWithNoPrimary": {
                    "description": "Sets if the driver should connect even if no primary is available. Default: false",
                    "type": "boolean"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "directConnection": {
                    "description": "Specifies whether to force dispatch all operations to the specified host. Default: false",
                    "type": "boolean"
                },
                "domainsEnabled": {
                    "description": "Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit. Default: false",
                    "type": "boolean"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"mongodb\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "family": {
                    "description": "Version of IP stack. Can be 4, 6.\nIf undefined, will attempt to connect with IPv6, and will fall back to IPv4 on failure",
                    "type": "number"
                },
                "forceServerObjectId": {
                    "description": "Force server to assign _id values instead of driver. Default: false",
                    "type": "boolean"
                },
                "fsync": {
                    "description": "Specify a file sync write concern. Default: false",
                    "type": "boolean"
                },
                "ha": {
                    "description": "Control if high availability monitoring runs for Replicaset or Mongos proxies. Default true",
                    "type": "boolean"
                },
                "haInterval": {
                    "description": "The High availability period for replicaset inquiry. Default: 10000",
                    "type": "number"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "hostReplicaSet": {
                    "description": "Database host replica set.",
                    "type": "string"
                },
                "ignoreUndefined": {
                    "description": "Specify if the BSON serializer should ignore undefined fields. Default: false",
                    "type": "boolean"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "j": {
                    "description": "Specify a journal write concern. Default: false",
                    "type": "boolean"
                },
                "keepAlive": {
                    "description": "The number of milliseconds to wait before initiating keepAlive on the TCP socket. Default: 30000",
                    "type": "number"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "loggerLevel": {
                    "description": "Specify the log level used by the driver logger (error/warn/info/debug).",
                    "enum": [
                        "debug",
                        "error",
                        "info",
                        "warn"
                    ],
                    "type": "string"
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "maxStalenessSeconds": {
                    "description": "Specify a maxStalenessSeconds value for secondary reads, minimum is 90 seconds",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "minSize": {
                    "description": "If present, the connection pool will be initialized with minSize connections, and will never dip below minSize connections",
                    "type": "number"
                },
                "monitorCommands": {
                    "description": "Enable command monitoring for this client. Default: false",
                    "type": "boolean"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "noDelay": {
                    "description": "TCP Socket NoDelay option. Default: true",
                    "type": "boolean"
                },
                "numberOfRetries": {
                    "description": "The number of retries for a tailable cursor. Default: 5",
                    "type": "number"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "pkFactory": {
                    "description": "A primary key factory object for generation of custom _id keys."
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "promiseLibrary": {
                    "description": "A Promise library class the application wishes to use such as Bluebird, must be ES6 compatible."
                },
                "promoteBuffers": {
                    "description": "Promotes Binary BSON values to native Node Buffers. Default: false",
                    "type": "boolean"
                },
                "promoteLongs": {
                    "description": "Promotes Long values to number if they fit inside the 53 bits resolution. Default: true",
                    "type": "boolean"
                },
                "promoteValues": {
                    "description": "Promotes BSON values to native types where possible, set to false to only receive wrapper types. Default: true",
                    "type": "boolean"
                },
                "raw": {
                    "description": "Return document results as raw BSON buffers. Default: false",
                    "type": "boolean"
                },
                "readConcern": {
                    "description": "Specify a read concern for the collection. (only MongoDB 3.2 or higher supported)."
                },
                "readPreference": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ReadPreference"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY,\nReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST)."
                },
                "readPreferenceTags": {
                    "description": "Read preference tags",
                    "items": {},
                    "type": "array"
                },
                "reconnectInterval": {
                    "description": "Server will wait #milliseconds between retries. Default 1000",
                    "type": "number"
                },
                "reconnectTries": {
                    "description": "Server attempt to reconnect #times. Default 30",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replicaSet": {
                    "description": "The name of the replicaset to connect to",
                    "type": "string"
                },
                "retryWrites": {
                    "description": "Enables or disables the ability to retry writes upon encountering transient network errors.",
                    "type": "boolean"
                },
                "secondaryAcceptableLatencyMS": {
                    "description": "Sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms).\nDefault: 15",
                    "type": "number"
                },
                "serializeFunctions": {
                    "description": "Serialize functions on any object. Default: false",
                    "type": "boolean"
                },
                "socketTimeoutMS": {
                    "description": "TCP Socket timeout setting. Default: 360000",
                    "type": "number"
                },
                "ssl": {
                    "description": "Use ssl connection (needs to have a mongod server with ssl support). Default: false",
                    "type": "boolean"
                },
                "sslCA": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Array of valid certificates either as Buffers or Strings\n(needs to have a mongod server with ssl support, 2.4 or higher)."
                },
                "sslCRL": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "SSL Certificate revocation list binary buffer\n(needs to have a mongod server with ssl support, 2.4 or higher)"
                },
                "sslCert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "String or buffer containing the certificate we wish to present\n(needs to have a mongod server with ssl support, 2.4 or higher)"
                },
                "sslKey": {
                    "description": "String or buffer containing the certificate private key we wish to present\n(needs to have a mongod server with ssl support, 2.4 or higher)",
                    "type": "string"
                },
                "sslPass": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "String or buffer containing the certificate password\n(needs to have a mongod server with ssl support, 2.4 or higher)"
                },
                "sslValidate": {
                    "description": "Validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher).\nDefault: true",
                    "type": "boolean"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "mongodb",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "useNewUrlParser": {
                    "description": "Determines whether or not to use the new url parser. Default: false",
                    "type": "boolean"
                },
                "useUnifiedTopology": {
                    "description": "Determines whether or not to use the new Server Discovery and Monitoring engine. Default: false\nhttps://github.com/mongodb/node-mongodb-native/releases/tag/v3.2.1",
                    "type": "boolean"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                },
                "validateOptions": {
                    "description": "Validate MongoClient passed in options for correctness. Default: false"
                },
                "w": {
                    "description": "The write concern.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "wtimeout": {
                    "description": "The write concern timeout value.",
                    "type": "number"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "MongoCredentials": {
            "description": "A representation of the credentials used by MongoDB",
            "properties": {
                "mechanism": {
                    "$ref": "#/definitions/AuthMechanism",
                    "description": "The method used to authenticate"
                },
                "mechanismProperties": {
                    "$ref": "#/definitions/AuthMechanismProperties",
                    "description": "Special properties used by some types of auth mechanisms"
                },
                "password": {
                    "description": "The password used for authentication",
                    "type": "string"
                },
                "source": {
                    "description": "The database that the user should authenticate against",
                    "type": "string"
                },
                "username": {
                    "description": "The username used for authentication",
                    "type": "string"
                }
            },
            "required": [
                "mechanism",
                "mechanismProperties",
                "password",
                "source",
                "username"
            ],
            "type": "object"
        },
        "MongoEntityManager": {
            "description": "Entity manager supposed to work with any entity, automatically find its repository and call its methods,\nwhatever entity type are you passing.\n\nThis implementation is used for MongoDB driver which has some specifics in its EntityManager.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "callAggregateFun": {},
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection used by this entity manager."
                },
                "mongoQueryRunner": {
                    "$ref": "#/definitions/MongoQueryRunner"
                },
                "plainObjectToEntityTransformer": {
                    "$ref": "#/definitions/PlainObjectToNewEntityTransformer",
                    "description": "Plain to object transformer used in create and merge operations."
                },
                "queryRunner": {
                    "$ref": "#/definitions/QueryRunner",
                    "description": "Custom query runner to be used for operations in this entity manager.\nUsed only in non-global entity manager."
                },
                "repositories": {
                    "$ref": "#/definitions/Map<EntityTarget<any>,Repository<any>>",
                    "description": "Once created and then reused by repositories.\nCreated as a future replacement for the #repositories to provide a bit more perf optimization."
                },
                "treeRepositories": {
                    "description": "Once created and then reused by repositories.",
                    "items": {
                        "$ref": "#/definitions/TreeRepository<any>"
                    },
                    "type": "array"
                }
            },
            "required": [
                "@instanceof",
                "callAggregateFun",
                "connection",
                "mongoQueryRunner",
                "plainObjectToEntityTransformer",
                "repositories",
                "treeRepositories"
            ],
            "type": "object"
        },
        "MongoOptions": {
            "description": "Mongo Client Options",
            "properties": {
                "ALPNProtocols": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "additionalProperties": false,
                                "patternProperties": {
                                    "^[0-9]+$": {
                                        "type": "number"
                                    }
                                },
                                "properties": {
                                    "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                    },
                                    "__@toStringTag@25": {
                                        "const": "Uint8Array",
                                        "type": "string"
                                    },
                                    "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                    },
                                    "byteLength": {
                                        "type": "number"
                                    },
                                    "byteOffset": {
                                        "type": "number"
                                    },
                                    "length": {
                                        "type": "number"
                                    }
                                },
                                "required": [
                                    "BYTES_PER_ELEMENT",
                                    "__@toStringTag@25",
                                    "buffer",
                                    "byteLength",
                                    "byteOffset",
                                    "length"
                                ],
                                "type": "object"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "An array of strings or a Buffer naming possible ALPN protocols.\n(Protocols should be ordered by their priority.)"
                },
                "appName": {
                    "type": "string"
                },
                "autoEncrypter": {
                    "$ref": "#/definitions/AutoEncrypter"
                },
                "autoEncryption": {
                    "$ref": "#/definitions/AutoEncryptionOptions",
                    "description": "Optionally enable in-use auto encryption"
                },
                "ca": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Optionally override the trusted CA certificates. Default is to trust\nthe well-known CAs curated by Mozilla. Mozilla's CAs are completely\nreplaced when CAs are explicitly specified using this option."
                },
                "cert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Cert chains in PEM format. One cert chain should be provided per\nprivate key. Each cert chain should consist of the PEM formatted\ncertificate for a provided private key, followed by the PEM\nformatted intermediate certificates (if any), in order, and not\nincluding the root CA (the root CA must be pre-known to the peer,\nsee ca). When providing multiple cert chains, they do not have to\nbe in the same order as their private keys in key. If the\nintermediate certificates are not provided, the peer will not be\nable to validate the certificate, and the handshake will fail."
                },
                "checkServerIdentity": {
                    "description": "Verifies the certificate `cert` is issued to `hostname`.\n\nReturns [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) object, populating it with `reason`, `host`, and `cert` on\nfailure. On success, returns [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type).\n\nThis function is intended to be used in combination with the`checkServerIdentity` option that can be passed to {@link connect} and as\nsuch operates on a `certificate object`. For other purposes, consider using `x509.checkHost()` instead.\n\nThis function can be overwritten by providing an alternative function as the `options.checkServerIdentity` option that is passed to `tls.connect()`. The\noverwriting function can call `tls.checkServerIdentity()` of course, to augment\nthe checks done with additional verification.\n\nThis function is only called if the certificate passed all other checks, such as\nbeing issued by trusted CA (`options.ca`).\n\nEarlier versions of Node.js incorrectly accepted certificates for a given`hostname` if a matching `uniformResourceIdentifier` subject alternative name\nwas present (see [CVE-2021-44531](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531)). Applications that wish to accept`uniformResourceIdentifier` subject alternative names can use\na custom `options.checkServerIdentity` function that implements the desired behavior.",
                    "type": "object"
                },
                "ciphers": {
                    "description": "Cipher suite specification, replacing the default. For more\ninformation, see modifying the default cipher suite. Permitted\nciphers can be obtained via tls.getCiphers(). Cipher names must be\nuppercased in order for OpenSSL to accept them.",
                    "type": "string"
                },
                "compressors": {
                    "items": {
                        "enum": [
                            "none",
                            "snappy",
                            "zlib",
                            "zstd"
                        ],
                        "type": "string"
                    },
                    "type": "array"
                },
                "connectTimeoutMS": {
                    "description": "The time in milliseconds to attempt a connection before timing out.",
                    "type": "number"
                },
                "credentials": {
                    "$ref": "#/definitions/MongoCredentials",
                    "description": "A representation of the credentials used by MongoDB"
                },
                "crl": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                },
                "dbName": {
                    "type": "string"
                },
                "directConnection": {
                    "description": "Allow a driver to force a Single topology type with a connection string containing one host",
                    "type": "boolean"
                },
                "driverInfo": {
                    "$ref": "#/definitions/DriverInfo",
                    "description": "Allows a wrapping driver to amend the client metadata generated by the driver to include information about the wrapping driver"
                },
                "ecdhCurve": {
                    "description": "A string describing a named curve or a colon separated list of curve\nNIDs or names, for example P-521:P-384:P-256, to use for ECDH key\nagreement. Set to auto to select the curve automatically. Use\ncrypto.getCurves() to obtain a list of available curve names. On\nrecent releases, openssl ecparam -list_curves will also display the\nname and description of each available elliptic curve. Default:\ntls.DEFAULT_ECDH_CURVE.",
                    "type": "string"
                },
                "family": {
                    "type": "number"
                },
                "forceServerObjectId": {
                    "description": "Force server to assign `_id` values instead of driver",
                    "type": "boolean"
                },
                "heartbeatFrequencyMS": {
                    "description": "heartbeatFrequencyMS controls when the driver checks the state of the MongoDB deployment. Specify the interval (in milliseconds) between checks, counted from the end of the previous check until the beginning of the next one.",
                    "type": "number"
                },
                "hints": {
                    "type": "number"
                },
                "hosts": {
                    "items": {
                        "$ref": "#/definitions/HostAddress"
                    },
                    "type": "array"
                },
                "keepAlive": {
                    "description": "TCP Connection keep alive enabled",
                    "type": "boolean"
                },
                "keepAliveInitialDelay": {
                    "description": "The number of milliseconds to wait before initiating keepAlive on the TCP socket",
                    "type": "number"
                },
                "key": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/KeyObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format. PEM allows the option of private keys\nbeing encrypted. Encrypted keys will be decrypted with\noptions.passphrase. Multiple keys using different algorithms can be\nprovided either as an array of unencrypted key strings or buffers,\nor an array of objects in the form {pem: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted keys will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "loadBalanced": {
                    "type": "boolean"
                },
                "localAddress": {
                    "type": "string"
                },
                "localPort": {
                    "type": "number"
                },
                "localThresholdMS": {
                    "description": "The size (in milliseconds) of the latency window for selecting among multiple suitable MongoDB instances.",
                    "type": "number"
                },
                "lookup": {
                    "type": "object"
                },
                "maxConnecting": {
                    "description": "The maximum number of connections that may be in the process of being established concurrently by the connection pool.",
                    "type": "number"
                },
                "maxIdleTimeMS": {
                    "description": "The maximum number of milliseconds that a connection can remain idle in the pool before being removed and closed.",
                    "type": "number"
                },
                "maxPoolSize": {
                    "description": "The maximum number of connections in the connection pool.",
                    "type": "number"
                },
                "metadata": {
                    "$ref": "#/definitions/ClientMetadata"
                },
                "minDHSize": {
                    "type": "number"
                },
                "minHeartbeatFrequencyMS": {
                    "description": "Sets the minimum heartbeat frequency. In the event that the driver has to frequently re-check a server's availability, it will wait at least this long since the previous check to avoid wasted effort.",
                    "type": "number"
                },
                "minPoolSize": {
                    "description": "The minimum number of connections in the connection pool.",
                    "type": "number"
                },
                "monitorCommands": {
                    "description": "Enable command monitoring for this client",
                    "type": "boolean"
                },
                "noDelay": {
                    "description": "TCP Connection no delay",
                    "type": "boolean"
                },
                "passphrase": {
                    "description": "Shared passphrase used for a single private key and/or a PFX.",
                    "type": "string"
                },
                "pfx": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/PxfObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an\nalternative to providing key and cert individually. PFX is usually\nencrypted, if it is, passphrase will be used to decrypt it. Multiple\nPFX can be provided either as an array of unencrypted PFX buffers,\nor an array of objects in the form {buf: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted PFX will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "pkFactory": {
                    "$ref": "#/definitions/PkFactory",
                    "description": "A primary key factory function for generation of custom `_id` keys"
                },
                "proxyHost": {
                    "type": "string"
                },
                "proxyPassword": {
                    "type": "string"
                },
                "proxyPort": {
                    "type": "number"
                },
                "proxyUsername": {
                    "type": "string"
                },
                "raw": {
                    "description": "Enabling the raw option will return a [Node.js Buffer](https://nodejs.org/api/buffer.html)\nwhich is allocated using [allocUnsafe API](https://nodejs.org/api/buffer.html#static-method-bufferallocunsafesize).\nSee this section from the [Node.js Docs here](https://nodejs.org/api/buffer.html#what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe)\nfor more detail about what \"unsafe\" refers to in this context.\nIf you need to maintain your own editable clone of the bytes returned for an extended life time of the process, it is recommended you allocate\nyour own buffer and clone the contents:",
                    "type": "boolean"
                },
                "readConcern": {
                    "$ref": "#/definitions/ReadConcern"
                },
                "readPreference": {
                    "$ref": "#/definitions/ReadPreference"
                },
                "rejectUnauthorized": {
                    "default": true,
                    "description": "If true the server will reject any connection which is not\nauthorized with the list of supplied CAs. This option only has an\neffect if requestCert is true.",
                    "type": "boolean"
                },
                "replicaSet": {
                    "description": "Specifies the name of the replica set, if the mongod is a member of a replica set.",
                    "type": "string"
                },
                "retryReads": {
                    "description": "Enables retryable reads.",
                    "type": "boolean"
                },
                "retryWrites": {
                    "description": "Enable retryable writes.",
                    "type": "boolean"
                },
                "secureContext": {
                    "$ref": "#/definitions/SecureContext",
                    "description": "An optional TLS context object from tls.createSecureContext()"
                },
                "secureProtocol": {
                    "description": "Legacy mechanism to select the TLS protocol version to use, it does\nnot support independent control of the minimum and maximum version,\nand does not support limiting the protocol to TLSv1.3. Use\nminVersion and maxVersion instead. The possible values are listed as\nSSL_METHODS, use the function names as strings. For example, use\n'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\nany TLS protocol version up to TLSv1.3. It is not recommended to use\nTLS versions less than 1.2, but it may be required for\ninteroperability. Default: none, see minVersion.",
                    "type": "string"
                },
                "serverApi": {
                    "$ref": "#/definitions/ServerApi"
                },
                "serverSelectionTimeoutMS": {
                    "description": "Specifies how long (in milliseconds) to block for server selection before throwing an exception.",
                    "type": "number"
                },
                "servername": {
                    "type": "string"
                },
                "session": {
                    "additionalProperties": false,
                    "description": "An optional Buffer instance containing a TLS session.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@25": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "BYTES_PER_ELEMENT",
                        "__@toStringTag@25",
                        "buffer",
                        "byteLength",
                        "byteOffset",
                        "length"
                    ],
                    "type": "object"
                },
                "socketTimeoutMS": {
                    "description": "The time in milliseconds to attempt a send or receive on a socket before the attempt times out.",
                    "type": "number"
                },
                "srvHost": {
                    "type": "string"
                },
                "srvMaxHosts": {
                    "description": "The maximum number of hosts to connect to when using an srv connection string, a setting of `0` means unlimited hosts",
                    "type": "number"
                },
                "srvServiceName": {
                    "description": "Modifies the srv URI to look like:\n\n`_{srvServiceName}._tcp.{hostname}.{domainname}`\n\nQuerying this DNS URI is expected to respond with SRV records",
                    "type": "string"
                },
                "tls": {
                    "description": "# NOTE ABOUT TLS Options\n\nIf set TLS enabled, equivalent to setting the ssl option.\n\n### Additional options:\n\n|    nodejs option     | MongoDB equivalent                                       | type                                   |\n|:---------------------|--------------------------------------------------------- |:---------------------------------------|\n| `ca`                 | `sslCA`, `tlsCAFile`                                     | `string \\| Buffer \\| Buffer[]`         |\n| `crl`                | `sslCRL`                                                 | `string \\| Buffer \\| Buffer[]`         |\n| `cert`               | `sslCert`, `tlsCertificateFile`, `tlsCertificateKeyFile` | `string \\| Buffer \\| Buffer[]`         |\n| `key`                | `sslKey`, `tlsCertificateKeyFile`                        | `string \\| Buffer \\| KeyObject[]`      |\n| `passphrase`         | `sslPass`, `tlsCertificateKeyFilePassword`               | `string`                               |\n| `rejectUnauthorized` | `sslValidate`                                            | `boolean`                              |",
                    "type": "boolean"
                },
                "tlsAllowInvalidCertificates": {
                    "description": "Bypasses validation of the certificates presented by the mongod/mongos instance",
                    "type": "boolean"
                },
                "tlsAllowInvalidHostnames": {
                    "description": "Disables hostname validation of the certificate presented by the mongod/mongos instance.",
                    "type": "boolean"
                },
                "tlsInsecure": {
                    "description": "Disables various certificate validations.",
                    "type": "boolean"
                },
                "waitQueueTimeoutMS": {
                    "description": "The maximum time in milliseconds that a thread can wait for a connection to become available.",
                    "type": "number"
                },
                "writeConcern": {
                    "$ref": "#/definitions/WriteConcern"
                },
                "zlibCompressionLevel": {
                    "description": "An integer that specifies the compression level if using zlib for network compression.",
                    "enum": [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9
                    ],
                    "type": "number"
                }
            },
            "required": [
                "autoEncryption",
                "compressors",
                "connectTimeoutMS",
                "dbName",
                "directConnection",
                "driverInfo",
                "forceServerObjectId",
                "heartbeatFrequencyMS",
                "hosts",
                "keepAlive",
                "keepAliveInitialDelay",
                "loadBalanced",
                "localThresholdMS",
                "maxConnecting",
                "maxIdleTimeMS",
                "maxPoolSize",
                "metadata",
                "minHeartbeatFrequencyMS",
                "minPoolSize",
                "monitorCommands",
                "noDelay",
                "pkFactory",
                "raw",
                "readConcern",
                "readPreference",
                "replicaSet",
                "retryReads",
                "retryWrites",
                "serverApi",
                "serverSelectionTimeoutMS",
                "socketTimeoutMS",
                "srvMaxHosts",
                "srvServiceName",
                "tls",
                "tlsAllowInvalidCertificates",
                "tlsAllowInvalidHostnames",
                "tlsInsecure",
                "waitQueueTimeoutMS",
                "writeConcern",
                "zlibCompressionLevel"
            ],
            "type": "object"
        },
        "MongoQueryRunner": {
            "description": "Runs queries on a single MongoDB connection.",
            "properties": {
                "broadcaster": {
                    "$ref": "#/definitions/Broadcaster",
                    "description": "Broadcaster used on this query runner to broadcast entity events."
                },
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection used by this query runner."
                },
                "data": {
                    "description": "Stores temporarily user data.\nUseful for sharing data with subscribers.",
                    "properties": {},
                    "type": "object"
                },
                "databaseConnection": {
                    "$ref": "#/definitions/MongoClient",
                    "description": "Real database connection from a connection pool used to perform queries."
                },
                "isReleased": {
                    "description": "Indicates if connection for this query runner is released.\nOnce its released, query runner cannot run queries anymore.\nAlways false for mongodb since mongodb has a single query executor instance.",
                    "type": "boolean"
                },
                "isTransactionActive": {
                    "description": "Indicates if transaction is active in this query executor.\nAlways false for mongodb since mongodb does not support transactions.",
                    "type": "boolean"
                },
                "loadedTables": {
                    "description": "All synchronized tables in the database.",
                    "items": {
                        "$ref": "#/definitions/Table"
                    },
                    "type": "array"
                },
                "loadedViews": {
                    "description": "All synchronized views in the database.",
                    "items": {
                        "$ref": "#/definitions/View"
                    },
                    "type": "array"
                },
                "manager": {
                    "$ref": "#/definitions/MongoEntityManager",
                    "description": "Entity manager working only with current query runner."
                }
            },
            "required": [
                "broadcaster",
                "connection",
                "data",
                "databaseConnection",
                "isReleased",
                "isTransactionActive",
                "loadedTables",
                "loadedViews",
                "manager"
            ],
            "type": "object"
        },
        "MysqlConnectionCredentialsOptions": {
            "description": "MySQL specific connection credential options.",
            "properties": {
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "socketPath": {
                    "description": "Database socket path",
                    "type": "string"
                },
                "ssl": {
                    "description": "Object with ssl parameters or a string containing name of ssl profile."
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "MysqlConnectionOptions": {
            "description": "MySQL specific connection options.",
            "properties": {
                "acquireTimeout": {
                    "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)\nThis difference between connectTimeout and acquireTimeout is subtle and is described in the mysqljs/mysql docs\nhttps://github.com/mysqljs/mysql/tree/master#pool-options",
                    "type": "number"
                },
                "bigNumberStrings": {
                    "description": "Enabling both supportBigNumbers and bigNumberStrings forces big numbers (BIGINT and DECIMAL columns) to be always\nreturned as JavaScript String objects (Default: false). Enabling supportBigNumbers but leaving bigNumberStrings\ndisabled will return big numbers as String objects only when they cannot be accurately represented with\n[JavaScript Number objects](http://ecma262-5.com/ELS5_HTML.htm#Section_8.5) (which happens when they exceed the [-2^53, +2^53] range),\notherwise they will be returned as Number objects. This option is ignored if supportBigNumbers is disabled.",
                    "type": "boolean"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "charset": {
                    "description": "The charset for the connection. This is called \"collation\" in the SQL-level of MySQL (like utf8_general_ci).\nIf a SQL-level charset is specified (like utf8mb4) then the default collation for that charset is used.\nDefault: 'UTF8_GENERAL_CI'",
                    "type": "string"
                },
                "connectTimeout": {
                    "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)",
                    "type": "number"
                },
                "connectorPackage": {
                    "description": "TypeORM will automatically use package found in your node_modules, prioritizing mysql over mysql2,\nbut you can specify it manually",
                    "enum": [
                        "mysql",
                        "mysql2"
                    ],
                    "type": "string"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "dateStrings": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then inflated into JavaScript Date objects.\nCan be true/false or an array of type names to keep as strings."
                },
                "debug": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Prints protocol details to stdout. Can be true/false or an array of packet type names that should be printed.\n(Default: false)"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"mysql\").\nFalls back to require(\"mysql2\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "flags": {
                    "description": "List of connection flags to use other than the default ones. It is also possible to blacklist default ones.\nFor more information, check https://github.com/mysqljs/mysql#connection-flags.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "insecureAuth": {
                    "description": "Allow connecting to MySQL instances that ask for the old (insecure) authentication method. (Default: false)",
                    "type": "boolean"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "legacySpatialSupport": {
                    "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8.\n(Default: true)",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "multipleStatements": {
                    "description": "Allow multiple mysql statements per query. Be careful with this, it could increase the scope of SQL injection attacks.\n(Default: false)",
                    "type": "boolean"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "canRetry": {
                            "description": "If true, PoolCluster will attempt to reconnect when connection fails. (Default: true)",
                            "type": "boolean"
                        },
                        "defaultMode": {
                            "default": "slave",
                            "description": "Default connection pool to use for SELECT queries",
                            "enum": [
                                "master",
                                "slave"
                            ],
                            "type": "string"
                        },
                        "master": {
                            "$ref": "#/definitions/MysqlConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "removeNodeErrorCount": {
                            "description": "If connection fails, node's errorCount increases.\nWhen errorCount is greater than removeNodeErrorCount, remove a node in the PoolCluster. (Default: 5)",
                            "type": "number"
                        },
                        "restoreNodeTimeout": {
                            "description": "If connection fails, specifies the number of milliseconds before another connection attempt will be made.\nIf set to 0, then node will be removed instead and never re-used. (Default: 0)",
                            "type": "number"
                        },
                        "selector": {
                            "description": "Determines how slaves are selected:\nRR: Select one alternately (Round-Robin).\nRANDOM: Select the node by random function.\nORDER: Select the first node available unconditionally.",
                            "enum": [
                                "ORDER",
                                "RANDOM",
                                "RR"
                            ],
                            "type": "string"
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/MysqlConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "socketPath": {
                    "description": "Database socket path",
                    "type": "string"
                },
                "ssl": {
                    "description": "Object with ssl parameters or a string containing name of ssl profile."
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "supportBigNumbers": {
                    "description": "When dealing with big numbers (BIGINT and DECIMAL columns) in the database, you should enable this option (Default: false)",
                    "type": "boolean"
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "timezone": {
                    "description": "The timezone configured on the MySQL server.\nThis is used to type cast server date/time values to JavaScript Date object and vice versa.\nThis can be 'local', 'Z', or an offset in the form +HH:MM or -HH:MM. (Default: 'local')",
                    "type": "string"
                },
                "trace": {
                    "description": "Generates stack traces on Error to include call site of library entrance (\"long stack traces\").\nSlight performance penalty for most calls. (Default: true)",
                    "type": "boolean"
                },
                "type": {
                    "description": "Database type.",
                    "enum": [
                        "mariadb",
                        "mysql"
                    ],
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "NamingStrategyInterface": {
            "description": "Naming strategy defines how auto-generated names for such things like table name, or table column gonna be\ngenerated.",
            "properties": {
                "materializedPathColumnName": {
                    "description": "Column name for materialized paths.",
                    "type": "string"
                },
                "name": {
                    "description": "Naming strategy name.",
                    "type": "string"
                },
                "nestedSetColumnNames": {
                    "description": "Column names for nested sets.",
                    "properties": {
                        "left": {
                            "type": "string"
                        },
                        "right": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "left",
                        "right"
                    ],
                    "type": "object"
                }
            },
            "required": [
                "materializedPathColumnName",
                "nestedSetColumnNames"
            ],
            "type": "object"
        },
        "NativescriptConnectionOptions": {
            "description": "NativeScript-specific connection options.",
            "properties": {
                "androidFlags": {
                    "description": "Flags to pass to SQLite when opening the database on Android. (see https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)",
                    "type": "number"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nyou should pass `require('nativescript-sqlite') here"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "iosFlags": {
                    "description": "Flags to pass to SQLite when opening the database on iOS. (see https://www.sqlite.org/c3ref/open.html)",
                    "type": "number"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "key": {
                    "description": "The key to use for for using/opening encrypted databases. (requires the \"Encrypted Plugin\")",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrate": {
                    "description": "Migrates a Encrypted Sql database from v3 to the new v4. If you are a new user you do not need to set this flag as new created databases will already be in v4.\nIf you are upgrading a app that used v1.3.0 or earlier of NS-Sqlite-Encrypted; then you will probably want to set this flag to true. (requires the \"Encrypted Plugin\")",
                    "type": "boolean"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "multithreading": {
                    "description": "Whether to enable background multitasking. All SQL is ran on a background worker thread. (requires the \"Commercial Plugin\")",
                    "type": "boolean"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "readOnly": {
                    "description": "Whether to mark the mark the database as read only on open (iOS only).",
                    "type": "boolean"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "nativescript",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "driver",
                "type"
            ],
            "type": "object"
        },
        "NodeJS.Dict<string>": {
            "additionalProperties": {
                "$ref": "#/definitions/T_1"
            },
            "type": "object"
        },
        "NodeJS.Dict<string[]>": {
            "additionalProperties": {
                "$ref": "#/definitions/T_1"
            },
            "type": "object"
        },
        "NtlmAuthentication": {
            "properties": {
                "options": {
                    "properties": {
                        "domain": {
                            "description": "Once you set domain for ntlm authentication type, driver will connect to SQL Server using domain login.\n\nThis is necessary for forming a connection using ntlm type",
                            "type": "string"
                        },
                        "password": {
                            "description": "Password from your windows account.",
                            "type": "string"
                        },
                        "userName": {
                            "description": "User name from your windows account.",
                            "type": "string"
                        }
                    },
                    "required": [
                        "domain",
                        "password",
                        "userName"
                    ],
                    "type": "object"
                },
                "type": {
                    "const": "ntlm",
                    "type": "string"
                }
            },
            "required": [
                "options",
                "type"
            ],
            "type": "object"
        },
        "Number": {
            "type": "object"
        },
        "NumberConstructor": {
            "properties": {
                "EPSILON": {
                    "type": "number"
                },
                "MAX_SAFE_INTEGER": {
                    "type": "number"
                },
                "MAX_VALUE": {
                    "type": "number"
                },
                "MIN_SAFE_INTEGER": {
                    "type": "number"
                },
                "MIN_VALUE": {
                    "type": "number"
                },
                "NEGATIVE_INFINITY": {
                    "type": "number"
                },
                "NaN": {
                    "type": "number"
                },
                "POSITIVE_INFINITY": {
                    "type": "number"
                },
                "prototype": {
                    "$ref": "#/definitions/Number"
                }
            },
            "required": [
                "EPSILON",
                "MAX_SAFE_INTEGER",
                "MAX_VALUE",
                "MIN_SAFE_INTEGER",
                "MIN_VALUE",
                "NEGATIVE_INFINITY",
                "NaN",
                "POSITIVE_INFINITY",
                "prototype"
            ],
            "type": "object"
        },
        "NumberSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/NumberSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/NumberSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "Object": {
            "properties": {
                "constructor": {
                    "$ref": "#/definitions/Function"
                }
            },
            "required": [
                "constructor"
            ],
            "type": "object"
        },
        "ObjectLiteral": {
            "additionalProperties": {},
            "description": "Interface of the simple literal object with any string keys.",
            "type": "object"
        },
        "ObjectSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/ObjectSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/ObjectSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "OnDeleteType": {
            "description": "ON_DELETE type to be used to specify delete strategy when some relation is being deleted from the database.",
            "enum": [
                "CASCADE",
                "DEFAULT",
                "NO ACTION",
                "RESTRICT",
                "SET NULL"
            ],
            "type": "string"
        },
        "OnUpdateType": {
            "description": "ON_UPDATE type to be used to specify update strategy when some relation is being updated.",
            "enum": [
                "CASCADE",
                "DEFAULT",
                "NO ACTION",
                "RESTRICT",
                "SET NULL"
            ],
            "type": "string"
        },
        "OracleConnectionCredentialsOptions": {
            "description": "Oracle specific connection credential options.",
            "properties": {
                "connectString": {
                    "description": "Embedded TNS Connection String",
                    "type": "string"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "serviceName": {
                    "description": "Connection Service Name.",
                    "type": "string"
                },
                "sid": {
                    "description": "Connection SID.",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "OracleConnectionOptions": {
            "description": "Oracle-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "connectString": {
                    "description": "Embedded TNS Connection String",
                    "type": "string"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"oracledb\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "master": {
                            "$ref": "#/definitions/OracleConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/OracleConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "schema": {
                    "description": "Schema name. By default is \"public\".",
                    "type": "string"
                },
                "serviceName": {
                    "description": "Connection Service Name.",
                    "type": "string"
                },
                "sid": {
                    "description": "Connection SID.",
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "thickMode": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/OracleThickModeOptions"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Utilize the thick driver. Starting from oracledb version 6, it's necessary to set this to true when opting for the thick client usage.\nAlternatively, an 'OracleThickModeOptions' object can be configured, which is used for the thick mode configuration by passing it to the 'node-oracledb' driver.\nFor additional information, refer to the details provided in the following link:\n(https://node-oracledb.readthedocs.io/en/latest/api_manual/oracledb.html#oracledb.initOracleClient)"
                },
                "type": {
                    "const": "oracle",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "useUTC": {
                    "description": "A boolean determining whether to pass time values in UTC or local time. (default: false).",
                    "type": "boolean"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "OracleThickModeOptions": {
            "properties": {
                "binaryDir": {
                    "type": "string"
                },
                "configDir": {
                    "type": "string"
                },
                "driverName": {
                    "type": "string"
                },
                "errorUrl": {
                    "type": "string"
                },
                "libDir": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "P": {
            "type": "object"
        },
        "PartialSchemaMap<any>": {
            "type": "object"
        },
        "PassThrough": {
            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams.",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
                    "type": "boolean"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "allowHalfOpen",
                "closed",
                "destroyed",
                "errored",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "PkFactory": {
            "type": "object"
        },
        "PlainObjectToNewEntityTransformer": {
            "description": "Transforms plain old javascript object\nEntity is constructed based on its entity metadata.",
            "properties": {
                "groupAndTransform": {
                    "description": "Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\nwe need to group our result and we must have some unique id (primary key in our case)"
                }
            },
            "required": [
                "groupAndTransform"
            ],
            "type": "object"
        },
        "PluginProperties": {
            "description": "An empty interface to allow typings of custom plugin properties.",
            "type": "object"
        },
        "PluginSpecificConfiguration": {
            "type": "object"
        },
        "PluginsListRegistered": {
            "description": "[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverregistrations)",
            "type": "object"
        },
        "PluginsStates": {
            "type": "object"
        },
        "PostgresConnectionCredentialsOptions": {
            "description": "Postgres specific connection credential options.",
            "properties": {
                "applicationName": {
                    "description": "sets the application_name var to help db administrators identify\nthe service using this connection. Defaults to 'undefined'",
                    "type": "string"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "password": {
                    "description": "Database password.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "ssl": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TlsOptions"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Object with ssl parameters"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "PostgresConnectionOptions": {
            "description": "Postgres-specific connection options.",
            "properties": {
                "applicationName": {
                    "description": "sets the application_name var to help db administrators identify\nthe service using this connection. Defaults to 'undefined'",
                    "type": "string"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "connectTimeoutMS": {
                    "description": "The milliseconds before a timeout occurs during the initial connection to the postgres\nserver. If undefined, or set to 0, there is no timeout. Defaults to undefined.",
                    "type": "number"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to `require(\"pg\")`."
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "installExtensions": {
                    "description": "Automatically install postgres extensions",
                    "type": "boolean"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logNotifications": {
                    "description": "Include notification messages from Postgres server in client logs",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "nativeDriver": {
                    "description": "The driver object\nThis defaults to `require(\"pg-native\")`."
                },
                "parseInt8": {
                    "description": "Return 64-bit integers (int8) as JavaScript integers.\n\nBecause JavaScript doesn't have support for 64-bit integers node-postgres cannot confidently\nparse int8 data type results as numbers because if you have a huge number it will overflow\nand the result you'd get back from node-postgres would not be the result in the database.\nThat would be a very bad thing so node-postgres just returns int8 results as strings and leaves the parsing up to you.\n\nEnabling parseInt8 will cause node-postgres to parse int8 results as numbers.\nNote: the maximum safe integer in js is: Number.MAX_SAFE_INTEGER (`+2^53`)",
                    "type": "boolean"
                },
                "password": {
                    "description": "Database password.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "poolErrorHandler": {
                    "type": "object"
                },
                "poolSize": {
                    "description": "Maximum number of clients the pool should contain.",
                    "type": "number"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "defaultMode": {
                            "default": "slave",
                            "description": "Default connection pool to use for SELECT queries",
                            "enum": [
                                "master",
                                "slave"
                            ],
                            "type": "string"
                        },
                        "master": {
                            "$ref": "#/definitions/PostgresConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/PostgresConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "schema": {
                    "description": "Schema name.",
                    "type": "string"
                },
                "ssl": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/TlsOptions"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Object with ssl parameters"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "postgres",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "useUTC": {
                    "description": "A boolean determining whether to pass time values in UTC or local time. (default: false).",
                    "type": "boolean"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                },
                "uuidExtension": {
                    "description": "The Postgres extension to use to generate UUID columns. Defaults to uuid-ossp.\nIf pgcrypto is selected, TypeORM will use the gen_random_uuid() function from this extension.\nIf uuid-ossp is selected, TypeORM will use the uuid_generate_v4() function from this extension.",
                    "enum": [
                        "pgcrypto",
                        "uuid-ossp"
                    ],
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "PropertyTypeFactory<any>": {
            "description": "Contains the name of the property of the object, or the function that returns this name.",
            "type": [
                "string",
                "object"
            ]
        },
        "ProxyOptions": {
            "properties": {
                "proxyHost": {
                    "type": "string"
                },
                "proxyPassword": {
                    "type": "string"
                },
                "proxyPort": {
                    "type": "number"
                },
                "proxyUsername": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "PxfObject": {
            "properties": {
                "buf": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain."
                },
                "passphrase": {
                    "description": "Optional passphrase.",
                    "type": "string"
                }
            },
            "required": [
                "buf"
            ],
            "type": "object"
        },
        "QueryResultCache": {
            "description": "Implementations of this interface provide different strategies to cache query builder results.",
            "type": "object"
        },
        "QueryRunner": {
            "description": "Runs queries on a single database connection.",
            "properties": {
                "broadcaster": {
                    "$ref": "#/definitions/Broadcaster",
                    "description": "Broadcaster used on this query runner to broadcast entity events."
                },
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection used by this query runner."
                },
                "data": {
                    "$ref": "#/definitions/ObjectLiteral",
                    "description": "Stores temporarily user data.\nUseful for sharing data with subscribers."
                },
                "isReleased": {
                    "description": "Indicates if connection for this query runner is released.\nOnce its released, query runner cannot run queries anymore.",
                    "type": "boolean"
                },
                "isTransactionActive": {
                    "description": "Indicates if transaction is in progress.",
                    "type": "boolean"
                },
                "loadedTables": {
                    "description": "All synchronized tables in the database.",
                    "items": {
                        "$ref": "#/definitions/Table"
                    },
                    "type": "array"
                },
                "loadedViews": {
                    "description": "All synchronized views in the database.",
                    "items": {
                        "$ref": "#/definitions/View"
                    },
                    "type": "array"
                },
                "manager": {
                    "$ref": "#/definitions/EntityManager",
                    "description": "Entity manager working only with this query runner."
                }
            },
            "required": [
                "broadcaster",
                "connection",
                "data",
                "isReleased",
                "isTransactionActive",
                "loadedTables",
                "loadedViews",
                "manager"
            ],
            "type": "object"
        },
        "ReactNativeConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Database name.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"react-native-sqlite-storage\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "location": {
                    "description": "Storage Location",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "react-native",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "location",
                "type"
            ],
            "type": "object"
        },
        "ReadConcern": {
            "description": "The MongoDB ReadConcern, which allows for control of the consistency and isolation properties\nof the data read from replica sets and replica set shards.",
            "properties": {
                "level": {
                    "type": "string"
                }
            },
            "required": [
                "level"
            ],
            "type": "object"
        },
        "ReadPreference": {
            "description": "The **ReadPreference** class is a class that represents a MongoDB ReadPreference and is\nused to construct connections.",
            "properties": {
                "hedge": {
                    "$ref": "#/definitions/HedgeOptions"
                },
                "maxStalenessSeconds": {
                    "type": "number"
                },
                "minWireVersion": {
                    "type": "number"
                },
                "mode": {
                    "$ref": "#/definitions/ReadPreferenceMode"
                },
                "preference": {
                    "$ref": "#/definitions/ReadPreferenceMode"
                },
                "tags": {
                    "items": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "type": "array"
                }
            },
            "required": [
                "mode",
                "preference"
            ],
            "type": "object"
        },
        "ReadPreferenceMode": {
            "enum": [
                "nearest",
                "primary",
                "primaryPreferred",
                "secondary",
                "secondaryPreferred"
            ],
            "type": "string"
        },
        "Readable": {
            "properties": {
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "closed",
                "destroyed",
                "errored",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode"
            ],
            "type": "object"
        },
        "Record<string,RouteOptionsResponseSchema>": {
            "type": "object"
        },
        "Record<string,ServerAuthSchemeObjectApi>": {
            "type": "object"
        },
        "Record<string,any>": {
            "type": "object"
        },
        "Record<string,never>": {
            "type": "object"
        },
        "Record<string,object>": {
            "type": "object"
        },
        "RelationCountMetadata": {
            "description": "Contains all information about entity's relation count.",
            "properties": {
                "alias": {
                    "description": "Alias of the joined (destination) table.",
                    "type": "string"
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata where this column metadata is."
                },
                "propertyName": {
                    "description": "Target's property name to which this metadata is applied.",
                    "type": "string"
                },
                "queryBuilderFactory": {
                    "description": "Extra condition applied to \"ON\" section of join.",
                    "type": "object"
                },
                "relation": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "Relation which needs to be counted."
                },
                "relationNameOrFactory": {
                    "description": "Relation name which need to count.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                }
            },
            "required": [
                "entityMetadata",
                "propertyName",
                "relation",
                "relationNameOrFactory",
                "target"
            ],
            "type": "object"
        },
        "RelationIdLoader": {
            "description": "Loads relation ids for the given entities.",
            "properties": {
                "connection": {},
                "queryRunner": {
                    "$ref": "#/definitions/QueryRunner"
                }
            },
            "required": [
                "connection"
            ],
            "type": "object"
        },
        "RelationIdMetadata": {
            "description": "Contains all information about entity's relation count.",
            "properties": {
                "alias": {
                    "description": "Alias of the joined (destination) table.",
                    "type": "string"
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata where this column metadata is."
                },
                "propertyName": {
                    "description": "Target's property name to which this metadata is applied.",
                    "type": "string"
                },
                "queryBuilderFactory": {
                    "description": "Extra condition applied to \"ON\" section of join.",
                    "type": "object"
                },
                "relation": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "Relation from which ids will be extracted."
                },
                "relationNameOrFactory": {
                    "description": "Relation name which need to count.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                }
            },
            "required": [
                "entityMetadata",
                "propertyName",
                "relation",
                "relationNameOrFactory",
                "target"
            ],
            "type": "object"
        },
        "RelationLoader": {
            "description": "Wraps entities and creates getters/setters for their relations\nto be able to lazily load relations when accessing these relations.",
            "properties": {
                "connection": {}
            },
            "required": [
                "connection"
            ],
            "type": "object"
        },
        "RelationMetadata": {
            "description": "Contains all information about some entity's relation.",
            "properties": {
                "createForeignKeyConstraints": {
                    "description": "Indicates whether foreign key constraints will be created for join columns.\nCan be used only for many-to-one and owner one-to-one relations.\nDefaults to true.",
                    "type": "boolean"
                },
                "deferrable": {
                    "description": "What to do with a relation on update of the row containing a foreign key.",
                    "enum": [
                        "INITIALLY DEFERRED",
                        "INITIALLY IMMEDIATE"
                    ],
                    "type": "string"
                },
                "embeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Embedded metadata where this relation is.\nIf this relation is not in embed then this property value is undefined."
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the entity where this relation is placed.\n\nFor example for"
                },
                "foreignKeys": {
                    "description": "Foreign keys created for this relation.",
                    "items": {
                        "$ref": "#/definitions/ForeignKeyMetadata"
                    },
                    "type": "array"
                },
                "givenInverseSidePropertyFactory": {
                    "$ref": "#/definitions/PropertyTypeFactory<any>",
                    "description": "Inverse side of the relation set by user.\n\nInverse side set in the relation can be either string - property name of the column on inverse side,\neither can be a function that accepts a map of properties with the object and returns one of them.\nSecond approach is used to achieve type-safety."
                },
                "inverseEntityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the entity that is targeted by this relation.\n\nFor example for"
                },
                "inverseJoinColumns": {
                    "description": "Inverse join table columns.\nInverse join columns are supported only for many-to-many relations\nand can be obtained only from owner side of the relation.\nFrom non-owner side of the relation join columns will be undefined.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "inverseRelation": {
                    "$ref": "#/definitions/RelationMetadata",
                    "description": "Gets the relation metadata of the inverse side of this relation."
                },
                "inverseSidePropertyPath": {
                    "description": "Gets the property path of the inverse side of the relation.",
                    "type": "string"
                },
                "isCascadeInsert": {
                    "description": "If set to true then related objects are allowed to be inserted to the database.",
                    "type": "boolean"
                },
                "isCascadeRecover": {
                    "description": "If set to true then related objects are allowed to be recovered from the database.",
                    "type": "boolean"
                },
                "isCascadeRemove": {
                    "description": "If set to true then related objects are allowed to be remove from the database.",
                    "type": "boolean"
                },
                "isCascadeSoftRemove": {
                    "description": "If set to true then related objects are allowed to be soft-removed from the database.",
                    "type": "boolean"
                },
                "isCascadeUpdate": {
                    "description": "If set to true then related objects are allowed to be updated in the database.",
                    "type": "boolean"
                },
                "isEager": {
                    "description": "Indicates if this relation is eagerly loaded.",
                    "type": "boolean"
                },
                "isLazy": {
                    "description": "Indicates if this relation is lazily loaded.",
                    "type": "boolean"
                },
                "isManyToMany": {
                    "description": "Checks if this relation's type is \"many-to-many\".",
                    "type": "boolean"
                },
                "isManyToManyNotOwner": {
                    "description": "Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\nNot owner side means this side of relation does not have a join table.",
                    "type": "boolean"
                },
                "isManyToManyOwner": {
                    "description": "Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\nOwner side means this side of relation has a join table.",
                    "type": "boolean"
                },
                "isManyToOne": {
                    "description": "Checks if this relation's type is \"many-to-one\".",
                    "type": "boolean"
                },
                "isNullable": {
                    "description": "Indicates if relation column value can be nullable or not.",
                    "type": "boolean"
                },
                "isOneToMany": {
                    "description": "Checks if this relation's type is \"one-to-many\".",
                    "type": "boolean"
                },
                "isOneToOne": {
                    "description": "Checks if this relation's type is \"one-to-one\".",
                    "type": "boolean"
                },
                "isOneToOneNotOwner": {
                    "description": "Checks if this relation is NOT owner side of the \"one-to-one\" relation.\nNOT owner side means this side of relation does not have a join column in the table.",
                    "type": "boolean"
                },
                "isOneToOneOwner": {
                    "description": "Checks if this relation is owner side of the \"one-to-one\" relation.\nOwner side means this side of relation has a join column in the table.",
                    "type": "boolean"
                },
                "isOwning": {
                    "description": "Indicates if this side is an owner of this relation.",
                    "type": "boolean"
                },
                "isPrimary": {
                    "description": "Indicates if this relation's column is a primary key.\nCan be used only for many-to-one and owner one-to-one relations.",
                    "type": "boolean"
                },
                "isTreeChildren": {
                    "description": "Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.",
                    "type": "boolean"
                },
                "isTreeParent": {
                    "description": "Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.",
                    "type": "boolean"
                },
                "isWithJoinColumn": {
                    "description": "Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).",
                    "type": "boolean"
                },
                "joinColumns": {
                    "description": "Join table columns.\nJoin columns can be obtained only from owner side of the relation.\nFrom non-owner side of the relation join columns will be empty.\nIf this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\nIf this relation is many-to-many then it takes all owner join columns from the junction entity.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "joinTableName": {
                    "description": "Join table name.",
                    "type": "string"
                },
                "junctionEntityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the junction table.\nJunction tables have their own entity metadata objects.\nDefined only for many-to-many relations."
                },
                "onDelete": {
                    "description": "What to do with a relation on deletion of the row containing a foreign key.",
                    "enum": [
                        "CASCADE",
                        "DEFAULT",
                        "NO ACTION",
                        "RESTRICT",
                        "SET NULL"
                    ],
                    "type": "string"
                },
                "onUpdate": {
                    "description": "What to do with a relation on update of the row containing a foreign key.",
                    "enum": [
                        "CASCADE",
                        "DEFAULT",
                        "NO ACTION",
                        "RESTRICT",
                        "SET NULL"
                    ],
                    "type": "string"
                },
                "orphanedRowAction": {
                    "description": "When a parent is saved (with cascading but) without a child row that still exists in database, this will control what shall happen to them.\ndelete will remove these rows from database. nullify will remove the relation key.\nskip will keep the relation intact. Removal of related item is only possible through its own repo.",
                    "enum": [
                        "delete",
                        "disable",
                        "nullify",
                        "soft-delete"
                    ],
                    "type": "string"
                },
                "persistenceEnabled": {
                    "description": "Indicates if persistence is enabled for the relation.\nBy default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\nIf its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\nThis is useful for performance optimization since its disabling avoid multiple extra queries during entity save.",
                    "type": "boolean"
                },
                "propertyName": {
                    "description": "Target's property name to which relation decorator is applied.",
                    "type": "string"
                },
                "propertyPath": {
                    "description": "Gets full path to this column property (including relation name).\nFull path is relevant when column is used in embeds (one or multiple nested).\nFor example it will return \"counters.subcounters.likes\".\nIf property is not in embeds then it returns just property name of the column.",
                    "type": "string"
                },
                "relationType": {
                    "$ref": "#/definitions/RelationType",
                    "description": "Relation type, e.g. is it one-to-one, one-to-many, many-to-one or many-to-many."
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target entity to which this relation is applied.\nTarget IS NOT equal to entityMetadata.target, because relation\n\nFor example for"
                },
                "type": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Gets the property's type to which this relation is applied.\n\nFor example for"
                }
            },
            "required": [
                "createForeignKeyConstraints",
                "entityMetadata",
                "foreignKeys",
                "givenInverseSidePropertyFactory",
                "inverseEntityMetadata",
                "inverseJoinColumns",
                "inverseSidePropertyPath",
                "isCascadeInsert",
                "isCascadeRecover",
                "isCascadeRemove",
                "isCascadeSoftRemove",
                "isCascadeUpdate",
                "isEager",
                "isLazy",
                "isManyToMany",
                "isManyToManyNotOwner",
                "isManyToManyOwner",
                "isManyToOne",
                "isNullable",
                "isOneToMany",
                "isOneToOne",
                "isOneToOneNotOwner",
                "isOneToOneOwner",
                "isOwning",
                "isPrimary",
                "isTreeChildren",
                "isTreeParent",
                "isWithJoinColumn",
                "joinColumns",
                "joinTableName",
                "persistenceEnabled",
                "propertyName",
                "propertyPath",
                "relationType",
                "target",
                "type"
            ],
            "type": "object"
        },
        "RelationType": {
            "description": "All types that relation can be.",
            "enum": [
                "many-to-many",
                "many-to-one",
                "one-to-many",
                "one-to-one"
            ],
            "type": "string"
        },
        "Resolver<any>": {
            "description": "A resolver object returned by asClass(), asFunction() or asValue().",
            "properties": {
                "isLeakSafe": {
                    "description": "True if this resolver should be excluded from lifetime leak checking. Used by resolvers that\nwish to uphold the anti-leakage contract themselves. Defaults to false.",
                    "type": "boolean"
                },
                "lifetime": {
                    "description": "Lifetime setting.",
                    "enum": [
                        "SCOPED",
                        "SINGLETON",
                        "TRANSIENT"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Only used for inline configuration with `loadModules`.",
                    "type": "string"
                },
                "register": {
                    "description": "Registration function to use. Only used for inline configuration with `loadModules`.",
                    "type": "object"
                }
            },
            "type": "object"
        },
        "RouteConfig": {
            "properties": {
                "crudRoutes": {
                    "items": {
                        "properties": {
                            "controller": {
                                "properties": {
                                    "prototype": {
                                        "$ref": "#/definitions/ItemController"
                                    }
                                },
                                "required": [
                                    "prototype"
                                ],
                                "type": "object"
                            },
                            "resource": {
                                "default": "items",
                                "type": "string"
                            }
                        },
                        "required": [
                            "controller",
                            "resource"
                        ],
                        "type": "object"
                    },
                    "type": "array"
                },
                "customRoutes": {
                    "default": [
                        {
                            "method": "GET",
                            "path": "/ping"
                        }
                    ],
                    "items": {
                        "$ref": "#/definitions/ServerRoute<ReqRefDefaults>"
                    },
                    "type": "array"
                },
                "server": {
                    "$ref": "#/definitions/Server<ServerApplicationState>"
                },
                "setRoutes": {
                    "type": "object"
                }
            },
            "required": [
                "crudRoutes",
                "customRoutes",
                "server",
                "setRoutes"
            ],
            "type": "object"
        },
        "RouteDefMethods": {
            "enum": [
                "ACL",
                "BIND",
                "CHECKOUT",
                "CONNECT",
                "COPY",
                "DELETE",
                "GET",
                "LINK",
                "LOCK",
                "M-SEARCH",
                "MERGE",
                "MKACTIVITY",
                "MKCALENDAR",
                "MKCOL",
                "MOVE",
                "NOTIFY",
                "OPTIONS",
                "PATCH",
                "POST",
                "PROPFIND",
                "PROPPATCH",
                "PURGE",
                "PUT",
                "REBIND",
                "REPORT",
                "SEARCH",
                "SOURCE",
                "SUBSCRIBE",
                "TRACE",
                "UNBIND",
                "UNLINK",
                "UNLOCK",
                "UNSUBSCRIBE",
                "acl",
                "bind",
                "checkout",
                "connect",
                "copy",
                "delete",
                "get",
                "link",
                "lock",
                "m-search",
                "merge",
                "mkactivity",
                "mkcalendar",
                "mkcol",
                "move",
                "notify",
                "options",
                "patch",
                "post",
                "propfind",
                "proppatch",
                "purge",
                "put",
                "rebind",
                "report",
                "search",
                "source",
                "subscribe",
                "trace",
                "unbind",
                "unlink",
                "unlock",
                "unsubscribe"
            ],
            "type": "string"
        },
        "RouteExtObject<ReqRefDefaults>": {
            "properties": {
                "method": {
                    "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                    "type": "object"
                },
                "options": {
                    "$ref": "#/definitions/ServerExtOptions"
                }
            },
            "required": [
                "method"
            ],
            "type": "object"
        },
        "RouteOptions<ReqRefDefaults>": {
            "description": "Each route can be customized to change the default behavior of the request lifecycle.\nFor context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#route-options)",
            "properties": {
                "app": {
                    "$ref": "#/definitions/RouteOptionsApp",
                    "description": "Application-specific route configuration state. Should not be used by plugins which should use options.plugins[name] instead.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsapp)"
                },
                "auth": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsAccess"
                        },
                        {
                            "const": false,
                            "type": "boolean"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Route authentication configuration. Value can be:\nfalse to disable authentication if a default strategy is set.\na string with the name of an authentication strategy registered with server.auth.strategy(). The strategy will be set to 'required' mode.\nan authentication configuration object.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsapp)"
                },
                "bind": {
                    "anyOf": [
                        {
                            "additionalProperties": true,
                            "properties": {},
                            "type": "object"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "default": "null.\nAn object passed back to the provided handler (via this) when called. Ignored if the method is an arrow function.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsbind)"
                },
                "cache": {
                    "anyOf": [
                        {
                            "allOf": [
                                {
                                    "properties": {
                                        "otherwise": {
                                            "type": "string"
                                        },
                                        "privacy": {
                                            "enum": [
                                                "default",
                                                "private",
                                                "public"
                                            ],
                                            "type": "string"
                                        },
                                        "statuses": {
                                            "items": {
                                                "type": "number"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                },
                                {
                                    "properties": {
                                        "expiresIn": {
                                            "type": "number"
                                        }
                                    },
                                    "type": "object"
                                }
                            ]
                        },
                        {
                            "allOf": [
                                {
                                    "properties": {
                                        "otherwise": {
                                            "type": "string"
                                        },
                                        "privacy": {
                                            "enum": [
                                                "default",
                                                "private",
                                                "public"
                                            ],
                                            "type": "string"
                                        },
                                        "statuses": {
                                            "items": {
                                                "type": "number"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                },
                                {
                                    "properties": {
                                        "expiresAt": {
                                            "type": "string"
                                        }
                                    },
                                    "type": "object"
                                }
                            ]
                        },
                        {
                            "allOf": [
                                {
                                    "properties": {
                                        "otherwise": {
                                            "type": "string"
                                        },
                                        "privacy": {
                                            "enum": [
                                                "default",
                                                "private",
                                                "public"
                                            ],
                                            "type": "string"
                                        },
                                        "statuses": {
                                            "items": {
                                                "type": "number"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                },
                                {
                                    "type": "object"
                                }
                            ]
                        },
                        {
                            "const": false,
                            "type": "boolean"
                        }
                    ],
                    "default": "{ privacy: 'default', statuses: [200], otherwise: 'no-cache' }.\nIf the route method is 'GET', the route can be configured to include HTTP caching directives in the response. Caching can be customized using an object with the following options:\nprivacy - determines the privacy flag included in client-side caching using the 'Cache-Control' header. Values are:\n* * 'default' - no privacy flag.\n* * 'public' - mark the response as suitable for public caching.\n* * 'private' - mark the response as suitable only for private caching.\n* expiresIn - relative expiration expressed in the number of milliseconds since the item was saved in the cache. Cannot be used together with expiresAt.\n* expiresAt - time of day expressed in 24h notation using the 'HH:MM' format, at which point all cache records for the route expire. Cannot be used together with expiresIn.\n* statuses - an array of HTTP response status code numbers (e.g. 200) which are allowed to include a valid caching directive.\n* otherwise - a string with the value of the 'Cache-Control' header when caching is disabled.\nThe default Cache-Control: no-cache header can be disabled by setting cache to false.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionscache)"
                },
                "compression": {
                    "$ref": "#/definitions/{deflate?:ZlibOptions|undefined;gzip?:ZlibOptions|undefined;}",
                    "description": "An object where each key is a content-encoding name and each value is an object with the desired encoder settings. Note that decoder settings are set in compression.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionscompression)"
                },
                "cors": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsCors"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": "false (no CORS headers).\nThe Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web applications running inside a browser which are loaded from a different\ndomain than the API server. To enable, set cors to true, or to an object with the following options:\n* origin - an array of allowed origin servers strings ('Access-Control-Allow-Origin'). The array can contain any combination of fully qualified origins along with origin strings containing a\nwildcard '*' character, or a single '*' origin string. If set to 'ignore', any incoming Origin header is ignored (present or not) and the 'Access-Control-Allow-Origin' header is set to '*'.\nDefaults to any origin ['*'].\n* maxAge - number of seconds the browser should cache the CORS response ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser checks for changes in\npolicy. Defaults to 86400 (one day).\n* headers - a strings array of allowed headers ('Access-Control-Allow-Headers'). Defaults to ['Accept', 'Authorization', 'Content-Type', 'If-None-Match'].\n* additionalHeaders - a strings array of additional headers to headers. Use this to keep the default headers in place.\n* exposedHeaders - a strings array of exposed headers ('Access-Control-Expose-Headers'). Defaults to ['WWW-Authenticate', 'Server-Authorization'].\n* additionalExposedHeaders - a strings array of additional headers to exposedHeaders. Use this to keep the default headers in place.\n* credentials - if true, allows user credentials to be sent ('Access-Control-Allow-Credentials'). Defaults to false.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionscors)"
                },
                "description": {
                    "default": "none.\nRoute description used for generating documentation (string).\nThis setting is not available when setting server route defaults using server.options.routes.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsdescription)",
                    "type": "string"
                },
                "ext": {
                    "$ref": "#/definitions/{onPreAuth?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onCredentials?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostAuth?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPreHandler?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostHandler?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPreResponse?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostResponse?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;}",
                    "default": "none.\nRoute-level request extension points by setting the option to an object with a key for each of the desired extension points ('onRequest' is not allowed), and the value is the same as the\nserver.ext(events) event argument.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsext)\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#request-lifecycle)"
                },
                "files": {
                    "default": "{ relativeTo: '.' }.\nDefines the behavior for accessing files:\n* relativeTo - determines the folder relative paths are resolved against.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsfiles)",
                    "properties": {
                        "relativeTo": {
                            "type": "string"
                        }
                    },
                    "required": [
                        "relativeTo"
                    ],
                    "type": "object"
                },
                "handler": {
                    "anyOf": [
                        {
                            "additionalProperties": true,
                            "properties": {},
                            "type": "object"
                        },
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        }
                    ],
                    "default": "none.\nThe route handler function performs the main business logic of the route and sets the response. handler can be assigned:\n* a lifecycle method.\n* an object with a single property using the name of a handler type registered with the server.handler() method. The matching property value is passed as options to the registered handler\ngenerator. Note: handlers using a fat arrow style function cannot be bound to any bind property. Instead, the bound context is available under h.context.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionshandler)"
                },
                "id": {
                    "default": "none.\nAn optional unique identifier used to look up the route using server.lookup(). Cannot be assigned to routes added with an array of methods.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsid)",
                    "type": "string"
                },
                "isInternal": {
                    "default": "false.\nIf true, the route cannot be accessed through the HTTP listener but only through the server.inject() interface with the allowInternals option set to true. Used for internal routes that should\nnot be accessible to the outside world.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsisinternal)",
                    "type": "boolean"
                },
                "json": {
                    "$ref": "#/definitions/Json.StringifyArguments",
                    "default": "none.\nOptional arguments passed to JSON.stringify() when converting an object or error response to a string payload or escaping it after stringification. Supports the following:\n* replacer - the replacer function or array. Defaults to no action.\n* space - number of spaces to indent nested object keys. Defaults to no indentation.\n* suffix - string suffix added after conversion to JSON string. Defaults to no suffix.\n* escape - calls Hoek.jsonEscape() after conversion to JSON string. Defaults to false.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsjson)"
                },
                "log": {
                    "default": "{ collect: false }.\nRequest logging options:\ncollect - if true, request-level logs (both internal and application) are collected and accessible via request.logs.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionslog)",
                    "properties": {
                        "collect": {
                            "type": "boolean"
                        }
                    },
                    "required": [
                        "collect"
                    ],
                    "type": "object"
                },
                "notes": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "default": "none.\nRoute notes used for generating documentation (string or array of strings).\nThis setting is not available when setting server route defaults using server.options.routes.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsnotes)"
                },
                "payload": {
                    "$ref": "#/definitions/RouteOptionsPayload",
                    "description": "Determines how the request payload is processed.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayload)"
                },
                "plugins": {
                    "$ref": "#/definitions/PluginSpecificConfiguration",
                    "default": "{}.\nPlugin-specific configuration. plugins is an object where each key is a plugin name and the value is the plugin configuration.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsplugins)"
                },
                "pre": {
                    "default": "none.\nThe pre option allows defining methods for performing actions before the handler is called. These methods allow breaking the handler logic into smaller, reusable components that can be shared\nacross routes, as well as provide a cleaner error handling of prerequisite operations (e.g. load required reference data from a database). pre is assigned an ordered array of methods which\nare called serially in order. If the pre array contains another array of methods as one of its elements, those methods are called in parallel. Note that during parallel execution, if any of\nthe methods error, return a takeover response, or abort signal, the other parallel methods will continue to execute but will be ignored once completed. pre can be assigned a mixed array of:\n* an array containing the elements listed below, which are executed in parallel.\n* an object with:\n* * method - a lifecycle method.\n* * assign - key name used to assign the response of the method to in request.pre and request.preResponses.\n* * failAction - A failAction value which determine what to do when a pre-handler method throws an error. If assign is specified and the failAction setting is not 'error', the error will be\nassigned.\n* a method function - same as including an object with a single method key.\nNote that pre-handler methods do not behave the same way other lifecycle methods do when a value is returned. Instead of the return value becoming the new response payload, the value is used\nto assign the corresponding request.pre and request.preResponses properties. Otherwise, the handling of errors, takeover response response, or abort signal behave the same as any other\nlifecycle methods.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspre)",
                    "description": "For context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspre)",
                    "items": {
                        "$ref": "#/definitions/RouteOptionsPreAllOptions<ReqRefDefaults>"
                    },
                    "type": "array"
                },
                "response": {
                    "$ref": "#/definitions/RouteOptionsResponse",
                    "description": "Processing rules for the outgoing response.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponse)"
                },
                "security": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsSecureObject"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": "false (security headers disabled).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionssecurity)"
                },
                "state": {
                    "default": "{ parse: true, failAction: 'error' }.\nHTTP state management (cookies) allows the server to store information on the client which is sent back to the server with every request (as defined in RFC 6265). state supports the following\noptions: parse - determines if incoming 'Cookie' headers are parsed and stored in the request.state object. failAction - A failAction value which determines how to handle cookie parsing\nerrors. Defaults to 'error' (return a Bad Request (400) error response).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsstate)",
                    "properties": {
                        "failAction": {
                            "anyOf": [
                                {
                                    "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                                    "type": "object"
                                },
                                {
                                    "enum": [
                                        "error",
                                        "ignore",
                                        "log"
                                    ],
                                    "type": "string"
                                }
                            ]
                        },
                        "parse": {
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "tags": {
                    "default": "none.\nRoute tags used for generating documentation (array of strings).\nThis setting is not available when setting server route defaults using server.options.routes.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionstags)",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "timeout": {
                    "default": "{ server: false }.\nTimeouts for processing durations.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionstimeout)",
                    "properties": {
                        "server": {
                            "description": "Response timeout in milliseconds. Sets the maximum time allowed for the server to respond to an incoming request before giving up and responding with a Service Unavailable (503) error\nresponse.",
                            "type": [
                                "number",
                                "boolean"
                            ]
                        },
                        "socket": {
                            "default": "none (use node default of 2 minutes).\nBy default, node sockets automatically timeout after 2 minutes. Use this option to override this behavior. Set to false to disable socket timeouts.",
                            "type": [
                                "number",
                                "boolean"
                            ]
                        }
                    },
                    "type": "object"
                },
                "validate": {
                    "$ref": "#/definitions/RouteOptionsValidate",
                    "default": "{ headers: true, params: true, query: true, payload: true, failAction: 'error' }.\nRequest input validation rules for various request components.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidate)"
                }
            },
            "type": "object"
        },
        "RouteOptionsAccess": {
            "description": "Route Authentication Options",
            "properties": {
                "access": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                        },
                        {
                            "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                        },
                        {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                                },
                                {
                                    "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                                }
                            ]
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteOptionsAccessObject"
                            },
                            "type": "array"
                        }
                    ],
                    "default": "none.\nAn object or array of objects specifying the route access rules. Each rule is evaluated against an incoming request and access is granted if at least one of the rules matches. Each rule object\nmust include at least one of scope or entity.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccess)"
                },
                "entity": {
                    "default": "'any'.\nThe required authenticated entity type. If set, must match the entity value of the request authenticated credentials. Available values:\n* 'any' - the authentication can be on behalf of a user or application.\n* 'user' - the authentication must be on behalf of a user which is identified by the presence of a 'user' attribute in the credentials object returned by the authentication strategy.\n* 'app' - the authentication must be on behalf of an application which is identified by the lack of presence of a user attribute in the credentials object returned by the authentication\nstrategy.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccessentity)",
                    "enum": [
                        "any",
                        "app",
                        "user"
                    ],
                    "type": "string"
                },
                "mode": {
                    "default": "'required'.\nThe authentication mode. Available values:\n* 'required' - authentication is required.\n* 'optional' - authentication is optional - the request must include valid credentials or no credentials at all.\n* 'try' - similar to 'optional', any request credentials are attempted authentication, but if the credentials are invalid, the request proceeds regardless of the authentication error.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthmode)",
                    "enum": [
                        "optional",
                        "required",
                        "try"
                    ],
                    "type": "string"
                },
                "payload": {
                    "default": "false, unless the scheme requires payload authentication.\nIf set, the incoming request payload is authenticated after it is processed. Requires a strategy with payload authentication support (e.g. Hawk). Cannot be set to a value other than 'required'\nwhen the scheme sets the authentication options.payload to true. Available values:\n* false - no payload authentication.\n* 'required' - payload authentication required.\n* 'optional' - payload authentication performed only when the client includes payload authentication information (e.g. hash attribute in Hawk).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthpayload)",
                    "enum": [
                        false,
                        "optional",
                        "required"
                    ]
                },
                "scope": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "const": false,
                            "type": "boolean"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "default": "false (no scope requirements).\nThe application scope required to access the route. Value can be a scope string or an array of scope strings. When authenticated, the credentials object scope property must contain at least\none of the scopes defined to access the route. If a scope string begins with a + character, that scope is required. If a scope string begins with a ! character, that scope is forbidden. For\nexample, the scope ['!a', '+b', 'c', 'd'] means the incoming request credentials' scope must not include 'a', must include 'b', and must include one of 'c' or 'd'. You may also access\nproperties on the request object (query, params, payload, and credentials) to populate a dynamic scope by using the '{' and '}' characters around the property name, such as 'user-{params.id}'.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccessscope)"
                },
                "strategies": {
                    "default": "the default strategy set via server.auth.default().\nAn array of string strategy names in the order they should be attempted. Cannot be used together with strategy.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthstrategies)",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "strategy": {
                    "default": "the default strategy set via server.auth.default().\nA string strategy names. Cannot be used together with strategies.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthstrategy)",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "RouteOptionsAccessEntityObject": {
            "properties": {
                "entity": {
                    "$ref": "#/definitions/AccessEntity"
                }
            },
            "required": [
                "entity"
            ],
            "type": "object"
        },
        "RouteOptionsAccessObject": {
            "anyOf": [
                {
                    "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                },
                {
                    "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                },
                {
                    "allOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                        },
                        {
                            "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                        }
                    ]
                }
            ]
        },
        "RouteOptionsAccessScope": {
            "anyOf": [
                {
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                {
                    "const": false,
                    "type": "boolean"
                },
                {
                    "type": "string"
                }
            ]
        },
        "RouteOptionsAccessScopeObject": {
            "properties": {
                "scope": {
                    "$ref": "#/definitions/RouteOptionsAccessScope"
                }
            },
            "required": [
                "scope"
            ],
            "type": "object"
        },
        "RouteOptionsApp": {
            "description": "Empty interface to allow for user-defined augmentations.",
            "type": "object"
        },
        "RouteOptionsCors": {
            "default": "false (no CORS headers).\nThe Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web applications running inside a browser which are loaded from a different domain\nthan the API server. To enable, set cors to true, or to an object with the following options:\n* origin - an array of allowed origin servers strings ('Access-Control-Allow-Origin'). The array can contain any combination of fully qualified origins along with origin strings containing a\nwildcard '*' character, or a single '*' origin string. If set to 'ignore', any incoming Origin header is ignored (present or not) and the 'Access-Control-Allow-Origin' header is set to '*'.\nDefaults to any origin ['*'].\n* maxAge - number of seconds the browser should cache the CORS response ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser checks for changes in policy.\nDefaults to 86400 (one day).\n* headers - a strings array of allowed headers ('Access-Control-Allow-Headers'). Defaults to ['Accept', 'Authorization', 'Content-Type', 'If-None-Match'].\n* additionalHeaders - a strings array of additional headers to headers. Use this to keep the default headers in place.\n* exposedHeaders - a strings array of exposed headers ('Access-Control-Expose-Headers'). Defaults to ['WWW-Authenticate', 'Server-Authorization'].\n* additionalExposedHeaders - a strings array of additional headers to exposedHeaders. Use this to keep the default headers in place.\n* credentials - if true, allows user credentials to be sent ('Access-Control-Allow-Credentials'). Defaults to false.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionscors)",
            "properties": {
                "additionalExposedHeaders": {
                    "description": "a strings array of additional headers to exposedHeaders. Use this to keep the default headers in place.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "additionalHeaders": {
                    "description": "a strings array of additional headers to headers. Use this to keep the default headers in place.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "credentials": {
                    "description": "if true, allows user credentials to be sent ('Access-Control-Allow-Credentials'). Defaults to false.",
                    "type": "boolean"
                },
                "exposedHeaders": {
                    "description": "a strings array of exposed headers ('Access-Control-Expose-Headers'). Defaults to ['WWW-Authenticate', 'Server-Authorization'].",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "headers": {
                    "description": "a strings array of allowed headers ('Access-Control-Allow-Headers'). Defaults to ['Accept', 'Authorization', 'Content-Type', 'If-None-Match'].",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "maxAge": {
                    "description": "number of seconds the browser should cache the CORS response ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser checks for changes in policy.\nDefaults to 86400 (one day).",
                    "type": "number"
                },
                "origin": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "*",
                                "ignore"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "an array of allowed origin servers strings ('Access-Control-Allow-Origin'). The array can contain any combination of fully qualified origins along with origin strings containing a wildcard '*'\ncharacter, or a single '*' origin string. If set to 'ignore', any incoming Origin header is ignored (present or not) and the 'Access-Control-Allow-Origin' header is set to '*'. Defaults to any\norigin ['*']."
                },
                "preflightStatusCode": {
                    "description": "the status code used for CORS preflight responses, either 200 or 204. Defaults to 200.",
                    "enum": [
                        200,
                        204
                    ],
                    "type": "number"
                }
            },
            "type": "object"
        },
        "RouteOptionsPayload": {
            "description": "Determines how the request payload is processed.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayload)",
            "properties": {
                "allow": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "default": "allows parsing of the following mime types:\n* application/json\n* application/*+json\n* application/octet-stream\n* application/x-www-form-urlencoded\n* multipart/form-data\n* text/*\nA string or an array of strings with the allowed mime types for the endpoint. Use this settings to limit the set of allowed mime types. Note that allowing additional mime types not listed\nabove will not enable them to be parsed, and if parse is true, the request will result in an error response.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadallow)"
                },
                "compression": {
                    "$ref": "#/definitions/{deflate?:ZlibOptions|undefined;gzip?:ZlibOptions|undefined;}_1",
                    "default": "none.\nAn object where each key is a content-encoding name and each value is an object with the desired decoder settings. Note that encoder settings are set in compression.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadcompression)"
                },
                "defaultContentType": {
                    "default": "'application/json'.\nThe default content type if the 'Content-Type' request header is missing.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloaddefaultcontenttype)",
                    "type": "string"
                },
                "failAction": {
                    "anyOf": [
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        },
                        {
                            "enum": [
                                "error",
                                "ignore",
                                "log"
                            ],
                            "type": "string"
                        }
                    ],
                    "default": "'error' (return a Bad Request (400) error response).\nA failAction value which determines how to handle payload parsing errors.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadfailaction)"
                },
                "maxBytes": {
                    "default": "1048576 (1MB).\nLimits the size of incoming payloads to the specified byte count. Allowing very large payloads may cause the server to run out of memory.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadmaxbytes)",
                    "type": "number"
                },
                "maxParts": {
                    "default": "1000\nLimits the number of parts allowed in multipart payloads.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadmaxparts)",
                    "type": "number"
                },
                "multipart": {
                    "anyOf": [
                        {
                            "properties": {
                                "output": {
                                    "enum": [
                                        "annotated",
                                        "data",
                                        "file",
                                        "stream"
                                    ],
                                    "type": "string"
                                }
                            },
                            "required": [
                                "output"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": "none.\nOverrides payload processing for multipart requests. Value can be one of:\n* false - disable multipart processing.\nan object with the following required options:\n* output - same as the output option with an additional value option:\n* * annotated - wraps each multipart part in an object with the following keys: // TODO type this?\n* * * headers - the part headers.\n* * * filename - the part file name.\n* * * payload - the processed part payload.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadmultipart)"
                },
                "output": {
                    "default": "'data'.\nThe processed payload format. The value must be one of:\n* 'data' - the incoming payload is read fully into memory. If parse is true, the payload is parsed (JSON, form-decoded, multipart) based on the 'Content-Type' header. If parse is false, a raw\nBuffer is returned.\n* 'stream' - the incoming payload is made available via a Stream.Readable interface. If the payload is 'multipart/form-data' and parse is true, field values are presented as text while files\nare provided as streams. File streams from a 'multipart/form-data' upload will also have a hapi property containing the filename and headers properties. Note that payload streams for multipart\npayloads are a synthetic interface created on top of the entire multipart content loaded into memory. To avoid loading large multipart payloads into memory, set parse to false and handle the\nmultipart payload in the handler using a streaming parser (e.g. pez).\n* 'file' - the incoming payload is written to temporary file in the directory specified by the uploads settings. If the payload is 'multipart/form-data' and parse is true, field values are\npresented as text while files are saved to disk. Note that it is the sole responsibility of the application to clean up the files generated by the framework. This can be done by keeping track\nof which files are used (e.g. using the request.app object), and listening to the server 'response' event to perform cleanup.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadoutput)",
                    "enum": [
                        "data",
                        "file",
                        "stream"
                    ],
                    "type": "string"
                },
                "override": {
                    "default": "none.\nA mime type string overriding the 'Content-Type' header value received.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadoverride)",
                    "type": "string"
                },
                "parse": {
                    "default": "true.\nDetermines if the incoming payload is processed or presented raw. Available values:\n* true - if the request 'Content-Type' matches the allowed mime types set by allow (for the whole payload as well as parts), the payload is converted into an object when possible. If the\nformat is unknown, a Bad Request (400) error response is sent. Any known content encoding is decoded.\n* false - the raw payload is returned unmodified.\n* 'gunzip' - the raw payload is returned unmodified after any known content encoding is decoded.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadparse)",
                    "enum": [
                        false,
                        "gunzip",
                        true
                    ]
                },
                "protoAction": {
                    "default": "to 'error'.\nSets handling of incoming payload that may contain a prototype poisoning security attack.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadprotoaction)",
                    "enum": [
                        "error",
                        "ignore",
                        "remove"
                    ],
                    "type": "string"
                },
                "timeout": {
                    "anyOf": [
                        {
                            "const": false,
                            "type": "boolean"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "default": "to 10000 (10 seconds).\nPayload reception timeout in milliseconds. Sets the maximum time allowed for the client to transmit the request payload (body) before giving up and responding with a Request Timeout (408)\nerror response. Set to false to disable.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloadtimeout)"
                },
                "uploads": {
                    "default": "os.tmpdir().\nThe directory used for writing file uploads.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspayloaduploads)",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "RouteOptionsPreAllOptions<ReqRefDefaults>": {
            "anyOf": [
                {
                    "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                    "type": "object"
                },
                {
                    "$ref": "#/definitions/RouteOptionsPreObject<ReqRefDefaults>"
                },
                {
                    "items": {
                        "$ref": "#/definitions/RouteOptionsPreObject<ReqRefDefaults>"
                    },
                    "type": "array"
                }
            ],
            "description": "For context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspre)"
        },
        "RouteOptionsPreObject<ReqRefDefaults>": {
            "description": "An object with:\n* method - a lifecycle method.\n* assign - key name used to assign the response of the method to in request.pre and request.preResponses.\n* failAction - A failAction value which determine what to do when a pre-handler method throws an error. If assign is specified and the failAction setting is not 'error', the error will be assigned.\nFor context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionspre)",
            "properties": {
                "assign": {
                    "description": "key name used to assign the response of the method to in request.pre and request.preResponses.",
                    "type": "string"
                },
                "failAction": {
                    "anyOf": [
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        },
                        {
                            "enum": [
                                "error",
                                "ignore",
                                "log"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "A failAction value which determine what to do when a pre-handler method throws an error. If assign is specified and the failAction setting is not 'error', the error will be assigned."
                },
                "method": {
                    "description": "a lifecycle method.",
                    "type": "object"
                }
            },
            "required": [
                "method"
            ],
            "type": "object"
        },
        "RouteOptionsResponse": {
            "description": "Processing rules for the outgoing response.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponse)",
            "properties": {
                "disconnectStatusCode": {
                    "default": 499,
                    "description": "The default HTTP status code used to set a response error when the request is closed or aborted before the\nresponse is fully transmitted.\nValue can be any integer greater or equal to 400.\nThe default value 499 is based on the non-standard nginx \"CLIENT CLOSED REQUEST\" error.\nThe value is only used for logging as the request has already ended.",
                    "type": "number"
                },
                "emptyStatusCode": {
                    "default": "204.\nThe default HTTP status code when the payload is considered empty. Value can be 200 or 204. Note that a 200 status code is converted to a 204 only at the time of response transmission (the\nresponse status code will remain 200 throughout the request lifecycle unless manually set).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponseemptystatuscode)",
                    "enum": [
                        200,
                        204
                    ],
                    "type": "number"
                },
                "failAction": {
                    "anyOf": [
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        },
                        {
                            "enum": [
                                "error",
                                "ignore",
                                "log"
                            ],
                            "type": "string"
                        }
                    ],
                    "default": "'error' (return an Internal Server Error (500) error response).\nA failAction value which defines what to do when a response fails payload validation.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponsefailaction)"
                },
                "modify": {
                    "default": "false.\nIf true, applies the validation rule changes to the response payload.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponsemodify)",
                    "type": "boolean"
                },
                "options": {
                    "$ref": "#/definitions/ValidationOptions",
                    "default": "none.\n[joi](https://github.com/hapijs/joi) options object pass to the validation function. Useful to set global options such as stripUnknown or abortEarly (the complete list is available here). If a\ncustom validation function is defined via schema or status then options can an arbitrary object that will be passed to this function as the second argument.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponseoptions)"
                },
                "ranges": {
                    "default": "true.\nIf false, payload range support is disabled.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponseranges)",
                    "type": "boolean"
                },
                "sample": {
                    "default": "100 (all responses).\nThe percent of response payloads validated (0 - 100). Set to 0 to disable all validation.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponsesample)",
                    "type": "number"
                },
                "schema": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": "true (no validation).\nThe default response payload validation rules (for all non-error responses) expressed as one of:\n* true - any payload allowed (no validation).\n* false - no payload allowed.\n* a joi validation object. The options along with the request context ({ headers, params, query, payload, app, auth }) are passed to the validation function.\n* a validation function using the signature async function(value, options) where:\n* * value - the pending response payload.\n* * options - The options along with the request context ({ headers, params, query, payload, app, auth }).\n* * if the function returns a value and modify is true, the value is used as the new response. If the original response is an error, the return value is used to override the original error\noutput.payload. If an error is thrown, the error is processed according to failAction.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponseschema)"
                },
                "status": {
                    "$ref": "#/definitions/Record<string,RouteOptionsResponseSchema>",
                    "default": "none.\nValidation schemas for specific HTTP status codes. Responses (excluding errors) not matching the listed status codes are validated using the default schema.\nstatus is set to an object where each key is a 3 digit HTTP status code and the value has the same definition as schema.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsresponsestatus)"
                }
            },
            "type": "object"
        },
        "RouteOptionsSecureObject": {
            "default": "false (security headers disabled).\nSets common security headers. To enable, set security to true or to an object with the following options:\n* hsts - controls the 'Strict-Transport-Security' header, where:\n* * true - the header will be set to max-age=15768000. This is the default value.\n* * a number - the maxAge parameter will be set to the provided value.\n* * an object with the following fields:\n* * * maxAge - the max-age portion of the header, as a number. Default is 15768000.\n* * * includeSubDomains - a boolean specifying whether to add the includeSubDomains flag to the header.\n* * * preload - a boolean specifying whether to add the 'preload' flag (used to submit domains inclusion in Chrome's HTTP Strict Transport Security (HSTS) preload list) to the header.\n* xframe - controls the 'X-Frame-Options' header, where:\n* * true - the header will be set to 'DENY'. This is the default value.\n* * 'deny' - the headers will be set to 'DENY'.\n* * 'sameorigin' - the headers will be set to 'SAMEORIGIN'.\n* * an object for specifying the 'allow-from' rule, where:\n* * * rule - one of:\n* * * * 'deny'\n* * * * 'sameorigin'\n* * * * 'allow-from'\n* * * source - when rule is 'allow-from' this is used to form the rest of the header, otherwise this field is ignored. If rule is 'allow-from' but source is unset, the rule will be automatically\nchanged to 'sameorigin'.\n* xss - controls the 'X-XSS-Protection' header, where:\n* * 'disabled' - the header will be set to '0'. This is the default value.\n* * 'enabled' - the header will be set to '1; mode=block'.\n* * false - the header will be omitted\n* noOpen - boolean controlling the 'X-Download-Options' header for Internet Explorer, preventing downloads from executing in your context. Defaults to true setting the header to 'noopen'.\n* noSniff - boolean controlling the 'X-Content-Type-Options' header. Defaults to true setting the header to its only and default option, 'nosniff'.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionssecurity)",
            "properties": {
                "hsts": {
                    "anyOf": [
                        {
                            "properties": {
                                "includeSubDomains": {
                                    "description": "a boolean specifying whether to add the includeSubDomains flag to the header.",
                                    "type": "boolean"
                                },
                                "maxAge": {
                                    "description": "the max-age portion of the header, as a number. Default is 15768000.",
                                    "type": "number"
                                },
                                "preload": {
                                    "description": "a boolean specifying whether to add the 'preload' flag (used to submit domains inclusion in Chrome's HTTP Strict Transport Security (HSTS) preload list) to the header.",
                                    "type": "boolean"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": [
                                "number",
                                "boolean"
                            ]
                        }
                    ],
                    "description": "hsts - controls the 'Strict-Transport-Security' header"
                },
                "noOpen": {
                    "description": "boolean controlling the 'X-Download-Options' header for Internet Explorer, preventing downloads from executing in your context. Defaults to true setting the header to 'noopen'.",
                    "type": "boolean"
                },
                "noSniff": {
                    "description": "boolean controlling the 'X-Content-Type-Options' header. Defaults to true setting the header to its only and default option, 'nosniff'.",
                    "type": "boolean"
                },
                "referrer": {
                    "default": "false Header will not be send.",
                    "description": "Controls the `Referrer-Policy` header, which has the following possible values.",
                    "enum": [
                        "",
                        false,
                        "no-referrer",
                        "no-referrer-when-downgrade",
                        "origin",
                        "origin-when-cross-origin",
                        "same-origin",
                        "strict-origin",
                        "strict-origin-when-cross-origin",
                        "unsafe-url"
                    ]
                },
                "xframe": {
                    "anyOf": [
                        {
                            "properties": {
                                "rule": {
                                    "description": "an object for specifying the 'allow-from' rule,",
                                    "enum": [
                                        "allow-from",
                                        "deny",
                                        "sameorigin"
                                    ],
                                    "type": "string"
                                },
                                "source": {
                                    "description": "when rule is 'allow-from' this is used to form the rest of the header, otherwise this field is ignored. If rule is 'allow-from' but source is unset, the rule will be automatically changed\nto 'sameorigin'.",
                                    "type": "string"
                                }
                            },
                            "required": [
                                "rule",
                                "source"
                            ],
                            "type": "object"
                        },
                        {
                            "enum": [
                                "deny",
                                "sameorigin",
                                true
                            ]
                        }
                    ],
                    "description": "controls the 'X-Frame-Options' header"
                },
                "xss": {
                    "description": "controls the 'X-XSS-Protection' header, where:\n* 'disabled' - the header will be set to '0'. This is the default value.\n* 'enabled' - the header will be set to '1; mode=block'.\n* false - the header will be omitted",
                    "enum": [
                        "disabled",
                        "enabled",
                        false
                    ]
                }
            },
            "type": "object"
        },
        "RouteOptionsValidate": {
            "default": "{ headers: true, params: true, query: true, payload: true, failAction: 'error' }.\nRequest input validation rules for various request components.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidate)",
            "properties": {
                "errorFields": {
                    "additionalProperties": true,
                    "default": "none.\nAn optional object with error fields copied into every validation error response.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidateerrorfields)",
                    "properties": {},
                    "type": "object"
                },
                "failAction": {
                    "anyOf": [
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        },
                        {
                            "enum": [
                                "error",
                                "ignore",
                                "log"
                            ],
                            "type": "string"
                        }
                    ],
                    "default": "'error' (return a Bad Request (400) error response).\nA failAction value which determines how to handle failed validations. When set to a function, the err argument includes the type of validation error under err.output.payload.validation.source.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidatefailaction)"
                },
                "headers": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": true,
                    "description": "Validation rules for incoming request headers:\n* If a value is returned, the value is used as the new request.headers value and the original value is stored in request.orig.headers. Otherwise, the headers are left unchanged. If an error\nis thrown, the error is handled according to failAction. Note that all header field names must be in lowercase to match the headers normalized by node.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidateheaders)"
                },
                "options": {
                    "anyOf": [
                        {
                            "additionalProperties": true,
                            "properties": {},
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/ValidationOptions"
                        }
                    ],
                    "default": true,
                    "description": "An options object passed to the joi rules or the custom validation methods. Used for setting global options such as stripUnknown or abortEarly (the complete list is available here).\nIf a custom validation function (see headers, params, query, or payload above) is defined then options can an arbitrary object that will be passed to this function as the second parameter.\nThe values of the other inputs (i.e. headers, query, params, payload, app, and auth) are added to the options object under the validation context (accessible in rules as\nJoi.ref('$query.key')).\nNote that validation is performed in order (i.e. headers, params, query, and payload) and if type casting is used (e.g. converting a string to a number), the value of inputs not yet validated\nwill reflect the raw, unvalidated and unmodified values. If the validation rules for headers, params, query, and payload are defined at both the server routes level and at the route level, the\nindividual route settings override the routes defaults (the rules are not merged).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidateparams)"
                },
                "params": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": true,
                    "description": "Validation rules for incoming request path parameters, after matching the path against the route, extracting any parameters, and storing them in request.params, where:\n* true - any path parameter value allowed (no validation performed).\n* a joi validation object.\n* a validation function using the signature async function(value, options) where:\n* * value - the request.params object containing the request path parameters.\n* * options - options.\nif a value is returned, the value is used as the new request.params value and the original value is stored in request.orig.params. Otherwise, the path parameters are left unchanged. If an\nerror is thrown, the error is handled according to failAction. Note that failing to match the validation rules to the route path parameters definition will cause all requests to fail.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidateparams)"
                },
                "payload": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": true,
                    "description": "Validation rules for incoming request payload (request body), where:\n* If a value is returned, the value is used as the new request.payload value and the original value is stored in request.orig.payload. Otherwise, the payload is left unchanged. If an error is\nthrown, the error is handled according to failAction. Note that validating large payloads and modifying them will cause memory duplication of the payload (since the original is kept), as well\nas the significant performance cost of validating large amounts of data.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidatepayload)"
                },
                "query": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": true,
                    "description": "Validation rules for incoming request URI query component (the key-value part of the URI between '?' and '#'). The query is parsed into its individual key-value pairs, decoded, and stored in\nrequest.query prior to validation. Where:\n* If a value is returned, the value is used as the new request.query value and the original value is stored in request.orig.query. Otherwise, the query parameters are left unchanged.\nIf an error\nis thrown, the error is handled according to failAction. Note that changes to the query parameters will not be reflected in request.url.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsvalidatequery)"
                },
                "state": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/AnySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ArraySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/AlternativesSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BinarySchema<any>"
                        },
                        {
                            "$ref": "#/definitions/BooleanSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/DateSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/FunctionSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/NumberSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/ObjectSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/StringSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/LinkSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/SymbolSchema<any>"
                        },
                        {
                            "$ref": "#/definitions/PartialSchemaMap<any>"
                        },
                        {
                            "type": [
                                "object",
                                "boolean"
                            ]
                        }
                    ],
                    "default": true,
                    "description": "Validation rules for incoming cookies.\nThe cookie header is parsed and decoded into the request.state prior to validation."
                }
            },
            "type": "object"
        },
        "RouteRules": {
            "type": "object"
        },
        "SapConnectionOptions": {
            "description": "SAP Hana specific connection options.",
            "properties": {
                "ca": {
                    "description": "Ca for encrypted connection",
                    "type": "string"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "cert": {
                    "description": "Cert for encrypted connection",
                    "type": "string"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver objects\nThis defaults to require(\"hdb-pool\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "encrypt": {
                    "description": "Encrypt database connection",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "hanaClientDriver": {
                    "description": "The driver objects\nThis defaults to require(\"@sap/hana-client\")"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "key": {
                    "description": "Key for encrypted connection",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "pool": {
                    "description": "Pool options.",
                    "properties": {
                        "checkInterval": {
                            "description": "How often to run resource timeout checks. (default=0, disabled)",
                            "type": "number"
                        },
                        "idleTimeout": {
                            "description": "Idle timeout",
                            "type": "number"
                        },
                        "max": {
                            "description": "Max number of connections.",
                            "type": "number"
                        },
                        "maxWaitingRequests": {
                            "description": "Maximum number of waiting requests allowed. (default=0, no limit).",
                            "type": "number"
                        },
                        "min": {
                            "description": "Minimum number of connections.",
                            "type": "number"
                        },
                        "poolErrorHandler": {
                            "description": "Function handling errors thrown by drivers pool.\nDefaults to logging error with `warn` level.",
                            "type": "object"
                        },
                        "requestTimeout": {
                            "description": "Max milliseconds a request will wait for a resource before timing out. (default=5000)",
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "schema": {
                    "description": "Database schema.",
                    "type": "string"
                },
                "sslValidateCertificate": {
                    "description": "Validate database certificate",
                    "type": "boolean"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "sap",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "Schema<any>": {
            "anyOf": [
                {
                    "$ref": "#/definitions/AnySchema<any>"
                },
                {
                    "$ref": "#/definitions/ArraySchema<any>"
                },
                {
                    "$ref": "#/definitions/AlternativesSchema<any>"
                },
                {
                    "$ref": "#/definitions/BinarySchema<any>"
                },
                {
                    "$ref": "#/definitions/BooleanSchema<any>"
                },
                {
                    "$ref": "#/definitions/DateSchema<any>"
                },
                {
                    "$ref": "#/definitions/FunctionSchema<any>"
                },
                {
                    "$ref": "#/definitions/NumberSchema<any>"
                },
                {
                    "$ref": "#/definitions/ObjectSchema<any>"
                },
                {
                    "$ref": "#/definitions/StringSchema<any>"
                },
                {
                    "$ref": "#/definitions/LinkSchema<any>"
                },
                {
                    "$ref": "#/definitions/SymbolSchema<any>"
                }
            ]
        },
        "SealOptions": {
            "description": "Options for customizing the key derivation algorithm used to generate encryption and integrity verification keys as well as the algorithms and salt sizes used.",
            "properties": {
                "encryption": {
                    "$ref": "#/definitions/SealOptionsSub",
                    "description": "Encryption step options."
                },
                "integrity": {
                    "$ref": "#/definitions/SealOptionsSub",
                    "description": "Integrity step options."
                },
                "localtimeOffsetMsec": {
                    "description": "Local clock time offset, expressed in number of milliseconds (positive or negative). Defaults to 0.",
                    "type": "number"
                },
                "timestampSkewSec": {
                    "description": "Number of seconds of permitted clock skew for incoming expirations. Defaults to 60 seconds.",
                    "type": "number"
                },
                "ttl": {
                    "description": "Sealed object lifetime in milliseconds where 0 means forever. Defaults to 0.",
                    "type": "number"
                }
            },
            "required": [
                "encryption",
                "integrity",
                "localtimeOffsetMsec",
                "timestampSkewSec",
                "ttl"
            ],
            "type": "object"
        },
        "SealOptionsSub": {
            "description": "seal() method options.",
            "properties": {
                "algorithm": {
                    "description": "The algorithm used. Defaults to 'aes-256-cbc' for encryption and 'sha256' for integrity.",
                    "enum": [
                        "aes-128-ctr",
                        "aes-256-cbc",
                        "sha256"
                    ],
                    "type": "string"
                },
                "iterations": {
                    "description": "The number of iterations used to derive a key from the password. Defaults to 1.",
                    "type": "number"
                },
                "minPasswordlength": {
                    "description": "Minimum password size. Defaults to 32.",
                    "type": "number"
                },
                "saltBits": {
                    "description": "The length of the salt (random buffer used to ensure that two identical objects will generate a different encrypted result). Defaults to 256.",
                    "type": "number"
                }
            },
            "required": [
                "algorithm",
                "iterations",
                "minPasswordlength",
                "saltBits"
            ],
            "type": "object"
        },
        "SecureContext": {
            "properties": {
                "context": {}
            },
            "required": [
                "context"
            ],
            "type": "object"
        },
        "SecureContextOptions": {
            "properties": {
                "ALPNCallback": {
                    "description": "If set, this will be called when a client opens a connection using the ALPN extension.\nOne argument will be passed to the callback: an object containing `servername` and `protocols` fields,\nrespectively containing the server name from the SNI extension (if any) and an array of\nALPN protocol name strings. The callback must return either one of the strings listed in `protocols`,\nwhich will be returned to the client as the selected ALPN protocol, or `undefined`,\nto reject the connection with a fatal alert. If a string is returned that does not match one of\nthe client's ALPN protocols, an error will be thrown.\nThis option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error.",
                    "type": "object"
                },
                "allowPartialTrustChain": {
                    "description": "Treat intermediate (non-self-signed)\ncertificates in the trust CA certificate list as trusted.",
                    "type": "boolean"
                },
                "ca": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Optionally override the trusted CA certificates. Default is to trust\nthe well-known CAs curated by Mozilla. Mozilla's CAs are completely\nreplaced when CAs are explicitly specified using this option."
                },
                "cert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Cert chains in PEM format. One cert chain should be provided per\nprivate key. Each cert chain should consist of the PEM formatted\ncertificate for a provided private key, followed by the PEM\nformatted intermediate certificates (if any), in order, and not\nincluding the root CA (the root CA must be pre-known to the peer,\nsee ca). When providing multiple cert chains, they do not have to\nbe in the same order as their private keys in key. If the\nintermediate certificates are not provided, the peer will not be\nable to validate the certificate, and the handshake will fail."
                },
                "ciphers": {
                    "description": "Cipher suite specification, replacing the default. For more\ninformation, see modifying the default cipher suite. Permitted\nciphers can be obtained via tls.getCiphers(). Cipher names must be\nuppercased in order for OpenSSL to accept them.",
                    "type": "string"
                },
                "clientCertEngine": {
                    "description": "Name of an OpenSSL engine which can provide the client certificate.",
                    "type": "string"
                },
                "crl": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                },
                "dhparam": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "`'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy.\nIf omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available.\nECDHE-based perfect forward secrecy will still be available."
                },
                "ecdhCurve": {
                    "description": "A string describing a named curve or a colon separated list of curve\nNIDs or names, for example P-521:P-384:P-256, to use for ECDH key\nagreement. Set to auto to select the curve automatically. Use\ncrypto.getCurves() to obtain a list of available curve names. On\nrecent releases, openssl ecparam -list_curves will also display the\nname and description of each available elliptic curve. Default:\ntls.DEFAULT_ECDH_CURVE.",
                    "type": "string"
                },
                "honorCipherOrder": {
                    "description": "Attempt to use the server's cipher suite preferences instead of the\nclient's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be\nset in secureOptions",
                    "type": "boolean"
                },
                "key": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/KeyObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format. PEM allows the option of private keys\nbeing encrypted. Encrypted keys will be decrypted with\noptions.passphrase. Multiple keys using different algorithms can be\nprovided either as an array of unencrypted key strings or buffers,\nor an array of objects in the form {pem: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted keys will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "maxVersion": {
                    "description": "Optionally set the maximum TLS version to allow. One\nof `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n`secureProtocol` option, use one or the other.\n**Default:** `'TLSv1.3'`, unless changed using CLI options. Using\n`--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to\n`'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.",
                    "enum": [
                        "TLSv1",
                        "TLSv1.1",
                        "TLSv1.2",
                        "TLSv1.3"
                    ],
                    "type": "string"
                },
                "minVersion": {
                    "description": "Optionally set the minimum TLS version to allow. One\nof `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n`secureProtocol` option, use one or the other.  It is not recommended to use\nless than TLSv1.2, but it may be required for interoperability.\n**Default:** `'TLSv1.2'`, unless changed using CLI options. Using\n`--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to\n`'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to\n'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.",
                    "enum": [
                        "TLSv1",
                        "TLSv1.1",
                        "TLSv1.2",
                        "TLSv1.3"
                    ],
                    "type": "string"
                },
                "passphrase": {
                    "description": "Shared passphrase used for a single private key and/or a PFX.",
                    "type": "string"
                },
                "pfx": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/PxfObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an\nalternative to providing key and cert individually. PFX is usually\nencrypted, if it is, passphrase will be used to decrypt it. Multiple\nPFX can be provided either as an array of unencrypted PFX buffers,\nor an array of objects in the form {buf: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted PFX will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "privateKeyEngine": {
                    "description": "Name of an OpenSSL engine to get private key from. Should be used\ntogether with privateKeyIdentifier.",
                    "type": "string"
                },
                "privateKeyIdentifier": {
                    "description": "Identifier of a private key managed by an OpenSSL engine. Should be\nused together with privateKeyEngine. Should not be set together with\nkey, because both options define a private key in different ways.",
                    "type": "string"
                },
                "secureOptions": {
                    "description": "Optionally affect the OpenSSL protocol behavior, which is not\nusually necessary. This should be used carefully if at all! Value is\na numeric bitmask of the SSL_OP_* options from OpenSSL Options",
                    "type": "number"
                },
                "secureProtocol": {
                    "description": "Legacy mechanism to select the TLS protocol version to use, it does\nnot support independent control of the minimum and maximum version,\nand does not support limiting the protocol to TLSv1.3. Use\nminVersion and maxVersion instead. The possible values are listed as\nSSL_METHODS, use the function names as strings. For example, use\n'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\nany TLS protocol version up to TLSv1.3. It is not recommended to use\nTLS versions less than 1.2, but it may be required for\ninteroperability. Default: none, see minVersion.",
                    "type": "string"
                },
                "sessionIdContext": {
                    "description": "Opaque identifier used by servers to ensure session state is not\nshared between applications. Unused by clients.",
                    "type": "string"
                },
                "sessionTimeout": {
                    "description": "The number of seconds after which a TLS session created by the\nserver will no longer be resumable. See Session Resumption for more\ninformation. Default: 300.",
                    "type": "number"
                },
                "sigalgs": {
                    "description": "Colon-separated list of supported signature algorithms. The list\ncan contain digest algorithms (SHA256, MD5 etc.), public key\nalgorithms (RSA-PSS, ECDSA etc.), combination of both (e.g\n'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).",
                    "type": "string"
                },
                "ticketKeys": {
                    "additionalProperties": false,
                    "description": "48-bytes of cryptographically strong pseudo-random data.\nSee Session Resumption for more information.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@25": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "BYTES_PER_ELEMENT",
                        "__@toStringTag@25",
                        "buffer",
                        "byteLength",
                        "byteOffset",
                        "length"
                    ],
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Server<ServerApplicationState>": {
            "description": "The server object is the main application container. The server manages all incoming requests along with all\nthe facilities provided by the framework. Each server supports a single connection (e.g. listen to port 80).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#server)",
            "properties": {
                "app": {
                    "$ref": "#/definitions/ServerApplicationState",
                    "description": "Provides a safe place to store server-specific run-time application data without potential conflicts with\nthe framework internals. The data can be accessed whenever the server is accessible.\nInitialized with an empty object.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverapp)"
                },
                "auth": {
                    "$ref": "#/definitions/ServerAuth",
                    "description": "Server Auth: properties and methods"
                },
                "cache": {
                    "$ref": "#/definitions/ServerCache",
                    "description": "[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servercacheoptions)"
                },
                "decorations": {
                    "description": "Provides access to the decorations already applied to various framework interfaces. The object must not be\nmodified directly, but only through server.decorate.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverdecorations)",
                    "properties": {
                        "request": {
                            "description": "decorations on the request object.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "server": {
                            "description": "decorations on the server object.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        "toolkit": {
                            "description": "decorations on the response toolkit.",
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "request",
                        "server",
                        "toolkit"
                    ],
                    "type": "object"
                },
                "events": {
                    "$ref": "#/definitions/ServerEvents",
                    "description": "Access: podium public interface.\nThe server events emitter. Utilizes the podium with support for event criteria validation, channels, and filters.\nUse the following methods to interact with server.events:\n[server.events.emit(criteria, data)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.emit()) - emit server events.\n[server.events.on(criteria, listener)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.on()) - subscribe to all events.\n[server.events.once(criteria, listener)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.once()) - subscribe to\nOther methods include: server.events.removeListener(name, listener), server.events.removeAllListeners(name), and server.events.hasListeners(name).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverevents)"
                },
                "info": {
                    "$ref": "#/definitions/ServerInfo",
                    "description": "An object containing information about the server where:\n* id - a unique server identifier (using the format '{hostname}:{pid}:{now base36}').\n* created - server creation timestamp.\n* started - server start timestamp (0 when stopped).\n* port - the connection port based on the following rules:\n* host - The host configuration value.\n* address - the active IP address the connection was bound to after starting. Set to undefined until the server has been started or when using a non TCP port (e.g. UNIX domain socket).\n* protocol - the protocol used:\n* 'http' - HTTP.\n* 'https' - HTTPS.\n* 'socket' - UNIX domain socket or Windows named pipe.\n* uri - a string representing the connection (e.g. 'http://example.com:8080' or 'socket:/unix/domain/socket/path'). Contains the uri value if set, otherwise constructed from the available\nsettings. If no port is configured or is set to 0, the uri will not include a port component until the server is started.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverinfo)"
                },
                "listener": {
                    "$ref": "#/definitions/Server<typeofIncomingMessage,typeofServerResponse>",
                    "description": "Access: read only and listener public interface.\nThe node HTTP server object.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverlistener)"
                },
                "load": {
                    "description": "An object containing the process load metrics (when load.sampleInterval is enabled):\n* eventLoopDelay - event loop delay milliseconds.\n* heapUsed - V8 heap usage.\n* rss - RSS memory usage.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverload)",
                    "properties": {
                        "eventLoopDelay": {
                            "description": "event loop delay milliseconds.",
                            "type": "number"
                        },
                        "heapUsed": {
                            "description": "V8 heap usage.",
                            "type": "number"
                        },
                        "rss": {
                            "description": "RSS memory usage.",
                            "type": "number"
                        }
                    },
                    "required": [
                        "eventLoopDelay",
                        "heapUsed",
                        "rss"
                    ],
                    "type": "object"
                },
                "methods": {
                    "$ref": "#/definitions/ServerMethods",
                    "description": "Server methods are functions registered with the server and used throughout the application as a common utility.\nTheir advantage is in the ability to configure them to use the built-in cache and share across multiple request\nhandlers without having to create a common module.\nsever.methods is an object which provides access to the methods registered via server.method() where each\nserver method name is an object property.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servermethods"
                },
                "mime": {
                    "$ref": "#/definitions/Mimos<{}>",
                    "description": "Provides access to the server MIME database used for setting content-type information. The object must not be\nmodified directly but only through the [mime](https://github.com/hapijs/hapi/blob/master/API.md#server.options.mime) server setting.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servermime)"
                },
                "plugins": {
                    "$ref": "#/definitions/PluginProperties",
                    "description": "An object containing the values exposed by each registered plugin where each key is a plugin name and the values\nare the exposed properties by each plugin using server.expose(). Plugins may set the value of\nthe server.plugins[name] object directly or via the server.expose() method.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverplugins)"
                },
                "realm": {
                    "$ref": "#/definitions/ServerRealm",
                    "description": "The realm object contains sandboxed server settings specific to each plugin or authentication strategy. When\nregistering a plugin or an authentication scheme, a server object reference is provided with a new server.realm\ncontainer specific to that registration. It allows each plugin to maintain its own settings without leaking\nand affecting other plugins.\nFor example, a plugin can set a default file path for local resources without breaking other plugins' configured\npaths. When calling server.bind(), the active realm's settings.bind property is set which is then used by\nroutes and extensions added at the same level (server root or plugin).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverrealm)"
                },
                "registrations": {
                    "$ref": "#/definitions/PluginsListRegistered",
                    "description": "An object of the currently registered plugins where each key is a registered plugin name and the value is\nan object containing:\n* version - the plugin version.\n* name - the plugin name.\n* options - (optional) options passed to the plugin during registration.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverregistrations)"
                },
                "settings": {
                    "$ref": "#/definitions/ServerOptions",
                    "description": "The server configuration object after defaults applied.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serversettings)"
                },
                "states": {
                    "$ref": "#/definitions/ServerState",
                    "description": "The server cookies manager.\nAccess: read only and statehood public interface.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverstates)"
                },
                "type": {
                    "description": "A string indicating the listener type where:\n* 'socket' - UNIX domain socket or Windows named pipe.\n* 'tcp' - an HTTP listener.",
                    "enum": [
                        "socket",
                        "tcp"
                    ],
                    "type": "string"
                },
                "version": {
                    "description": "The hapi module version number.",
                    "type": "string"
                }
            },
            "required": [
                "app",
                "auth",
                "cache",
                "decorations",
                "events",
                "info",
                "listener",
                "load",
                "methods",
                "mime",
                "plugins",
                "realm",
                "registrations",
                "settings",
                "states",
                "type",
                "version"
            ],
            "type": "object"
        },
        "Server<typeofIncomingMessage,typeofServerResponse>": {
            "properties": {
                "connections": {
                    "type": "number"
                },
                "headersTimeout": {
                    "description": "Limit the amount of time the parser will wait to receive the complete HTTP\nheaders.\n\nIf the timeout expires, the server responds with status 408 without\nforwarding the request to the request listener and then closes the connection.\n\nIt must be set to a non-zero value (e.g. 120 seconds) to protect against\npotential Denial-of-Service attacks in case the server is deployed without a\nreverse proxy in front.",
                    "type": "number"
                },
                "keepAliveTimeout": {
                    "description": "The number of milliseconds of inactivity a server needs to wait for additional\nincoming data, after it has finished writing the last response, before a socket\nwill be destroyed. If the server receives new data before the keep-alive\ntimeout has fired, it will reset the regular inactivity timeout, i.e., `server.timeout`.\n\nA value of `0` will disable the keep-alive timeout behavior on incoming\nconnections.\nA value of `0` makes the http server behave similarly to Node.js versions prior\nto 8.0.0, which did not have a keep-alive timeout.\n\nThe socket timeout logic is set up on connection, so changing this value only\naffects new connections to the server, not any existing connections.",
                    "type": "number"
                },
                "listening": {
                    "description": "Indicates whether or not the server is listening for connections.",
                    "type": "boolean"
                },
                "maxConnections": {
                    "description": "Set this property to reject connections when the server's connection count gets\nhigh.\n\nIt is not recommended to use this option once a socket has been sent to a child\nwith `child_process.fork()`.",
                    "type": "number"
                },
                "maxHeadersCount": {
                    "description": "Limits maximum incoming headers count. If set to 0, no limit will be applied.",
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "maxRequestsPerSocket": {
                    "description": "The maximum number of requests socket can handle\nbefore closing keep alive connection.\n\nA value of `0` will disable the limit.\n\nWhen the limit is reached it will set the `Connection` header value to `close`,\nbut will not actually close the connection, subsequent requests sent\nafter the limit is reached will get `503 Service Unavailable` as a response.",
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "requestTimeout": {
                    "description": "Sets the timeout value in milliseconds for receiving the entire request from\nthe client.\n\nIf the timeout expires, the server responds with status 408 without\nforwarding the request to the request listener and then closes the connection.\n\nIt must be set to a non-zero value (e.g. 120 seconds) to protect against\npotential Denial-of-Service attacks in case the server is deployed without a\nreverse proxy in front.",
                    "type": "number"
                },
                "timeout": {
                    "description": "The number of milliseconds of inactivity before a socket is presumed\nto have timed out.\n\nA value of `0` will disable the timeout behavior on incoming connections.\n\nThe socket timeout logic is set up on connection, so changing this\nvalue only affects new connections to the server, not any existing connections.",
                    "type": "number"
                }
            },
            "required": [
                "connections",
                "headersTimeout",
                "keepAliveTimeout",
                "listening",
                "maxConnections",
                "maxHeadersCount",
                "maxRequestsPerSocket",
                "requestTimeout",
                "timeout"
            ],
            "type": "object"
        },
        "ServerApi": {
            "properties": {
                "deprecationErrors": {
                    "type": "boolean"
                },
                "strict": {
                    "type": "boolean"
                },
                "version": {
                    "const": "1",
                    "type": "string"
                }
            },
            "required": [
                "version"
            ],
            "type": "object"
        },
        "ServerApplicationState": {
            "description": "User-extensible type for application specific state (`server.app`).",
            "type": "object"
        },
        "ServerAuth": {
            "properties": {
                "api": {
                    "$ref": "#/definitions/Record<string,ServerAuthSchemeObjectApi>",
                    "description": "An object where each key is an authentication strategy name and the value is the exposed strategy API.\nAvailable only when the authentication scheme exposes an API by returning an api key in the object\nreturned from its implementation function.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverauthapi)"
                },
                "settings": {
                    "description": "Contains the default authentication configuration is a default strategy was set via\n[server.auth.default()](https://github.com/hapijs/hapi/blob/master/API.md#server.auth.default()).",
                    "properties": {
                        "default": {
                            "$ref": "#/definitions/ServerAuthConfig"
                        }
                    },
                    "required": [
                        "default"
                    ],
                    "type": "object"
                }
            },
            "required": [
                "api",
                "settings"
            ],
            "type": "object"
        },
        "ServerAuthConfig": {
            "description": "An authentication configuration object using the same format as the route auth handler options.\nFor reference [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverauthdefaultoptions)",
            "properties": {
                "access": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                        },
                        {
                            "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                        },
                        {
                            "allOf": [
                                {
                                    "$ref": "#/definitions/RouteOptionsAccessScopeObject"
                                },
                                {
                                    "$ref": "#/definitions/RouteOptionsAccessEntityObject"
                                }
                            ]
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteOptionsAccessObject"
                            },
                            "type": "array"
                        }
                    ],
                    "default": "none.\nAn object or array of objects specifying the route access rules. Each rule is evaluated against an incoming request and access is granted if at least one of the rules matches. Each rule object\nmust include at least one of scope or entity.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccess)"
                },
                "entity": {
                    "default": "'any'.\nThe required authenticated entity type. If set, must match the entity value of the request authenticated credentials. Available values:\n* 'any' - the authentication can be on behalf of a user or application.\n* 'user' - the authentication must be on behalf of a user which is identified by the presence of a 'user' attribute in the credentials object returned by the authentication strategy.\n* 'app' - the authentication must be on behalf of an application which is identified by the lack of presence of a user attribute in the credentials object returned by the authentication\nstrategy.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccessentity)",
                    "enum": [
                        "any",
                        "app",
                        "user"
                    ],
                    "type": "string"
                },
                "mode": {
                    "default": "'required'.\nThe authentication mode. Available values:\n* 'required' - authentication is required.\n* 'optional' - authentication is optional - the request must include valid credentials or no credentials at all.\n* 'try' - similar to 'optional', any request credentials are attempted authentication, but if the credentials are invalid, the request proceeds regardless of the authentication error.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthmode)",
                    "enum": [
                        "optional",
                        "required",
                        "try"
                    ],
                    "type": "string"
                },
                "payload": {
                    "default": "false, unless the scheme requires payload authentication.\nIf set, the incoming request payload is authenticated after it is processed. Requires a strategy with payload authentication support (e.g. Hawk). Cannot be set to a value other than 'required'\nwhen the scheme sets the authentication options.payload to true. Available values:\n* false - no payload authentication.\n* 'required' - payload authentication required.\n* 'optional' - payload authentication performed only when the client includes payload authentication information (e.g. hash attribute in Hawk).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthpayload)",
                    "enum": [
                        false,
                        "optional",
                        "required"
                    ]
                },
                "scope": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "const": false,
                            "type": "boolean"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "default": "false (no scope requirements).\nThe application scope required to access the route. Value can be a scope string or an array of scope strings. When authenticated, the credentials object scope property must contain at least\none of the scopes defined to access the route. If a scope string begins with a + character, that scope is required. If a scope string begins with a ! character, that scope is forbidden. For\nexample, the scope ['!a', '+b', 'c', 'd'] means the incoming request credentials' scope must not include 'a', must include 'b', and must include one of 'c' or 'd'. You may also access\nproperties on the request object (query, params, payload, and credentials) to populate a dynamic scope by using the '{' and '}' characters around the property name, such as 'user-{params.id}'.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthaccessscope)"
                },
                "strategies": {
                    "default": "the default strategy set via server.auth.default().\nAn array of string strategy names in the order they should be attempted. Cannot be used together with strategy.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthstrategies)",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "strategy": {
                    "default": "the default strategy set via server.auth.default().\nA string strategy names. Cannot be used together with strategies.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-routeoptionsauthstrategy)",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ServerCache": {
            "description": "[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-servercacheoptions)",
            "type": "object"
        },
        "ServerEvents": {
            "description": "Access: podium public interface.\nThe server events emitter. Utilizes the podium with support for event criteria validation, channels, and filters.\nUse the following methods to interact with server.events:\n[server.event(events)](https://github.com/hapijs/hapi/blob/master/API.md#server.event()) - register application events.\n[server.events.emit(criteria, data)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.emit()) - emit server events.\n[server.events.on(criteria, listener)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.on()) - subscribe to all events.\n[server.events.once(criteria, listener)](https://github.com/hapijs/hapi/blob/master/API.md#server.events.once()) - subscribe to\nOther methods include: server.events.removeListener(name, listener), server.events.removeAllListeners(name), and server.events.hasListeners(name).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverevents)",
            "type": "object"
        },
        "ServerExtOptions": {
            "description": "An object with the following:\n* before - a string or array of strings of plugin names this method must execute before (on the same event). Otherwise, extension methods are executed in the order added.\n* after - a string or array of strings of plugin names this method must execute after (on the same event). Otherwise, extension methods are executed in the order added.\n* bind - a context object passed back to the provided method (via this) when called. Ignored if the method is an arrow function.\n* sandbox - if set to 'plugin' when adding a request extension points the extension is only added to routes defined by the current plugin. Not allowed when configuring route-level extensions, or\nwhen adding server extensions. Defaults to 'server' which applies to any route added to the server the extension is added to. For context [See\ndocs](https://github.com/hapijs/hapi/blob/master/API.md#-serverextevents)",
            "properties": {
                "after": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "a string or array of strings of plugin names this method must execute after (on the same event). Otherwise, extension methods are executed in the order added."
                },
                "before": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "a string or array of strings of plugin names this method must execute before (on the same event). Otherwise, extension methods are executed in the order added."
                },
                "bind": {
                    "additionalProperties": true,
                    "description": "a context object passed back to the provided method (via this) when called. Ignored if the method is an arrow function.",
                    "properties": {},
                    "type": "object"
                },
                "sandbox": {
                    "description": "if set to 'plugin' when adding a request extension points the extension is only added to routes defined by the current plugin. Not allowed when configuring route-level extensions, or when\nadding server extensions. Defaults to 'server' which applies to any route added to the server the extension is added to.",
                    "enum": [
                        "plugin",
                        "server"
                    ],
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ServerInfo": {
            "description": "[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverinfo)\nAn object containing information about the server where:",
            "properties": {
                "address": {
                    "description": "the active IP address the connection was bound to after starting. Set to undefined until the server has been\nstarted or when using a non TCP port (e.g. UNIX domain socket).",
                    "type": "string"
                },
                "created": {
                    "description": "server creation timestamp.",
                    "type": "number"
                },
                "host": {
                    "description": "The [host](https://github.com/hapijs/hapi/blob/master/API.md#server.options.host) configuration value.",
                    "type": "string"
                },
                "id": {
                    "description": "a unique server identifier (using the format '{hostname}:{pid}:{now base36}').",
                    "type": "string"
                },
                "port": {
                    "description": "the connection [port](https://github.com/hapijs/hapi/blob/master/API.md#server.options.port) based on the following rules:\n * before the server has been started: the configured port value.\n * after the server has been started: the actual port assigned when no port is configured or was set to 0.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "protocol": {
                    "description": "the protocol used:\n* 'http' - HTTP.\n* 'https' - HTTPS.\n* 'socket' - UNIX domain socket or Windows named pipe.",
                    "enum": [
                        "http",
                        "https",
                        "socket"
                    ],
                    "type": "string"
                },
                "started": {
                    "description": "server start timestamp (0 when stopped).",
                    "type": "number"
                },
                "uri": {
                    "description": "a string representing the connection (e.g. 'http://example.com:8080' or 'socket:/unix/domain/socket/path'). Contains\nthe uri value if set, otherwise constructed from the available settings. If no port is configured or is set\nto 0, the uri will not include a port component until the server is started.",
                    "type": "string"
                }
            },
            "required": [
                "address",
                "created",
                "host",
                "id",
                "port",
                "protocol",
                "started",
                "uri"
            ],
            "type": "object"
        },
        "ServerMethods": {
            "description": "An empty interface to allow typings of custom server.methods.",
            "type": "object"
        },
        "ServerOptions": {
            "description": "The server options control the behavior of the server object. Note that the options object is deeply cloned\n(with the exception of listener which is shallowly copied) and should not contain any values that are unsafe to perform deep copy on.\nAll options are optionals.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-server-options)",
            "properties": {
                "address": {
                    "default": "'0.0.0.0' (all available network interfaces).\nSets the hostname or IP address the server will listen on. If not configured, defaults to host if present, otherwise to all available network interfaces. Set to '127.0.0.1' or 'localhost' to\nrestrict the server to only those coming from the same host.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsaddress)",
                    "type": "string"
                },
                "app": {
                    "$ref": "#/definitions/ServerOptionsApp",
                    "default": "{}.\nProvides application-specific configuration which can later be accessed via server.settings.app. The framework does not interact with this object. It is simply a reference made available\nanywhere a server reference is provided. Note the difference between server.settings.app which is used to store static configuration values and server.app which is meant for storing run-time\nstate.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsapp)"
                },
                "autoListen": {
                    "default": "true.\nUsed to disable the automatic initialization of the listener. When false, indicates that the listener will be started manually outside the framework.\nCannot be set to true along with a port value.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsautolisten)",
                    "type": "boolean"
                },
                "cache": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/EnginePrototype<any>"
                        },
                        {
                            "$ref": "#/definitions/ServerOptionsCache"
                        },
                        {
                            "properties": {
                                "constructor": {
                                    "$ref": "#/definitions/EnginePrototype<any>"
                                },
                                "options": {
                                    "$ref": "#/definitions/ClientOptions"
                                }
                            },
                            "required": [
                                "constructor"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/ServerOptionsCache"
                            },
                            "type": "array"
                        }
                    ],
                    "default": "{ engine: require('@hapi/catbox-memory' }.\nSets up server-side caching providers. Every server includes a default cache for storing application state. By default, a simple memory-based cache is created which has limited capacity and\ncapabilities. hapi uses catbox for its cache implementation which includes support for common storage solutions (e.g. Redis, MongoDB, Memcached, Riak, among others). Caching is only utilized\nif methods and plugins explicitly store their state in the cache. The server cache configuration only defines the storage container itself. The configuration can be assigned one or more\n(array):\n* a class or prototype function (usually obtained by calling require() on a catbox strategy such as require('@hapi/catbox-redis')). A new catbox client will be created internally using this\nfunction.\n* a configuration object with the following:\n* * engine - a class, a prototype function, or a catbox engine object.\n* * name - an identifier used later when provisioning or configuring caching for server methods or plugins. Each cache name must be unique. A single item may omit the name option which defines\nthe default cache. If every cache includes a name, a default memory cache is provisioned as well.\n* * shared - if true, allows multiple cache users to share the same segment (e.g. multiple methods using the same cache storage container). Default to false.\n* * partition - (optional) string used to isolate cached data. Defaults to 'hapi-cache'.\n* * other options passed to the catbox strategy used. Other options are only passed to catbox when engine above is a class or function and ignored if engine is a catbox engine object).\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionscache)"
                },
                "compression": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ServerOptionsCompression"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": "{ minBytes: 1024 }.\nDefines server handling of content encoding requests. If false, response content encoding is disabled and no compression is performed by the server."
                },
                "debug": {
                    "anyOf": [
                        {
                            "properties": {
                                "log": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": "string"
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "const": false,
                                            "type": "boolean"
                                        },
                                        {
                                            "type": "string"
                                        }
                                    ]
                                },
                                "request": {
                                    "anyOf": [
                                        {
                                            "items": {
                                                "type": "string"
                                            },
                                            "type": "array"
                                        },
                                        {
                                            "const": false,
                                            "type": "boolean"
                                        },
                                        {
                                            "type": "string"
                                        }
                                    ]
                                }
                            },
                            "type": "object"
                        },
                        {
                            "const": false,
                            "type": "boolean"
                        }
                    ],
                    "default": "{ request: ['implementation'] }.\nDetermines which logged events are sent to the console. This should only be used for development and does not affect which events are actually logged internally and recorded. Set to false to\ndisable all console logging, or to an object with:\n* log - a string array of server log tags to be displayed via console.error() when the events are logged via server.log() as well as internally generated server logs. Defaults to no output.\n* request - a string array of request log tags to be displayed via console.error() when the events are logged via request.log() as well as internally generated request logs. For example, to\ndisplay all errors, set the option to ['error']. To turn off all console debug messages set it to false. To display all request logs, set it to '*'. Defaults to uncaught errors thrown in\nexternal code (these errors are handled automatically and result in an Internal Server Error response) or runtime errors due to developer error. For example, to display all errors, set the log\nor request to ['error']. To turn off all output set the log or request to false. To display all server logs, set the log or request to '*'. To disable all debug information, set debug to\nfalse."
                },
                "host": {
                    "default": "the operating system hostname and if not available, to 'localhost'.\nThe public hostname or IP address. Used to set server.info.host and server.info.uri and as address is none provided.",
                    "type": "string"
                },
                "info": {
                    "properties": {
                        "remote": {
                            "default": "false.\nIf true, the request.info.remoteAddress and request.info.remotePort are populated when the request is received which can consume more resource (but is ok if the information is needed,\nespecially for aborted requests). When false, the fields are only populated upon demand (but will be undefined if accessed after the request is aborted).",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "listener": {
                    "$ref": "#/definitions/Server<typeofIncomingMessage,typeofServerResponse>",
                    "default": "none.\nAn optional node HTTP (or HTTPS) http.Server object (or an object with a compatible interface).\nIf the listener needs to be manually started, set autoListen to false.\nIf the listener uses TLS, set tls to true."
                },
                "load": {
                    "default": "{ sampleInterval: 0 }.\nServer excessive load handling limits where:\n* sampleInterval - the frequency of sampling in milliseconds. When set to 0, the other load options are ignored. Defaults to 0 (no sampling).\n* maxHeapUsedBytes - maximum V8 heap size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to 0 (no limit).\n* maxRssBytes - maximum process RSS size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to 0 (no limit).\n* maxEventLoopDelay - maximum event loop delay duration in milliseconds over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to 0 (no limit).",
                    "properties": {
                        "maxEventLoopDelay": {
                            "description": "maximum event loop delay duration in milliseconds over which incoming requests are rejected with an HTTP Server Timeout (503) response.\nDefaults to 0 (no limit).",
                            "type": "number"
                        },
                        "maxHeapUsedBytes": {
                            "description": "maximum V8 heap size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to 0 (no limit).",
                            "type": "number"
                        },
                        "maxRssBytes": {
                            "description": "maximum process RSS size over which incoming requests are rejected with an HTTP Server Timeout (503) response. Defaults to 0 (no limit).",
                            "type": "number"
                        },
                        "sampleInterval": {
                            "description": "the frequency of sampling in milliseconds. When set to 0, the other load options are ignored. Defaults to 0 (no sampling).",
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "mime": {
                    "$ref": "#/definitions/MimosOptions<{}>",
                    "default": "none.\nOptions passed to the mimos module when generating the mime database used by the server (and accessed via server.mime):\n* override - an object hash that is merged into the built in mime information specified here. Each key value pair represents a single mime object. Each override value must contain:\n* key - the lower-cased mime-type string (e.g. 'application/javascript').\n* value - an object following the specifications outlined here. Additional values include:\n* * type - specify the type value of result objects, defaults to key.\n* * predicate - method with signature function(mime) when this mime type is found in the database, this function will execute to allows customizations.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsmime)"
                },
                "operations": {
                    "default": "{ cleanStop: true }\nDefines server handling of server operations.",
                    "properties": {
                        "cleanStop": {
                            "default": "true\nIf true, the server keeps track of open connections and properly closes them when the server is stopped.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsoperations)",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "plugins": {
                    "$ref": "#/definitions/PluginSpecificConfiguration",
                    "default": "{}.\nPlugin-specific configuration which can later be accessed via server.settings.plugins. plugins is an object where each key is a plugin name and the value is the configuration. Note the\ndifference between server.settings.plugins which is used to store static configuration values and server.plugins which is meant for storing run-time state."
                },
                "port": {
                    "default": "0 (an ephemeral port).\nThe TCP port the server will listen to. Defaults the next available port when the server is started (and assigned to server.info.port).\nIf port is a string containing a '/' character, it is used as a UNIX domain socket path. If it starts with '\\.\\pipe', it is used as a Windows named pipe.",
                    "type": [
                        "string",
                        "number"
                    ]
                },
                "query": {
                    "description": "Query parameter configuration.",
                    "type": "object"
                },
                "router": {
                    "default": "{ isCaseSensitive: true, stripTrailingSlash: false }.\nControls how incoming request URIs are matched against the routing table:\n* isCaseSensitive - determines whether the paths '/example' and '/EXAMPLE' are considered different resources. Defaults to true.\n* stripTrailingSlash - removes trailing slashes on incoming paths. Defaults to false.",
                    "properties": {
                        "isCaseSensitive": {
                            "type": "boolean"
                        },
                        "stripTrailingSlash": {
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "routes": {
                    "$ref": "#/definitions/RouteOptions<ReqRefDefaults>",
                    "default": "none.\nA route options object used as the default configuration for every route."
                },
                "state": {
                    "description": "Default value:\n{\n    strictHeader: true,\n    ignoreErrors: false,\n    isSecure: true,\n    isHttpOnly: true,\n    isSameSite: 'Strict',\n    encoding: 'none'\n}\nSets the default configuration for every state (cookie) set explicitly via server.state() or implicitly (without definition) using the state configuration object.",
                    "properties": {
                        "encoding": {
                            "enum": [
                                "base64",
                                "base64json",
                                "form",
                                "iron",
                                "none"
                            ],
                            "type": "string"
                        },
                        "ignoreErrors": {
                            "type": "boolean"
                        },
                        "isHttpOnly": {
                            "type": "boolean"
                        },
                        "isSameSite": {
                            "enum": [
                                "Lax",
                                "None",
                                "Strict",
                                false
                            ]
                        },
                        "isSecure": {
                            "type": "boolean"
                        },
                        "strictHeader": {
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "tls": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ServerOptions<typeofIncomingMessage,typeofServerResponse>"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": "none.\nUsed to create an HTTPS connection. The tls object is passed unchanged to the node HTTPS server as described in the node HTTPS documentation."
                },
                "uri": {
                    "default": "constructed from runtime server information.\nThe full public URI without the path (e.g. 'http://example.com:8080'). If present, used as the server server.info.uri, otherwise constructed from the server settings.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "ServerOptions<typeofIncomingMessage,typeofServerResponse>": {
            "allOf": [
                {
                    "$ref": "#/definitions/SecureContextOptions"
                },
                {
                    "$ref": "#/definitions/TlsOptions"
                },
                {
                    "$ref": "#/definitions/ServerOptions<typeofIncomingMessage,typeofServerResponse>_1"
                }
            ]
        },
        "ServerOptions<typeofIncomingMessage,typeofServerResponse>_1": {
            "properties": {
                "IncomingMessage": {
                    "description": "Specifies the `IncomingMessage` class to be used. Useful for extending the original `IncomingMessage`.",
                    "properties": {
                        "Duplex": {
                            "$ref": "#/definitions/typeofDuplex",
                            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                        },
                        "EventEmitter": {
                            "$ref": "#/definitions/typeofimport(\"events\")",
                            "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                        },
                        "EventEmitterAsyncResource": {
                            "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                        },
                        "PassThrough": {
                            "$ref": "#/definitions/typeofPassThrough",
                            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                        },
                        "Readable": {
                            "$ref": "#/definitions/typeofReadable"
                        },
                        "Stream": {
                            "$ref": "#/definitions/typeofStream"
                        },
                        "Transform": {
                            "$ref": "#/definitions/typeofTransform",
                            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                        },
                        "Writable": {
                            "$ref": "#/definitions/typeofWritable"
                        },
                        "addAbortSignal": {
                            "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                            "type": "object"
                        },
                        "captureRejectionSymbol": {
                            "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                            "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                        },
                        "captureRejections": {
                            "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                            "type": "boolean"
                        },
                        "consumers": {
                            "properties": {
                                "arrayBuffer": {
                                    "type": "object"
                                },
                                "blob": {
                                    "type": "object"
                                },
                                "buffer": {
                                    "type": "object"
                                },
                                "json": {
                                    "type": "object"
                                },
                                "text": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "arrayBuffer",
                                "blob",
                                "buffer",
                                "json",
                                "text"
                            ],
                            "type": "object"
                        },
                        "defaultMaxListeners": {
                            "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                            "type": "number"
                        },
                        "duplexPair": {
                            "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                            "type": "object"
                        },
                        "errorMonitor": {
                            "$ref": "#/definitions/typeoferrorMonitor",
                            "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                        },
                        "finished": {
                            "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "__promisify__"
                            ],
                            "type": "object"
                        },
                        "getDefaultHighWaterMark": {
                            "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                            "type": "object"
                        },
                        "isErrored": {
                            "description": "Returns whether the stream has encountered an error.",
                            "type": "object"
                        },
                        "isReadable": {
                            "description": "Returns whether the stream is readable.",
                            "type": "object"
                        },
                        "pipeline": {
                            "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "__promisify__"
                            ],
                            "type": "object"
                        },
                        "promises": {
                            "properties": {
                                "finished": {
                                    "type": "object"
                                },
                                "pipeline": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "finished",
                                "pipeline"
                            ],
                            "type": "object"
                        },
                        "prototype": {
                            "$ref": "#/definitions/IncomingMessage"
                        },
                        "setDefaultHighWaterMark": {
                            "description": "Sets the default highWaterMark used by streams.",
                            "type": "object"
                        }
                    },
                    "required": [
                        "Duplex",
                        "EventEmitter",
                        "EventEmitterAsyncResource",
                        "PassThrough",
                        "Readable",
                        "Stream",
                        "Transform",
                        "Writable",
                        "addAbortSignal",
                        "captureRejectionSymbol",
                        "captureRejections",
                        "consumers",
                        "defaultMaxListeners",
                        "duplexPair",
                        "errorMonitor",
                        "finished",
                        "getDefaultHighWaterMark",
                        "isErrored",
                        "isReadable",
                        "pipeline",
                        "promises",
                        "prototype",
                        "setDefaultHighWaterMark"
                    ],
                    "type": "object"
                },
                "ServerResponse": {
                    "description": "Specifies the `ServerResponse` class to be used. Useful for extending the original `ServerResponse`.",
                    "properties": {
                        "Duplex": {
                            "$ref": "#/definitions/typeofDuplex",
                            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                        },
                        "EventEmitter": {
                            "$ref": "#/definitions/typeofimport(\"events\")",
                            "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                        },
                        "EventEmitterAsyncResource": {
                            "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                        },
                        "PassThrough": {
                            "$ref": "#/definitions/typeofPassThrough",
                            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                        },
                        "Readable": {
                            "$ref": "#/definitions/typeofReadable"
                        },
                        "Stream": {
                            "$ref": "#/definitions/typeofStream"
                        },
                        "Transform": {
                            "$ref": "#/definitions/typeofTransform",
                            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                        },
                        "Writable": {
                            "$ref": "#/definitions/typeofWritable"
                        },
                        "addAbortSignal": {
                            "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                            "type": "object"
                        },
                        "captureRejectionSymbol": {
                            "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                            "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                        },
                        "captureRejections": {
                            "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                            "type": "boolean"
                        },
                        "consumers": {
                            "properties": {
                                "arrayBuffer": {
                                    "type": "object"
                                },
                                "blob": {
                                    "type": "object"
                                },
                                "buffer": {
                                    "type": "object"
                                },
                                "json": {
                                    "type": "object"
                                },
                                "text": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "arrayBuffer",
                                "blob",
                                "buffer",
                                "json",
                                "text"
                            ],
                            "type": "object"
                        },
                        "defaultMaxListeners": {
                            "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                            "type": "number"
                        },
                        "duplexPair": {
                            "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                            "type": "object"
                        },
                        "errorMonitor": {
                            "$ref": "#/definitions/typeoferrorMonitor",
                            "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                        },
                        "finished": {
                            "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "__promisify__"
                            ],
                            "type": "object"
                        },
                        "getDefaultHighWaterMark": {
                            "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                            "type": "object"
                        },
                        "isErrored": {
                            "description": "Returns whether the stream has encountered an error.",
                            "type": "object"
                        },
                        "isReadable": {
                            "description": "Returns whether the stream is readable.",
                            "type": "object"
                        },
                        "pipeline": {
                            "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                            "properties": {
                                "__promisify__": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "__promisify__"
                            ],
                            "type": "object"
                        },
                        "promises": {
                            "properties": {
                                "finished": {
                                    "type": "object"
                                },
                                "pipeline": {
                                    "type": "object"
                                }
                            },
                            "required": [
                                "finished",
                                "pipeline"
                            ],
                            "type": "object"
                        },
                        "prototype": {
                            "$ref": "#/definitions/ServerResponse<any>"
                        },
                        "setDefaultHighWaterMark": {
                            "description": "Sets the default highWaterMark used by streams.",
                            "type": "object"
                        }
                    },
                    "required": [
                        "Duplex",
                        "EventEmitter",
                        "EventEmitterAsyncResource",
                        "PassThrough",
                        "Readable",
                        "Stream",
                        "Transform",
                        "Writable",
                        "addAbortSignal",
                        "captureRejectionSymbol",
                        "captureRejections",
                        "consumers",
                        "defaultMaxListeners",
                        "duplexPair",
                        "errorMonitor",
                        "finished",
                        "getDefaultHighWaterMark",
                        "isErrored",
                        "isReadable",
                        "pipeline",
                        "promises",
                        "prototype",
                        "setDefaultHighWaterMark"
                    ],
                    "type": "object"
                },
                "connectionsCheckingInterval": {
                    "default": 30000,
                    "description": "Sets the interval value in milliseconds to check for request and headers timeout in incomplete requests.",
                    "type": "number"
                },
                "highWaterMark": {
                    "description": "Optionally overrides all `socket`s' `readableHighWaterMark` and `writableHighWaterMark`.\nThis affects `highWaterMark` property of both `IncomingMessage` and `ServerResponse`.\nDefault:",
                    "type": "number"
                },
                "insecureHTTPParser": {
                    "default": false,
                    "description": "Use an insecure HTTP parser that accepts invalid HTTP headers when `true`.\nUsing the insecure parser should be avoided.\nSee --insecure-http-parser for more information.",
                    "type": "boolean"
                },
                "joinDuplicateHeaders": {
                    "default": false,
                    "description": "It joins the field line values of multiple headers in a request with `, ` instead of discarding the duplicates.",
                    "type": "boolean"
                },
                "keepAlive": {
                    "default": false,
                    "description": "If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,\nsimilarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.",
                    "type": "boolean"
                },
                "keepAliveInitialDelay": {
                    "default": 0,
                    "description": "If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.",
                    "type": "number"
                },
                "keepAliveTimeout": {
                    "default": 5000,
                    "description": "The number of milliseconds of inactivity a server needs to wait for additional incoming data,\nafter it has finished writing the last response, before a socket will be destroyed.",
                    "type": "number"
                },
                "maxHeaderSize": {
                    "default": 16384,
                    "description": "Optionally overrides the value of `--max-http-header-size` for requests received by\nthis server, i.e. the maximum length of request headers in bytes.",
                    "type": "number"
                },
                "noDelay": {
                    "default": true,
                    "description": "If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.",
                    "type": "boolean"
                },
                "requestTimeout": {
                    "default": 300000,
                    "description": "Sets the timeout value in milliseconds for receiving the entire request from the client.",
                    "type": "number"
                },
                "uniqueHeaders": {
                    "description": "A list of response headers that should be sent only once.\nIf the header's value is an array, the items will be joined using `; `.",
                    "items": {
                        "anyOf": [
                            {
                                "items": {
                                    "type": "string"
                                },
                                "type": "array"
                            },
                            {
                                "type": "string"
                            }
                        ]
                    },
                    "type": "array"
                }
            },
            "type": "object"
        },
        "ServerOptionsApp": {
            "description": "Empty interface to allow for custom augmentation.",
            "type": "object"
        },
        "ServerOptionsCache": {
            "additionalProperties": {},
            "description": "hapi uses catbox for its cache implementation which includes support for common storage solutions (e.g. Redis,\nMongoDB, Memcached, Riak, among others). Caching is only utilized if methods and plugins explicitly store their state in the cache.\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-cache)",
            "properties": {
                "dropOnError": {
                    "description": "dropOnError - if true, an error or timeout in the generateFunc causes the stale value to be evicted from the cache. Defaults to true.",
                    "type": "boolean"
                },
                "engine": {
                    "$ref": "#/definitions/ClientApi<any>",
                    "description": "catbox engine object."
                },
                "expiresAt": {
                    "description": "expiresAt - time of day expressed in 24h notation using the 'HH:MM' format, at which point all cache records for the route expire. Uses local time. Cannot be used together with expiresIn.",
                    "type": "string"
                },
                "expiresIn": {
                    "description": "expiresIn - relative expiration expressed in the number of milliseconds since the item was saved in the cache. Cannot be used together with expiresAt.",
                    "type": "number"
                },
                "generateFunc": {
                    "description": "generateFunc - a function used to generate a new cache item if one is not found in the cache when calling get(). The method's signature is function(id, next) where:",
                    "type": "object"
                },
                "generateIgnoreWriteError": {
                    "description": "generateIgnoreWriteError - if false, an upstream cache write error will be passed back with the generated value when calling the get() method. Defaults to true.",
                    "type": "boolean"
                },
                "generateOnReadError": {
                    "description": "generateOnReadError - if false, an upstream cache read error will stop the get() method from calling the generate function and will instead pass back the cache error. Defaults to true.",
                    "type": "boolean"
                },
                "generateTimeout": {
                    "anyOf": [
                        {
                            "const": false,
                            "type": "boolean"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "generateTimeout - number of milliseconds to wait before returning a timeout error when the generateFunc function takes too long to return a value.\nWhen the value is eventually returned, it is stored in the cache for future requests. Required if generateFunc is present.\nSet to false to disable timeouts which may cause all get() requests to get stuck forever."
                },
                "name": {
                    "description": "an identifier used later when provisioning or configuring caching for server methods or plugins. Each cache name must be unique. A single item may omit the name option which defines\nthe default cache. If every cache includes a name, a default memory cache is provisioned as well.",
                    "type": "string"
                },
                "partition": {
                    "description": "(optional) string used to isolate cached data. Defaults to 'hapi-cache'.",
                    "type": "string"
                },
                "pendingGenerateTimeout": {
                    "default": "0, no blocking of concurrent generateFunc calls beyond staleTimeout.",
                    "description": "pendingGenerateTimeout - number of milliseconds while generateFunc call is in progress for a given id, before a subsequent generateFunc call is allowed.",
                    "type": "number"
                },
                "provider": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/EnginePrototype<any>"
                        },
                        {
                            "properties": {
                                "constructor": {
                                    "$ref": "#/definitions/EnginePrototype<any>"
                                },
                                "options": {
                                    "$ref": "#/definitions/ClientOptions"
                                }
                            },
                            "required": [
                                "constructor"
                            ],
                            "type": "object"
                        }
                    ],
                    "description": "a class or a prototype function"
                },
                "shared": {
                    "description": "if true, allows multiple cache users to share the same segment (e.g. multiple methods using the same cache storage container). Default to false.",
                    "type": "boolean"
                },
                "staleIn": {
                    "description": "staleIn - number of milliseconds to mark an item stored in cache as stale and attempt to regenerate it when generateFunc is provided.\nMust be less than expiresIn. Alternatively function that returns staleIn value in milliseconds. The function signature is function(stored, ttl) where:\n * stored - the timestamp when the item was stored in the cache (in milliseconds).\n * ttl - the remaining time-to-live (not the original value used when storing the object).",
                    "type": [
                        "number",
                        "object"
                    ]
                },
                "staleTimeout": {
                    "description": "staleTimeout - number of milliseconds to wait before returning a stale value while generateFunc is generating a fresh value.",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ServerOptionsCompression": {
            "properties": {
                "minBytes": {
                    "type": "number"
                }
            },
            "required": [
                "minBytes"
            ],
            "type": "object"
        },
        "ServerRealm": {
            "description": "The realm object contains sandboxed server settings specific to each plugin or authentication strategy. When registering a plugin or an authentication scheme, a server object reference is provided\nwith a new server.realm container specific to that registration. It allows each plugin to maintain its own settings without leaking and affecting other plugins. For example, a plugin can set a\ndefault file path for local resources without breaking other plugins' configured paths. When calling server.bind(), the active realm's settings.bind property is set which is then used by routes\nand extensions added at the same level (server root or plugin).\n\nhttps://github.com/hapijs/hapi/blob/master/API.md#server.realm",
            "properties": {
                "modifiers": {
                    "description": "when the server object is provided as an argument to the plugin register() method, modifiers provides the registration preferences passed the server.register() method and includes:",
                    "properties": {
                        "route": {
                            "description": "routes preferences:",
                            "properties": {
                                "prefix": {
                                    "description": "the route path prefix used by any calls to server.route() from the server. Note that if a prefix is used and the route path is set to '/', the resulting path will not include\nthe trailing slash.",
                                    "type": "string"
                                },
                                "vhost": {
                                    "description": "the route virtual host settings used by any calls to server.route() from the server.",
                                    "type": "string"
                                }
                            },
                            "required": [
                                "prefix",
                                "vhost"
                            ],
                            "type": "object"
                        }
                    },
                    "required": [
                        "route"
                    ],
                    "type": "object"
                },
                "parent": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ServerRealm"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "the realm of the parent server object, or null for the root server."
                },
                "plugin": {
                    "description": "the active plugin name (empty string if at the server root).",
                    "type": "string"
                },
                "pluginOptions": {
                    "additionalProperties": true,
                    "description": "the plugin options object passed at registration.",
                    "properties": {},
                    "type": "object"
                },
                "plugins": {
                    "$ref": "#/definitions/PluginsStates",
                    "description": "plugin-specific state to be shared only among activities sharing the same active state. plugins is an object where each key is a plugin name and the value is the plugin state."
                },
                "settings": {
                    "description": "settings overrides",
                    "properties": {
                        "bind": {
                            "additionalProperties": true,
                            "properties": {},
                            "type": "object"
                        },
                        "files": {
                            "properties": {
                                "relativeTo": {
                                    "type": "string"
                                }
                            },
                            "required": [
                                "relativeTo"
                            ],
                            "type": "object"
                        }
                    },
                    "required": [
                        "bind",
                        "files"
                    ],
                    "type": "object"
                }
            },
            "required": [
                "modifiers",
                "parent",
                "plugin",
                "pluginOptions",
                "plugins",
                "settings"
            ],
            "type": "object"
        },
        "ServerResponse<any>": {
            "description": "This object is created internally by an HTTP server, not by the user. It is\npassed as the second parameter to the `'request'` event.",
            "properties": {
                "chunkedEncoding": {
                    "type": "boolean"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "connection": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Socket"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Alias of `outgoingMessage.socket`."
                },
                "destroyed": {
                    "description": "Is `true` after `writable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "finished": {
                    "type": "boolean"
                },
                "headersSent": {
                    "description": "Read-only. `true` if the headers were sent, otherwise `false`.",
                    "type": "boolean"
                },
                "req": {},
                "sendDate": {
                    "type": "boolean"
                },
                "shouldKeepAlive": {
                    "type": "boolean"
                },
                "socket": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Socket"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Reference to the underlying socket. Usually, users will not want to access\nthis property.\n\nAfter calling `outgoingMessage.end()`, this property will be nulled."
                },
                "statusCode": {
                    "description": "When using implicit headers (not calling `response.writeHead()` explicitly),\nthis property controls the status code that will be sent to the client when\nthe headers get flushed.\n\n```js\nresponse.statusCode = 404;\n```\n\nAfter response header was sent to the client, this property indicates the\nstatus code which was sent out.",
                    "type": "number"
                },
                "statusMessage": {
                    "description": "When using implicit headers (not calling `response.writeHead()` explicitly),\nthis property controls the status message that will be sent to the client when\nthe headers get flushed. If this is left as `undefined` then the standard\nmessage for the status code will be used.\n\n```js\nresponse.statusMessage = 'Not found';\n```\n\nAfter response header was sent to the client, this property indicates the\nstatus message which was sent out.",
                    "type": "string"
                },
                "strictContentLength": {
                    "description": "If set to `true`, Node.js will check whether the `Content-Length` header value and the size of the body, in bytes, are equal.\nMismatching the `Content-Length` header value will result\nin an `Error` being thrown, identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.",
                    "type": "boolean"
                },
                "useChunkedEncodingByDefault": {
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "chunkedEncoding",
                "closed",
                "connection",
                "destroyed",
                "errored",
                "finished",
                "headersSent",
                "req",
                "sendDate",
                "shouldKeepAlive",
                "socket",
                "statusCode",
                "statusMessage",
                "strictContentLength",
                "useChunkedEncodingByDefault",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "ServerRoute<ReqRefDefaults>": {
            "description": "A route configuration object or an array of configuration objects where each object contains:\n* path - (required) the absolute path used to match incoming requests (must begin with '/'). Incoming requests are compared to the configured paths based on the server's router configuration. The\npath can include named parameters enclosed in {} which will be matched against literal values in the request as described in Path parameters.\n* method - (required) the HTTP method. Typically one of 'GET', 'POST', 'PUT', 'PATCH', 'DELETE', or 'OPTIONS'. Any HTTP method is allowed, except for 'HEAD'. Use '*' to match against any HTTP\nmethod (only when an exact match was not found, and any match with a specific method will be given a higher priority over a wildcard match). Can be assigned an array of methods which has the same\nresult as adding the same route with different methods manually.\n* vhost - (optional) a domain string or an array of domain strings for limiting the route to only requests with a matching host header field. Matching is done against the hostname part of the\nheader only (excluding the port). Defaults to all hosts.\n* handler - (required when handler is not set) the route handler function called to generate the response after successful authentication and validation.\n* options - additional route options. The options value can be an object or a function that returns an object using the signature function(server) where server is the server the route is being\nadded to and this is bound to the current realm's bind option.\n* rules - route custom rules object. The object is passed to each rules processor registered with server.rules(). Cannot be used if route.options.rules is defined.\nFor context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverrouteroute)",
            "properties": {
                "handler": {
                    "anyOf": [
                        {
                            "description": "Lifecycle methods are the interface between the framework and the application. Many of the request lifecycle steps:\nextensions, authentication, handlers, pre-handler methods, and failAction function values are lifecycle methods\nprovided by the developer and executed by the framework.\nEach lifecycle method is a function with the signature await function(request, h, [err]) where:\n* request - the request object.\n* h - the response toolkit the handler must call to set a response and return control back to the framework.\n* err - an error object available only when the method is used as a failAction value.",
                            "type": "object"
                        },
                        {
                            "$ref": "#/definitions/HandlerDecorations"
                        }
                    ],
                    "description": "(required when handler is not set) the route handler function called to generate the response after successful authentication and validation."
                },
                "method": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/RouteDefMethods"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "*",
                                "ACL",
                                "BIND",
                                "CHECKOUT",
                                "CONNECT",
                                "COPY",
                                "DELETE",
                                "GET",
                                "LINK",
                                "LOCK",
                                "M-SEARCH",
                                "MERGE",
                                "MKACTIVITY",
                                "MKCALENDAR",
                                "MKCOL",
                                "MOVE",
                                "NOTIFY",
                                "OPTIONS",
                                "PATCH",
                                "POST",
                                "PROPFIND",
                                "PROPPATCH",
                                "PURGE",
                                "PUT",
                                "REBIND",
                                "REPORT",
                                "SEARCH",
                                "SOURCE",
                                "SUBSCRIBE",
                                "TRACE",
                                "UNBIND",
                                "UNLINK",
                                "UNLOCK",
                                "UNSUBSCRIBE",
                                "acl",
                                "bind",
                                "checkout",
                                "connect",
                                "copy",
                                "delete",
                                "get",
                                "link",
                                "lock",
                                "m-search",
                                "merge",
                                "mkactivity",
                                "mkcalendar",
                                "mkcol",
                                "move",
                                "notify",
                                "options",
                                "patch",
                                "post",
                                "propfind",
                                "proppatch",
                                "purge",
                                "put",
                                "rebind",
                                "report",
                                "search",
                                "source",
                                "subscribe",
                                "trace",
                                "unbind",
                                "unlink",
                                "unlock",
                                "unsubscribe"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "(required) the HTTP method. Typically one of 'GET', 'POST', 'PUT', 'PATCH', 'DELETE', or 'OPTIONS'. Any HTTP method is allowed, except for 'HEAD'. Use '*' to match against any HTTP method\n(only when an exact match was not found, and any match with a specific method will be given a higher priority over a wildcard match). Can be assigned an array of methods which has the same\nresult as adding the same route with different methods manually."
                },
                "options": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteOptions<ReqRefDefaults>"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "additional route options. The options value can be an object or a function that returns an object using the signature function(server) where server is the server the route is being added to\nand this is bound to the current realm's bind option."
                },
                "path": {
                    "description": "(required) the absolute path used to match incoming requests (must begin with '/'). Incoming requests are compared to the configured paths based on the server's router configuration. The path\ncan include named parameters enclosed in {} which will be matched against literal values in the request as described in Path parameters. For context [See\ndocs](https://github.com/hapijs/hapi/blob/master/API.md#-serverrouteroute) For context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#path-parameters)",
                    "type": "string"
                },
                "rules": {
                    "$ref": "#/definitions/RouteRules",
                    "description": "route custom rules object. The object is passed to each rules processor registered with server.rules(). Cannot be used if route.options.rules is defined."
                },
                "vhost": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "(optional) a domain string or an array of domain strings for limiting the route to only requests with a matching host header field. Matching is done against the hostname part of the header\nonly (excluding the port). Defaults to all hosts."
                }
            },
            "required": [
                "method",
                "path"
            ],
            "type": "object"
        },
        "ServerState": {
            "description": "For context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverstatename-options)\nFor context [See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serveroptionsstate)",
            "properties": {
                "cookies": {
                    "additionalProperties": {
                        "$ref": "#/definitions/ServerStateCookieOptions"
                    },
                    "description": "An object containing the configuration of each cookie added via [server.state()](https://github.com/hapijs/hapi/blob/master/API.md#server.state()) where each key is the\ncookie name and value is the configuration object.",
                    "type": "object"
                },
                "names": {
                    "description": "An array containing the names of all configured cookies.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "settings": {
                    "$ref": "#/definitions/ServerStateCookieOptions",
                    "description": "The server cookies manager settings. The settings are based on the values configured in [server.options.state](https://github.com/hapijs/hapi/blob/master/API.md#server.options.state)."
                },
                "states": {
                    "additionalProperties": true,
                    "description": "The server cookies manager.\nAccess: read only and statehood public interface.",
                    "properties": {},
                    "type": "object"
                }
            },
            "required": [
                "cookies",
                "names",
                "settings",
                "states"
            ],
            "type": "object"
        },
        "ServerStateCookieOptions": {
            "description": "Optional cookie settings\n[See docs](https://github.com/hapijs/hapi/blob/master/API.md#-serverstatename-options)",
            "properties": {
                "clearInvalid": {
                    "default": false,
                    "description": "If true, automatically instruct the client to remove invalid cookies.",
                    "type": "boolean"
                },
                "domain": {
                    "default": "null (no domain)",
                    "description": "The domain scope.",
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "encoding": {
                    "default": "'none'",
                    "description": "Encoding performs on the provided value before serialization. Options are:\n\n    - `none` - no encoding. When used, the cookie value must be a string.\n    - `base64` - string value is encoded using Base64.\n    - `base64json` - object value is JSON-stringified then encoded using Base64.\n    - `form` - object value is encoded using the x-www-form-urlencoded method.\n    - `iron` - Encrypts and sign the value using iron.",
                    "enum": [
                        "base64",
                        "base64json",
                        "form",
                        "iron",
                        "none"
                    ],
                    "type": "string"
                },
                "ignoreErrors": {
                    "description": "If `true`, errors are ignored and treated as missing cookies.",
                    "type": "boolean"
                },
                "iron": {
                    "$ref": "#/definitions/SealOptions",
                    "description": "Options for 'iron' encoding."
                },
                "isHttpOnly": {
                    "default": true,
                    "description": "Sets the `HttpOnly` flag.",
                    "type": "boolean"
                },
                "isSameSite": {
                    "default": "'Strict'",
                    "description": "Sets the `SameSite` flag. The value must be one of:\n\n    - `false`  - no flag.\n    - `Strict` - sets the value to `Strict`.\n    - `Lax`    - sets the value to `Lax`.\n    - `None`   - sets the value to `None`.",
                    "enum": [
                        "Lax",
                        "None",
                        "Strict",
                        false
                    ]
                },
                "isSecure": {
                    "default": true,
                    "description": "Sets the `Secure` flag.",
                    "type": "boolean"
                },
                "passThrough": {
                    "description": "Used by proxy plugins (e.g. h2o2)."
                },
                "password": {
                    "description": "Password used for 'iron' encoding (must be at least 32 characters long).",
                    "type": "string"
                },
                "path": {
                    "default": "null (no path)",
                    "description": "The path scope.",
                    "type": [
                        "null",
                        "string"
                    ]
                },
                "sign": {
                    "description": "An object used to calculate an HMAC for cookie integrity validation. This does not provide privacy, only a mean\nto verify that the cookie value was generated by the server. Redundant when 'iron' encoding is used. Options are:\n - integrity -\n - password -",
                    "properties": {
                        "integrity": {
                            "$ref": "#/definitions/SealOptionsSub",
                            "description": "Algorithm options."
                        },
                        "password": {
                            "description": "Password used for HMAC key generation (must be at least 32 characters long).",
                            "type": "string"
                        }
                    },
                    "required": [
                        "password"
                    ],
                    "type": "object"
                },
                "strictHeader": {
                    "default": true,
                    "description": "If `false`, allows any cookie value including values in violation of [RFC 6265](https://tools.ietf.org/html/rfc6265).",
                    "type": "boolean"
                },
                "ttl": {
                    "default": "null (session time-life - cookies are deleted when the browser is closed)",
                    "description": "Time-to-live in milliseconds.",
                    "type": [
                        "null",
                        "number"
                    ]
                }
            },
            "type": "object"
        },
        "ServiceContainer": {
            "properties": {
                "container": {
                    "$ref": "#/definitions/AwilixContainer<any>"
                },
                "defineServices": {
                    "type": "object"
                },
                "getContainer": {
                    "type": "object"
                },
                "services": {
                    "items": {
                        "description": "A class constructor. For example:\n\n   class MyClass {}\n\n   container.registerClass('myClass', MyClass)\n                                      ^^^^^^^",
                        "type": "object"
                    },
                    "type": "array"
                }
            },
            "required": [
                "container",
                "defineServices",
                "getContainer",
                "services"
            ],
            "type": "object"
        },
        "Set<string|Function>": {
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "size": {
                    "type": "number"
                }
            },
            "required": [
                "__@toStringTag@25",
                "size"
            ],
            "type": "object"
        },
        "SharedArrayBuffer": {
            "properties": {
                "__@species@470": {
                    "$ref": "#/definitions/SharedArrayBuffer"
                },
                "__@toStringTag@25": {
                    "const": "SharedArrayBuffer",
                    "type": "string"
                },
                "byteLength": {
                    "type": "number"
                }
            },
            "required": [
                "__@species@470",
                "__@toStringTag@25",
                "byteLength"
            ],
            "type": "object"
        },
        "Socket": {
            "description": "This class is an abstraction of a TCP socket or a streaming `IPC` endpoint\n(uses named pipes on Windows, and Unix domain sockets otherwise). It is also\nan `EventEmitter`.\n\nA `net.Socket` can be created by the user and used directly to interact with\na server. For example, it is returned by {@link createConnection},\nso the user can use it to talk to the server.\n\nIt can also be created by Node.js and passed to the user when a connection\nis received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use\nit to interact with the client.",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
                    "type": "boolean"
                },
                "autoSelectFamilyAttemptedAddresses": {
                    "description": "This property is only present if the family autoselection algorithm is enabled in `socket.connect(options)`\nand it is an array of the addresses that have been attempted.\n\nEach address is a string in the form of `$IP:$PORT`.\nIf the connection was successful, then the last address is the one that the socket is currently connected to.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "bufferSize": {
                    "description": "This property shows the number of characters buffered for writing. The buffer\nmay contain strings whose length after encoding is not yet known. So this number\nis only an approximation of the number of bytes in the buffer.\n\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket. The network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible.\n\nThe consequence of this internal buffering is that memory may grow.\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.",
                    "type": "number"
                },
                "bytesRead": {
                    "description": "The amount of received bytes.",
                    "type": "number"
                },
                "bytesWritten": {
                    "description": "The amount of bytes sent.",
                    "type": "number"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "connecting": {
                    "description": "If `true`, `socket.connect(options[, connectListener])` was\ncalled and has not yet finished. It will stay `true` until the socket becomes\nconnected, then it is set to `false` and the `'connect'` event is emitted. Note\nthat the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "See `writable.destroyed` for further details.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "localAddress": {
                    "description": "The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on `'0.0.0.0'`, if a client\nconnects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.",
                    "type": "string"
                },
                "localFamily": {
                    "description": "The string representation of the local IP family. `'IPv4'` or `'IPv6'`.",
                    "type": "string"
                },
                "localPort": {
                    "description": "The numeric representation of the local port. For example, `80` or `21`.",
                    "type": "number"
                },
                "pending": {
                    "description": "This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting\n(see `socket.connecting`).",
                    "type": "boolean"
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "readyState": {
                    "$ref": "#/definitions/SocketReadyState",
                    "description": "This property represents the state of the connection as a string.\n\n* If the stream is connecting `socket.readyState` is `opening`.\n* If the stream is readable and writable, it is `open`.\n* If the stream is readable and not writable, it is `readOnly`.\n* If the stream is not readable and writable, it is `writeOnly`."
                },
                "remoteAddress": {
                    "description": "The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).",
                    "type": "string"
                },
                "remoteFamily": {
                    "description": "The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).",
                    "type": "string"
                },
                "remotePort": {
                    "description": "The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).",
                    "type": "number"
                },
                "timeout": {
                    "description": "The socket timeout in milliseconds as set by `socket.setTimeout()`.\nIt is `undefined` if a timeout has not been set.",
                    "type": "number"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "allowHalfOpen",
                "autoSelectFamilyAttemptedAddresses",
                "bufferSize",
                "bytesRead",
                "bytesWritten",
                "closed",
                "connecting",
                "destroyed",
                "errored",
                "pending",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode",
                "readyState",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "SocketReadyState": {
            "enum": [
                "closed",
                "open",
                "opening",
                "readOnly",
                "writeOnly"
            ],
            "type": "string"
        },
        "SpannerConnectionCredentialsOptions": {
            "description": "Spanner specific connection credential options.",
            "properties": {
                "databaseId": {
                    "description": "Database host port.",
                    "type": "string"
                },
                "instanceId": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "projectId": {
                    "description": "Database host.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "SpannerConnectionOptions": {
            "description": "Spanner specific connection options.",
            "properties": {
                "acquireTimeout": {
                    "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)\nThis difference between connectTimeout and acquireTimeout is subtle and is described in the mysqljs/mysql docs\nhttps://github.com/mysqljs/mysql/tree/master#pool-options",
                    "type": "number"
                },
                "bigNumberStrings": {
                    "description": "Enabling both supportBigNumbers and bigNumberStrings forces big numbers (BIGINT and DECIMAL columns) to be always\nreturned as JavaScript String objects (Default: false). Enabling supportBigNumbers but leaving bigNumberStrings\ndisabled will return big numbers as String objects only when they cannot be accurately represented with\n[JavaScript Number objects](http://ecma262-5.com/ELS5_HTML.htm#Section_8.5) (which happens when they exceed the [-2^53, +2^53] range),\notherwise they will be returned as Number objects. This option is ignored if supportBigNumbers is disabled.",
                    "type": "boolean"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "charset": {
                    "description": "The charset for the connection. This is called \"collation\" in the SQL-level of MySQL (like utf8_general_ci).\nIf a SQL-level charset is specified (like utf8mb4) then the default collation for that charset is used.\nDefault: 'UTF8_GENERAL_CI'",
                    "type": "string"
                },
                "connectTimeout": {
                    "description": "The milliseconds before a timeout occurs during the initial connection to the MySQL server. (Default: 10000)",
                    "type": "number"
                },
                "database": {
                    "type": "string"
                },
                "databaseId": {
                    "description": "Database host port.",
                    "type": "string"
                },
                "dateStrings": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Force date types (TIMESTAMP, DATETIME, DATE) to be returned as strings rather then inflated into JavaScript Date objects.\nCan be true/false or an array of type names to keep as strings."
                },
                "debug": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Prints protocol details to stdout. Can be true/false or an array of packet type names that should be printed.\n(Default: false)"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"@google-cloud/spanner\")."
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "flags": {
                    "description": "List of connection flags to use other than the default ones. It is also possible to blacklist default ones.\nFor more information, check https://github.com/mysqljs/mysql#connection-flags.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "insecureAuth": {
                    "description": "Allow connecting to MySQL instances that ask for the old (insecure) authentication method. (Default: false)",
                    "type": "boolean"
                },
                "instanceId": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "legacySpatialSupport": {
                    "description": "Use spatial functions like GeomFromText and AsText which are removed in MySQL 8.\n(Default: true)",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "multipleStatements": {
                    "description": "Allow multiple mysql statements per query. Be careful with this, it could increase the scope of SQL injection attacks.\n(Default: false)",
                    "type": "boolean"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "projectId": {
                    "description": "Database host.",
                    "type": "string"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "canRetry": {
                            "description": "If true, PoolCluster will attempt to reconnect when connection fails. (Default: true)",
                            "type": "boolean"
                        },
                        "defaultMode": {
                            "default": "slave",
                            "description": "Default connection pool to use for SELECT queries",
                            "enum": [
                                "master",
                                "slave"
                            ],
                            "type": "string"
                        },
                        "master": {
                            "$ref": "#/definitions/SpannerConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "removeNodeErrorCount": {
                            "description": "If connection fails, node's errorCount increases.\nWhen errorCount is greater than removeNodeErrorCount, remove a node in the PoolCluster. (Default: 5)",
                            "type": "number"
                        },
                        "restoreNodeTimeout": {
                            "description": "If connection fails, specifies the number of milliseconds before another connection attempt will be made.\nIf set to 0, then node will be removed instead and never re-used. (Default: 0)",
                            "type": "number"
                        },
                        "selector": {
                            "description": "Determines how slaves are selected:\nRR: Select one alternately (Round-Robin).\nRANDOM: Select the node by random function.\nORDER: Select the first node available unconditionally.",
                            "enum": [
                                "ORDER",
                                "RANDOM",
                                "RR"
                            ],
                            "type": "string"
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/SpannerConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "schema": {
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "supportBigNumbers": {
                    "description": "When dealing with big numbers (BIGINT and DECIMAL columns) in the database, you should enable this option (Default: false)",
                    "type": "boolean"
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "timezone": {
                    "description": "The timezone configured on the MySQL server.\nThis is used to type cast server date/time values to JavaScript Date object and vice versa.\nThis can be 'local', 'Z', or an offset in the form +HH:MM or -HH:MM. (Default: 'local')",
                    "type": "string"
                },
                "trace": {
                    "description": "Generates stack traces on Error to include call site of library entrance (\"long stack traces\").\nSlight performance penalty for most calls. (Default: true)",
                    "type": "boolean"
                },
                "type": {
                    "const": "spanner",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "SqlServerConnectionCredentialsOptions": {
            "description": "SqlServer specific connection credential options.",
            "properties": {
                "authentication": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/DefaultAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryAccessTokenAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryDefaultAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryMsiAppServiceAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryMsiVmAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryPasswordAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryServicePrincipalSecret"
                        },
                        {
                            "$ref": "#/definitions/NtlmAuthentication"
                        }
                    ],
                    "description": "Authentication settings\nIt overrides username and password, when passed."
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "domain": {
                    "description": "Once you set domain, driver will connect to SQL Server using domain login.",
                    "type": "string"
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "type": "object"
        },
        "SqlServerConnectionOptions": {
            "description": "Microsoft Sql Server specific connection options.",
            "properties": {
                "authentication": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/DefaultAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryAccessTokenAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryDefaultAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryMsiAppServiceAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryMsiVmAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryPasswordAuthentication"
                        },
                        {
                            "$ref": "#/definitions/AzureActiveDirectoryServicePrincipalSecret"
                        },
                        {
                            "$ref": "#/definitions/NtlmAuthentication"
                        }
                    ],
                    "description": "Authentication settings\nIt overrides username and password, when passed."
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "connectionTimeout": {
                    "description": "Connection timeout in ms (default: 15000).",
                    "type": "number"
                },
                "database": {
                    "description": "Database name to connect to.",
                    "type": "string"
                },
                "domain": {
                    "description": "Once you set domain, driver will connect to SQL Server using domain login.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to `require(\"mssql\")`"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "host": {
                    "description": "Database host.",
                    "type": "string"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "options": {
                    "description": "Extra options",
                    "properties": {
                        "abortTransactionOnError": {
                            "description": "A boolean determining whether to rollback a transaction automatically if any error is encountered during\nthe given transaction's execution. This sets the value for SET XACT_ABORT during the initial SQL phase\nof a connection (documentation).",
                            "type": "boolean"
                        },
                        "appName": {
                            "description": "Application name used for identifying a specific application in profiling, logging or tracing tools of SQL Server.\n(default: node-mssql)",
                            "type": "string"
                        },
                        "camelCaseColumns": {
                            "description": "A boolean, controlling whether the column names returned will have the first letter converted to lower case\n(true) or not. This value is ignored if you provide a columnNameReplacer. (default: false).",
                            "type": "boolean"
                        },
                        "cancelTimeout": {
                            "description": "The number of milliseconds before the cancel (abort) of a request is considered failed (default: 5000).",
                            "type": "number"
                        },
                        "connectTimeout": {
                            "description": "The number of milliseconds before the attempt to connect is considered failed (default: 15000).",
                            "type": "number"
                        },
                        "connectionIsolationLevel": {
                            "description": "The default isolation level for new connections. All out-of-transaction queries are executed with this\nsetting. The isolation levels are available from require('tedious').ISOLATION_LEVEL .",
                            "enum": [
                                "READ_COMMITTED",
                                "READ_UNCOMMITTED",
                                "REPEATABLE_READ",
                                "SERIALIZABLE",
                                "SNAPSHOT"
                            ],
                            "type": "string"
                        },
                        "cryptoCredentialsDetails": {
                            "description": "When encryption is used, an object may be supplied that will be used for the first argument when calling\ntls.createSecurePair (default: {})."
                        },
                        "debug": {
                            "description": "Debug options",
                            "properties": {
                                "data": {
                                    "description": "A boolean, controlling whether debug events will be emitted with text describing packet data details\n(default: false).",
                                    "type": "boolean"
                                },
                                "packet": {
                                    "description": "A boolean, controlling whether debug events will be emitted with text describing packet details\n(default: false).",
                                    "type": "boolean"
                                },
                                "payload": {
                                    "description": "A boolean, controlling whether debug events will be emitted with text describing packet payload details\n(default: false).",
                                    "type": "boolean"
                                },
                                "token": {
                                    "description": "A boolean, controlling whether debug events will be emitted with text describing token stream tokens\n(default: false).",
                                    "type": "boolean"
                                }
                            },
                            "type": "object"
                        },
                        "disableAsciiToUnicodeParamConversion": {
                            "description": "A boolean, controlling whether MssqlParameter types char, varchar, and text are converted to their unicode equivalents, nchar, nvarchar, and ntext.\n(default: false, meaning that char/varchar/text parameters will be converted to nchar/nvarchar/ntext)",
                            "type": "boolean"
                        },
                        "disableOutputReturning": {
                            "description": "A boolean, controlling whatever to disable RETURNING / OUTPUT statements.",
                            "type": "boolean"
                        },
                        "enableAnsiNullDefault": {
                            "description": "If true, SET ANSI_NULL_DFLT_ON ON will be set in the initial sql. This means new columns will be nullable by\ndefault. See the T-SQL documentation for more details. (Default: true).",
                            "type": "boolean"
                        },
                        "enableArithAbort": {
                            "description": "A boolean, that when true will abort a query when an overflow or divide-by-zero error occurs during query execution.",
                            "type": "boolean"
                        },
                        "encrypt": {
                            "description": "A boolean determining whether or not the connection will be encrypted. Set to true if you're on\nWindows Azure. (default: true).",
                            "type": "boolean"
                        },
                        "fallbackToDefaultDb": {
                            "description": "By default, if the database requestion by options.database cannot be accessed, the connection will fail with\nan error. However, if options.fallbackToDefaultDb is set to true, then the user's default database will\nbe used instead (Default: false).",
                            "type": "boolean"
                        },
                        "instanceName": {
                            "description": "The named instance to connect to",
                            "type": "string"
                        },
                        "isolation": {
                            "description": "The default isolation level that transactions will be run with. The isolation levels are available\nfrom require('tedious').ISOLATION_LEVEL. (default: READ_COMMITTED).",
                            "enum": [
                                "READ_COMMITTED",
                                "READ_UNCOMMITTED",
                                "REPEATABLE_READ",
                                "SERIALIZABLE",
                                "SNAPSHOT"
                            ],
                            "type": "string"
                        },
                        "localAddress": {
                            "description": "A string indicating which network interface (ip address) to use when connecting to SQL Server.",
                            "type": "string"
                        },
                        "packetSize": {
                            "description": "The size of TDS packets (subject to negotiation with the server). Should be a power of 2. (default: 4096).",
                            "type": "number"
                        },
                        "readOnlyIntent": {
                            "description": "A boolean, determining whether the connection will request read only access from a SQL Server\nAvailability Group. For more information, see here. (default: false).",
                            "type": "boolean"
                        },
                        "rowCollectionOnDone": {
                            "description": "A boolean, that when true will expose received rows in Requests' done* events. See done, doneInProc and\ndoneProc. (default: false)\nCaution: If many row are received, enabling this option could result in excessive memory usage.",
                            "type": "boolean"
                        },
                        "rowCollectionOnRequestCompletion": {
                            "description": "A boolean, that when true will expose received rows in Requests' completion callback. See new Request. (default: false)\nCaution: If many row are received, enabling this option could result in excessive memory usage.",
                            "type": "boolean"
                        },
                        "tdsVersion": {
                            "description": "The version of TDS to use. If server doesn't support specified version, negotiated version is used instead.\nThe versions are available from require('tedious').TDS_VERSION. (default: 7_4).",
                            "type": "string"
                        },
                        "trustServerCertificate": {
                            "description": "A boolean, controlling whether encryption occurs if there is no verifiable server certificate.\n(default: false)",
                            "type": "boolean"
                        },
                        "useColumnNames": {
                            "description": "A boolean determining whether to return rows as arrays or key-value collections. (default: false).",
                            "type": "boolean"
                        },
                        "useUTC": {
                            "description": "A boolean determining whether to pass time values in UTC or local time. (default: false).",
                            "type": "boolean"
                        }
                    },
                    "type": "object"
                },
                "password": {
                    "description": "Database password.",
                    "type": "string"
                },
                "pool": {
                    "description": "An optional object/dictionary with the any of the properties",
                    "properties": {
                        "acquireTimeoutMillis": {
                            "description": "Max milliseconds an acquire call will wait for a resource before timing out. (default no limit), if supplied should non-zero positive integer.",
                            "type": "number"
                        },
                        "errorHandler": {
                            "type": "object"
                        },
                        "evictionRunIntervalMillis": {
                            "description": "How often to run eviction checks. Default: 0 (does not run).",
                            "type": "number"
                        },
                        "fifo": {
                            "description": "If true the oldest resources will be first to be allocated. If false the most recently released resources will\nbe the first to be allocated. This in effect turns the pool's behaviour from a queue into a stack. boolean,\n(default true)",
                            "type": "boolean"
                        },
                        "idleTimeoutMillis": {
                            "description": "The minimum amount of time that an object may sit idle in the pool before it is eligible for eviction due\nto idle time. Supercedes softIdleTimeoutMillis Default: 30000",
                            "type": "number"
                        },
                        "max": {
                            "description": "Maximum number of resources to create at any given time. (default=1)",
                            "type": "number"
                        },
                        "maxWaitingClients": {
                            "description": "Maximum number of queued requests allowed, additional acquire calls will be callback with an err in a future\ncycle of the event loop.",
                            "type": "number"
                        },
                        "min": {
                            "description": "Minimum number of resources to keep in pool at any given time. If this is set >= max, the pool will silently\nset the min to equal max. (default=0)",
                            "type": "number"
                        },
                        "numTestsPerRun": {
                            "description": "Number of resources to check each eviction run. Default: 3.",
                            "type": "number"
                        },
                        "priorityRange": {
                            "description": "Int between 1 and x - if set, borrowers can specify their relative priority in the queue if no resources\nare available. see example. (default 1)",
                            "type": "number"
                        },
                        "softIdleTimeoutMillis": {
                            "description": "Amount of time an object may sit idle in the pool before it is eligible for eviction by the idle object\nevictor (if any), with the extra condition that at least \"min idle\" object instances remain in the pool.\nDefault -1 (nothing can get evicted)",
                            "type": "number"
                        }
                    },
                    "type": "object"
                },
                "port": {
                    "description": "Database host port.",
                    "type": "number"
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "replication": {
                    "description": "Replication setup.",
                    "properties": {
                        "defaultMode": {
                            "default": "slave",
                            "description": "Default connection pool to use for SELECT queries",
                            "enum": [
                                "master",
                                "slave"
                            ],
                            "type": "string"
                        },
                        "master": {
                            "$ref": "#/definitions/SqlServerConnectionCredentialsOptions",
                            "description": "Master server used by orm to perform writes."
                        },
                        "slaves": {
                            "description": "List of read-from severs (slaves).",
                            "items": {
                                "$ref": "#/definitions/SqlServerConnectionCredentialsOptions"
                            },
                            "type": "array"
                        }
                    },
                    "required": [
                        "master",
                        "slaves"
                    ],
                    "type": "object"
                },
                "requestTimeout": {
                    "description": "Request timeout in ms (default: 15000). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.",
                    "type": "number"
                },
                "schema": {
                    "description": "Database schema.",
                    "type": "string"
                },
                "stream": {
                    "description": "Stream recordsets/rows instead of returning them all at once as an argument of callback (default: false).\nYou can also enable streaming for each request independently (request.stream = true).\nAlways set to true if you plan to work with large amount of rows.",
                    "type": "boolean"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "mssql",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "url": {
                    "description": "Connection url where perform connection to.",
                    "type": "string"
                },
                "username": {
                    "description": "Database username.",
                    "type": "string"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "SqliteConnectionOptions": {
            "description": "Sqlite-specific connection options.",
            "properties": {
                "busyErrorRetry": {
                    "description": "In your SQLite application when you perform parallel writes its common to face SQLITE_BUSY error.\nThis error indicates that SQLite failed to write to the database file since someone else already writes into it.\nSince SQLite cannot handle parallel saves this error cannot be avoided.\n\nTo simplify life's of those who have this error this particular option sets a timeout within which ORM will try\nto perform requested write operation again and again until it receives SQLITE_BUSY error.\n\nEnabling WAL can improve your app performance and face less SQLITE_BUSY issues.\nTime in milliseconds.",
                    "type": "number"
                },
                "busyTimeout": {
                    "description": "Query or change the setting of the busy timeout.\nTime in milliseconds.",
                    "type": "number"
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "description": "Storage type or path to the storage.",
                    "type": "string"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"sqlite3\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "enableWAL": {
                    "description": "Enables WAL mode. By default its disabled.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "flags": {
                    "description": "Specifies the open file flags. By default its undefined.",
                    "type": "number"
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "key": {
                    "description": "Encryption key for for SQLCipher.",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "sqlite",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                }
            },
            "required": [
                "database",
                "type"
            ],
            "type": "object"
        },
        "SqljsConnectionOptions": {
            "description": "Sql.js-specific connection options.",
            "properties": {
                "autoSave": {
                    "description": "Enables the autoSave mechanism which either saves to location\nor calls autoSaveCallback every time a change to the database is made.",
                    "type": "boolean"
                },
                "autoSaveCallback": {
                    "$ref": "#/definitions/Function",
                    "description": "A function that gets called on every change instead of the internal autoSave function.\nautoSave has to be enabled for this to work."
                },
                "cache": {
                    "anyOf": [
                        {
                            "properties": {
                                "alwaysEnabled": {
                                    "description": "If set to true then queries (using find methods and QueryBuilder's methods) will always be cached.",
                                    "type": "boolean"
                                },
                                "duration": {
                                    "description": "Time in milliseconds in which cache will expire.\nThis can be setup per-query.\nDefault value is 1000 which is equivalent to 1 second.",
                                    "type": "number"
                                },
                                "ignoreErrors": {
                                    "description": "Used to specify if cache errors should be ignored, and pass through the call to the Database.",
                                    "type": "boolean"
                                },
                                "options": {
                                    "description": "Used to provide redis connection options."
                                },
                                "provider": {
                                    "description": "Factory function for custom cache providers that implement QueryResultCache.",
                                    "type": "object"
                                },
                                "tableName": {
                                    "description": "Configurable table name for \"database\" type cache.\nDefault value is \"query-result-cache\"",
                                    "type": "string"
                                },
                                "type": {
                                    "description": "Type of caching.\n\n- \"database\" means cached values will be stored in the separate table in database. This is default value.\n- \"redis\" means cached values will be stored inside redis. You must provide redis connection options.",
                                    "enum": [
                                        "database",
                                        "ioredis",
                                        "ioredis/cluster",
                                        "redis"
                                    ],
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "description": "Allows to setup cache options."
                },
                "database": {
                    "additionalProperties": false,
                    "description": "A Uint8Array that gets imported when the connection is opened.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@25": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "BYTES_PER_ELEMENT",
                        "__@toStringTag@25",
                        "buffer",
                        "byteLength",
                        "byteOffset",
                        "length"
                    ],
                    "type": "object"
                },
                "driver": {
                    "description": "The driver object\nThis defaults to require(\"sql.js\")"
                },
                "dropSchema": {
                    "description": "Drops the schema each time connection is being established.\nBe careful with this option and don't use this in production - otherwise you'll lose all production data.\nThis option is useful during debug and development.",
                    "type": "boolean"
                },
                "entities": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "$ref": "#/definitions/EntitySchema<any>"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Entities to be loaded for this connection.\nAccepts both entity classes and directories where from entities need to be loaded.\nDirectories support glob patterns."
                },
                "entityPrefix": {
                    "description": "Prefix to use on all tables (collections) of this connection in the database.",
                    "type": "string"
                },
                "entitySkipConstructor": {
                    "description": "When creating new Entity instances, skip all constructors when true.",
                    "type": "boolean"
                },
                "extra": {
                    "description": "Extra connection options to be passed to the underlying driver.\n\ntodo: deprecate this and move all database-specific types into hts own connection options object."
                },
                "isolateWhereStatements": {
                    "description": "Allows automatic isolation of where clauses",
                    "type": "boolean"
                },
                "location": {
                    "description": "File path (Node.js) or local storage key (browser) to load and save database from.\nIf this is specified without autoSave, the database is loaded from the location\nand can be saved manually via the SqljsEntityManager. If autoSave is enabled,\nlocation is used to automatically save the database.",
                    "type": "string"
                },
                "logger": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Logger"
                        },
                        {
                            "enum": [
                                "advanced-console",
                                "debug",
                                "file",
                                "simple-console"
                            ],
                            "type": "string"
                        }
                    ],
                    "description": "Logger instance used to log queries and events in the ORM."
                },
                "logging": {
                    "anyOf": [
                        {
                            "items": {
                                "$ref": "#/definitions/LogLevel"
                            },
                            "type": "array"
                        },
                        {
                            "enum": [
                                "all",
                                false,
                                true
                            ]
                        }
                    ],
                    "description": "Logging options."
                },
                "maxQueryExecutionTime": {
                    "description": "Maximum number of milliseconds query should be executed before logger log a warning.",
                    "type": "number"
                },
                "metadataTableName": {
                    "description": "Typeorm metadata table name, in case of different name from \"typeorm_metadata\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrations": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Migrations to be loaded for this connection.\nAccepts both migration classes and glob patterns representing migration files."
                },
                "migrationsRun": {
                    "description": "Indicates if migrations should be auto run on every application launch.\nAlternative to it, you can use CLI and run migrations:run command.",
                    "type": "boolean"
                },
                "migrationsTableName": {
                    "description": "Migrations table name, in case of different name from \"migrations\".\nAccepts single string name.",
                    "type": "string"
                },
                "migrationsTransactionMode": {
                    "description": "Transaction mode for migrations to run in",
                    "enum": [
                        "all",
                        "each",
                        "none"
                    ],
                    "type": "string"
                },
                "name": {
                    "description": "Connection name. If connection name is not given then it will be called \"default\".\nDifferent connections must have different names.",
                    "type": "string"
                },
                "namingStrategy": {
                    "$ref": "#/definitions/NamingStrategyInterface",
                    "description": "Naming strategy to be used to name tables and columns in the database."
                },
                "relationLoadStrategy": {
                    "description": "Specifies how relations must be loaded - using \"joins\" or separate queries.\nIf you are loading too much data with nested joins it's better to load relations\nusing separate queries.\n\nDefault strategy is \"join\", but this default can be changed here.\nAlso, strategy can be set per-query in FindOptions and QueryBuilder.",
                    "enum": [
                        "join",
                        "query"
                    ],
                    "type": "string"
                },
                "sqlJsConfig": {
                    "description": "Config that's used to initialize sql.js."
                },
                "subscribers": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "$ref": "#/definitions/T"
                            },
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "$ref": "#/definitions/Function"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        }
                    ],
                    "description": "Subscribers to be loaded for this connection.\nAccepts both subscriber classes and directories where from subscribers need to be loaded.\nDirectories support glob patterns."
                },
                "synchronize": {
                    "description": "Indicates if database schema should be auto created on every application launch.\nBe careful with this option and don't use this in production - otherwise you can lose production data.\nThis option is useful during debug and development.\nAlternative to it, you can use CLI and run schema:sync command.\n\nNote that for MongoDB database it does not create schema, because MongoDB is schemaless.\nInstead, it syncs just by creating indices.",
                    "type": "boolean"
                },
                "type": {
                    "const": "sqljs",
                    "description": "Database type.",
                    "type": "string"
                },
                "typename": {
                    "description": "Optionally applied \"typename\" to the model.\nIf set, then each hydrated model will have this property with the target model / entity name inside.\n\n(works like a discriminator property).",
                    "type": "string"
                },
                "useLocalForage": {
                    "description": "Enables the usage of the localforage library to save & load the database asynchronously from the\nindexedDB instead of using the synchron local storage methods in a browser environment.",
                    "type": "boolean"
                }
            },
            "required": [
                "type"
            ],
            "type": "object"
        },
        "SqljsEntityManager": {
            "description": "A special EntityManager that includes import/export and load/save function\nthat are unique to Sql.js.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "callAggregateFun": {},
                "connection": {
                    "$ref": "#/definitions/DataSource",
                    "description": "Connection used by this entity manager."
                },
                "driver": {},
                "plainObjectToEntityTransformer": {
                    "$ref": "#/definitions/PlainObjectToNewEntityTransformer",
                    "description": "Plain to object transformer used in create and merge operations."
                },
                "queryRunner": {
                    "$ref": "#/definitions/QueryRunner",
                    "description": "Custom query runner to be used for operations in this entity manager.\nUsed only in non-global entity manager."
                },
                "repositories": {
                    "$ref": "#/definitions/Map<EntityTarget<any>,Repository<any>>",
                    "description": "Once created and then reused by repositories.\nCreated as a future replacement for the #repositories to provide a bit more perf optimization."
                },
                "treeRepositories": {
                    "description": "Once created and then reused by repositories.",
                    "items": {
                        "$ref": "#/definitions/TreeRepository<any>"
                    },
                    "type": "array"
                }
            },
            "required": [
                "@instanceof",
                "callAggregateFun",
                "connection",
                "driver",
                "plainObjectToEntityTransformer",
                "repositories",
                "treeRepositories"
            ],
            "type": "object"
        },
        "Stream": {
            "type": "object"
        },
        "StringConstructor": {
            "properties": {
                "prototype": {
                    "additionalProperties": false,
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "string"
                        }
                    },
                    "properties": {
                        "length": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "length"
                    ],
                    "type": "object"
                }
            },
            "required": [
                "prototype"
            ],
            "type": "object"
        },
        "StringSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/StringSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/StringSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "SymbolSchema<any>": {
            "properties": {
                "$": {
                    "$ref": "#/definitions/SymbolSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "$_super": {
                    "$ref": "#/definitions/Schema<any>",
                    "description": "Parent schema object."
                },
                "$_terms": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Terms of current schema."
                },
                "_flags": {
                    "$ref": "#/definitions/Record<string,any>",
                    "description": "Flags of current schema."
                },
                "ruleset": {
                    "$ref": "#/definitions/SymbolSchema<any>",
                    "description": "Starts a ruleset in order to apply multiple rule options. The set ends when `rule()`, `keep()`, `message()`, or `warn()` is called."
                },
                "type": {
                    "type": "string"
                }
            },
            "required": [
                "$",
                "$_super",
                "$_terms",
                "_flags",
                "ruleset"
            ],
            "type": "object"
        },
        "T": {
            "type": "object"
        },
        "T_1": {
            "type": "object"
        },
        "Table": {
            "description": "Table in the database represented in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "checks": {
                    "description": "Table check constraints.",
                    "items": {
                        "$ref": "#/definitions/TableCheck"
                    },
                    "type": "array"
                },
                "columns": {
                    "description": "Table columns.",
                    "items": {
                        "$ref": "#/definitions/TableColumn"
                    },
                    "type": "array"
                },
                "comment": {
                    "description": "Table comment. Not supported by all database types.",
                    "type": "string"
                },
                "database": {
                    "description": "Database name that this table resides in if it applies.",
                    "type": "string"
                },
                "engine": {
                    "description": "Table engine.",
                    "type": "string"
                },
                "exclusions": {
                    "description": "Table exclusion constraints.",
                    "items": {
                        "$ref": "#/definitions/TableExclusion"
                    },
                    "type": "array"
                },
                "foreignKeys": {
                    "description": "Table foreign keys.",
                    "items": {
                        "$ref": "#/definitions/TableForeignKey"
                    },
                    "type": "array"
                },
                "indices": {
                    "description": "Table indices.",
                    "items": {
                        "$ref": "#/definitions/TableIndex"
                    },
                    "type": "array"
                },
                "justCreated": {
                    "description": "Indicates if table was just created.\nThis is needed, for example to check if we need to skip primary keys creation\nfor new tables.",
                    "type": "boolean"
                },
                "name": {
                    "description": "May contain database name, schema name and table name, unless they're the current database.\n\nE.g. myDB.mySchema.myTable",
                    "type": "string"
                },
                "primaryColumns": {
                    "items": {
                        "$ref": "#/definitions/TableColumn"
                    },
                    "type": "array"
                },
                "schema": {
                    "description": "Schema name that this table resides in if it applies.",
                    "type": "string"
                },
                "uniques": {
                    "description": "Table unique constraints.",
                    "items": {
                        "$ref": "#/definitions/TableUnique"
                    },
                    "type": "array"
                },
                "withoutRowid": {
                    "description": "Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement",
                    "type": "boolean"
                }
            },
            "required": [
                "@instanceof",
                "checks",
                "columns",
                "exclusions",
                "foreignKeys",
                "indices",
                "justCreated",
                "name",
                "primaryColumns",
                "uniques"
            ],
            "type": "object"
        },
        "TableCheck": {
            "description": "Database's table check constraint stored in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "columnNames": {
                    "description": "Column that contains this constraint.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "expression": {
                    "description": "Check expression.",
                    "type": "string"
                },
                "name": {
                    "description": "Constraint name.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof"
            ],
            "type": "object"
        },
        "TableColumn": {
            "description": "Table's columns in the database represented in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "asExpression": {
                    "description": "Generated column expression.",
                    "type": "string"
                },
                "charset": {
                    "description": "Defines column character set.",
                    "type": "string"
                },
                "collation": {
                    "description": "Defines column collation.",
                    "type": "string"
                },
                "comment": {
                    "description": "Column's comment.",
                    "type": "string"
                },
                "default": {
                    "description": "Column's default value."
                },
                "enum": {
                    "description": "Array of possible enumerated values.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "enumName": {
                    "description": "Exact name of enum",
                    "type": "string"
                },
                "generatedIdentity": {
                    "description": "Identity column type. Supports only in Postgres 10+.",
                    "enum": [
                        "ALWAYS",
                        "BY DEFAULT"
                    ],
                    "type": "string"
                },
                "generatedType": {
                    "description": "Generated column type.",
                    "enum": [
                        "STORED",
                        "VIRTUAL"
                    ],
                    "type": "string"
                },
                "generationStrategy": {
                    "description": "Specifies generation strategy if this column will use auto increment.\n`rowid` option supported only in CockroachDB.",
                    "enum": [
                        "identity",
                        "increment",
                        "rowid",
                        "uuid"
                    ],
                    "type": "string"
                },
                "isArray": {
                    "description": "Indicates if column stores array.",
                    "type": "boolean"
                },
                "isGenerated": {
                    "description": "Indicates if column is auto-generated sequence.",
                    "type": "boolean"
                },
                "isNullable": {
                    "description": "Indicates if column is NULL, or is NOT NULL in the database.",
                    "type": "boolean"
                },
                "isPrimary": {
                    "description": "Indicates if column is a primary key.",
                    "type": "boolean"
                },
                "isUnique": {
                    "description": "Indicates if column has unique value.",
                    "type": "boolean"
                },
                "length": {
                    "description": "Column type's length. Used only on some column types.\nFor example type = \"string\" and length = \"100\" means that ORM will create a column with type varchar(100).",
                    "type": "string"
                },
                "name": {
                    "description": "Column name.",
                    "type": "string"
                },
                "onUpdate": {
                    "description": "ON UPDATE trigger. Works only for MySQL.",
                    "type": "string"
                },
                "precision": {
                    "description": "The precision for a decimal (exact numeric) column (applies only for decimal column), which is the maximum\nnumber of digits that are stored for the values.",
                    "type": [
                        "null",
                        "number"
                    ]
                },
                "primaryKeyConstraintName": {
                    "description": "Name of the primary key constraint for primary column.",
                    "type": "string"
                },
                "scale": {
                    "description": "The scale for a decimal (exact numeric) column (applies only for decimal column), which represents the number\nof digits to the right of the decimal point and must not be greater than precision.",
                    "type": "number"
                },
                "spatialFeatureType": {
                    "description": "Spatial Feature Type (Geometry, Point, Polygon, etc.)",
                    "type": "string"
                },
                "srid": {
                    "description": "SRID (Spatial Reference ID (EPSG code))",
                    "type": "number"
                },
                "type": {
                    "description": "Column type.",
                    "type": "string"
                },
                "unsigned": {
                    "description": "Puts UNSIGNED attribute on to numeric column. Works only for MySQL.",
                    "type": "boolean"
                },
                "width": {
                    "description": "Column type's display width. Used only on some column types in MySQL.\nFor example, INT(4) specifies an INT with a display width of four digits.",
                    "type": "number"
                },
                "zerofill": {
                    "description": "Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\nIf you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column",
                    "type": "boolean"
                }
            },
            "required": [
                "@instanceof",
                "isArray",
                "isGenerated",
                "isNullable",
                "isPrimary",
                "isUnique",
                "length",
                "name",
                "type",
                "unsigned",
                "zerofill"
            ],
            "type": "object"
        },
        "TableExclusion": {
            "description": "Database's table exclusion constraint stored in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "expression": {
                    "description": "Exclusion expression.",
                    "type": "string"
                },
                "name": {
                    "description": "Constraint name.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof"
            ],
            "type": "object"
        },
        "TableForeignKey": {
            "description": "Foreign key from the database stored in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "columnNames": {
                    "description": "Column names which included by this foreign key.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "deferrable": {
                    "description": "Set this foreign key constraint as \"DEFERRABLE\" e.g. check constraints at start\nor at the end of a transaction",
                    "type": "string"
                },
                "name": {
                    "description": "Name of the foreign key constraint.",
                    "type": "string"
                },
                "onDelete": {
                    "description": "\"ON DELETE\" of this foreign key, e.g. what action database should perform when\nreferenced stuff is being deleted.",
                    "type": "string"
                },
                "onUpdate": {
                    "description": "\"ON UPDATE\" of this foreign key, e.g. what action database should perform when\nreferenced stuff is being updated.",
                    "type": "string"
                },
                "referencedColumnNames": {
                    "description": "Column names which included by this foreign key.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "referencedDatabase": {
                    "description": "Database of Table referenced in the foreign key.",
                    "type": "string"
                },
                "referencedSchema": {
                    "description": "Database of Table referenced in the foreign key.",
                    "type": "string"
                },
                "referencedTableName": {
                    "description": "Table referenced in the foreign key.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof",
                "columnNames",
                "referencedColumnNames",
                "referencedTableName"
            ],
            "type": "object"
        },
        "TableIndex": {
            "description": "Database's table index stored in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "columnNames": {
                    "description": "Columns included in this index.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "isConcurrent": {
                    "description": "Create the index using the CONCURRENTLY modifier\nWorks only in postgres.",
                    "type": "boolean"
                },
                "isFulltext": {
                    "description": "The FULLTEXT modifier indexes the entire column and does not allow prefixing.\nWorks only in MySQL.",
                    "type": "boolean"
                },
                "isNullFiltered": {
                    "description": "NULL_FILTERED indexes are particularly useful for indexing sparse columns, where most rows contain a NULL value.\nIn these cases, the NULL_FILTERED index can be considerably smaller and more efficient to maintain than\na normal index that includes NULL values.\n\nWorks only in Spanner.",
                    "type": "boolean"
                },
                "isSpatial": {
                    "description": "The SPATIAL modifier indexes the entire column and does not allow indexed columns to contain NULL values.\nWorks only in MySQL.",
                    "type": "boolean"
                },
                "isUnique": {
                    "description": "Indicates if this index is unique.",
                    "type": "boolean"
                },
                "name": {
                    "description": "Index name.",
                    "type": "string"
                },
                "parser": {
                    "description": "Fulltext parser.\nWorks only in MySQL.",
                    "type": "string"
                },
                "where": {
                    "description": "Index filter condition.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof",
                "columnNames",
                "isConcurrent",
                "isFulltext",
                "isNullFiltered",
                "isSpatial",
                "isUnique",
                "where"
            ],
            "type": "object"
        },
        "TableMetadataArgs": {
            "description": "Arguments for TableMetadata class, helps to construct an TableMetadata object.",
            "properties": {
                "comment": {
                    "description": "Table comment. Not supported by all database types.",
                    "type": "string"
                },
                "database": {
                    "description": "Database name. Used in MySql and Sql Server.",
                    "type": "string"
                },
                "dependsOn": {
                    "$ref": "#/definitions/Set<string|Function>",
                    "description": "View dependencies."
                },
                "engine": {
                    "description": "Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).",
                    "type": "string"
                },
                "expression": {
                    "description": "View expression.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "materialized": {
                    "description": "Indicates if view is materialized",
                    "type": "boolean"
                },
                "name": {
                    "description": "Table's name. If name is not set then table's name will be generated from target's name.",
                    "type": "string"
                },
                "orderBy": {
                    "anyOf": [
                        {
                            "additionalProperties": {
                                "anyOf": [
                                    {
                                        "properties": {
                                            "nulls": {
                                                "enum": [
                                                    "NULLS FIRST",
                                                    "NULLS LAST"
                                                ],
                                                "type": "string"
                                            },
                                            "order": {
                                                "enum": [
                                                    "ASC",
                                                    "DESC"
                                                ],
                                                "type": "string"
                                            }
                                        },
                                        "required": [
                                            "order"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "enum": [
                                            "ASC",
                                            "DESC"
                                        ],
                                        "type": "string"
                                    }
                                ]
                            },
                            "description": "Special object that defines order condition for ORDER BY in sql.\n\nExample:\n{\n \"name\": \"ASC\",\n \"id\": \"DESC\"\n}",
                            "type": "object"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "Specifies a default order by used for queries from this table when no explicit order by is specified."
                },
                "schema": {
                    "description": "Schema name. Used in Postgres and Sql Server.",
                    "type": "string"
                },
                "synchronize": {
                    "description": "Indicates if schema synchronization is enabled or disabled for this entity.\nIf it will be set to false then schema sync will and migrations ignore this entity.\nBy default schema synchronization is enabled for all entities.",
                    "type": "boolean"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Class to which table is applied.\nFunction target is a table defined in the class.\nString target is a table defined in a json schema."
                },
                "type": {
                    "$ref": "#/definitions/TableType",
                    "description": "Table type. Tables can be abstract, closure, junction, embedded, etc."
                },
                "withoutRowid": {
                    "description": "If set to 'true' this option disables Sqlite's default behaviour of secretly creating\nan integer primary key column named 'rowid' on table creation.",
                    "type": "boolean"
                }
            },
            "required": [
                "target",
                "type"
            ],
            "type": "object"
        },
        "TableType": {
            "description": "Table type. Tables can be closure, junction,, etc.",
            "enum": [
                "closure",
                "closure-junction",
                "entity-child",
                "junction",
                "regular",
                "view"
            ],
            "type": "string"
        },
        "TableUnique": {
            "description": "Database's table unique constraint stored in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "columnNames": {
                    "description": "Columns that contains this constraint.",
                    "items": {
                        "type": "string"
                    },
                    "type": "array"
                },
                "deferrable": {
                    "description": "Set this foreign key constraint as \"DEFERRABLE\" e.g. check constraints at start\nor at the end of a transaction",
                    "type": "string"
                },
                "name": {
                    "description": "Constraint name.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof",
                "columnNames"
            ],
            "type": "object"
        },
        "TlsOptions": {
            "properties": {
                "ALPNCallback": {
                    "description": "If set, this will be called when a client opens a connection using the ALPN extension.\nOne argument will be passed to the callback: an object containing `servername` and `protocols` fields,\nrespectively containing the server name from the SNI extension (if any) and an array of\nALPN protocol name strings. The callback must return either one of the strings listed in `protocols`,\nwhich will be returned to the client as the selected ALPN protocol, or `undefined`,\nto reject the connection with a fatal alert. If a string is returned that does not match one of\nthe client's ALPN protocols, an error will be thrown.\nThis option cannot be used with the `ALPNProtocols` option, and setting both options will throw an error.",
                    "type": "object"
                },
                "ALPNProtocols": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "additionalProperties": false,
                                "patternProperties": {
                                    "^[0-9]+$": {
                                        "type": "number"
                                    }
                                },
                                "properties": {
                                    "BYTES_PER_ELEMENT": {
                                        "type": "number"
                                    },
                                    "__@toStringTag@25": {
                                        "const": "Uint8Array",
                                        "type": "string"
                                    },
                                    "buffer": {
                                        "$ref": "#/definitions/ArrayBufferLike"
                                    },
                                    "byteLength": {
                                        "type": "number"
                                    },
                                    "byteOffset": {
                                        "type": "number"
                                    },
                                    "length": {
                                        "type": "number"
                                    }
                                },
                                "required": [
                                    "BYTES_PER_ELEMENT",
                                    "__@toStringTag@25",
                                    "buffer",
                                    "byteLength",
                                    "byteOffset",
                                    "length"
                                ],
                                "type": "object"
                            },
                            "type": "array"
                        }
                    ],
                    "description": "An array of strings or a Buffer naming possible ALPN protocols.\n(Protocols should be ordered by their priority.)"
                },
                "SNICallback": {
                    "description": "SNICallback(servername, cb) <Function> A function that will be\ncalled if the client supports SNI TLS extension. Two arguments\nwill be passed when called: servername and cb. SNICallback should\ninvoke cb(null, ctx), where ctx is a SecureContext instance.\n(tls.createSecureContext(...) can be used to get a proper\nSecureContext.) If SNICallback wasn't provided the default callback\nwith high-level API will be used (see below).",
                    "type": "object"
                },
                "allowHalfOpen": {
                    "default": false,
                    "description": "Indicates whether half-opened TCP connections are allowed.",
                    "type": "boolean"
                },
                "allowPartialTrustChain": {
                    "description": "Treat intermediate (non-self-signed)\ncertificates in the trust CA certificate list as trusted.",
                    "type": "boolean"
                },
                "ca": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Optionally override the trusted CA certificates. Default is to trust\nthe well-known CAs curated by Mozilla. Mozilla's CAs are completely\nreplaced when CAs are explicitly specified using this option."
                },
                "cert": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Cert chains in PEM format. One cert chain should be provided per\nprivate key. Each cert chain should consist of the PEM formatted\ncertificate for a provided private key, followed by the PEM\nformatted intermediate certificates (if any), in order, and not\nincluding the root CA (the root CA must be pre-known to the peer,\nsee ca). When providing multiple cert chains, they do not have to\nbe in the same order as their private keys in key. If the\nintermediate certificates are not provided, the peer will not be\nable to validate the certificate, and the handshake will fail."
                },
                "ciphers": {
                    "description": "Cipher suite specification, replacing the default. For more\ninformation, see modifying the default cipher suite. Permitted\nciphers can be obtained via tls.getCiphers(). Cipher names must be\nuppercased in order for OpenSSL to accept them.",
                    "type": "string"
                },
                "clientCertEngine": {
                    "description": "Name of an OpenSSL engine which can provide the client certificate.",
                    "type": "string"
                },
                "crl": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PEM formatted CRLs (Certificate Revocation Lists)."
                },
                "dhparam": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "`'auto'` or custom Diffie-Hellman parameters, required for non-ECDHE perfect forward secrecy.\nIf omitted or invalid, the parameters are silently discarded and DHE ciphers will not be available.\nECDHE-based perfect forward secrecy will still be available."
                },
                "ecdhCurve": {
                    "description": "A string describing a named curve or a colon separated list of curve\nNIDs or names, for example P-521:P-384:P-256, to use for ECDH key\nagreement. Set to auto to select the curve automatically. Use\ncrypto.getCurves() to obtain a list of available curve names. On\nrecent releases, openssl ecparam -list_curves will also display the\nname and description of each available elliptic curve. Default:\ntls.DEFAULT_ECDH_CURVE.",
                    "type": "string"
                },
                "enableTrace": {
                    "default": false,
                    "description": "When enabled, TLS packet trace information is written to `stderr`. This can be\nused to debug TLS connection problems.",
                    "type": "boolean"
                },
                "handshakeTimeout": {
                    "description": "Abort the connection if the SSL/TLS handshake does not finish in the\nspecified number of milliseconds. A 'tlsClientError' is emitted on\nthe tls.Server object whenever a handshake times out. Default:\n120000 (120 seconds).",
                    "type": "number"
                },
                "highWaterMark": {
                    "default": "See [stream.getDefaultHighWaterMark()](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamgetdefaulthighwatermarkobjectmode).",
                    "description": "Optionally overrides all `net.Socket`s' `readableHighWaterMark` and `writableHighWaterMark`.",
                    "type": "number"
                },
                "honorCipherOrder": {
                    "description": "Attempt to use the server's cipher suite preferences instead of the\nclient's. When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be\nset in secureOptions",
                    "type": "boolean"
                },
                "keepAlive": {
                    "default": false,
                    "description": "If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,\nsimilarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.",
                    "type": "boolean"
                },
                "keepAliveInitialDelay": {
                    "default": 0,
                    "description": "If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.",
                    "type": "number"
                },
                "key": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/KeyObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Private keys in PEM format. PEM allows the option of private keys\nbeing encrypted. Encrypted keys will be decrypted with\noptions.passphrase. Multiple keys using different algorithms can be\nprovided either as an array of unencrypted key strings or buffers,\nor an array of objects in the form {pem: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted keys will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "maxVersion": {
                    "description": "Optionally set the maximum TLS version to allow. One\nof `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n`secureProtocol` option, use one or the other.\n**Default:** `'TLSv1.3'`, unless changed using CLI options. Using\n`--tls-max-v1.2` sets the default to `'TLSv1.2'`. Using `--tls-max-v1.3` sets the default to\n`'TLSv1.3'`. If multiple of the options are provided, the highest maximum is used.",
                    "enum": [
                        "TLSv1",
                        "TLSv1.1",
                        "TLSv1.2",
                        "TLSv1.3"
                    ],
                    "type": "string"
                },
                "minVersion": {
                    "description": "Optionally set the minimum TLS version to allow. One\nof `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, or `'TLSv1'`. Cannot be specified along with the\n`secureProtocol` option, use one or the other.  It is not recommended to use\nless than TLSv1.2, but it may be required for interoperability.\n**Default:** `'TLSv1.2'`, unless changed using CLI options. Using\n`--tls-v1.0` sets the default to `'TLSv1'`. Using `--tls-v1.1` sets the default to\n`'TLSv1.1'`. Using `--tls-min-v1.3` sets the default to\n'TLSv1.3'. If multiple of the options are provided, the lowest minimum is used.",
                    "enum": [
                        "TLSv1",
                        "TLSv1.1",
                        "TLSv1.2",
                        "TLSv1.3"
                    ],
                    "type": "string"
                },
                "noDelay": {
                    "default": false,
                    "description": "If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.",
                    "type": "boolean"
                },
                "passphrase": {
                    "description": "Shared passphrase used for a single private key and/or a PFX.",
                    "type": "string"
                },
                "pauseOnConnect": {
                    "default": false,
                    "description": "Indicates whether the socket should be paused on incoming connections.",
                    "type": "boolean"
                },
                "pfx": {
                    "anyOf": [
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "items": {
                                "anyOf": [
                                    {
                                        "additionalProperties": false,
                                        "patternProperties": {
                                            "^[0-9]+$": {
                                                "type": "number"
                                            }
                                        },
                                        "properties": {
                                            "BYTES_PER_ELEMENT": {
                                                "type": "number"
                                            },
                                            "__@toStringTag@25": {
                                                "const": "Uint8Array",
                                                "type": "string"
                                            },
                                            "buffer": {
                                                "$ref": "#/definitions/ArrayBufferLike"
                                            },
                                            "byteLength": {
                                                "type": "number"
                                            },
                                            "byteOffset": {
                                                "type": "number"
                                            },
                                            "length": {
                                                "type": "number"
                                            }
                                        },
                                        "required": [
                                            "BYTES_PER_ELEMENT",
                                            "__@toStringTag@25",
                                            "buffer",
                                            "byteLength",
                                            "byteOffset",
                                            "length"
                                        ],
                                        "type": "object"
                                    },
                                    {
                                        "$ref": "#/definitions/PxfObject"
                                    },
                                    {
                                        "type": "string"
                                    }
                                ]
                            },
                            "type": "array"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "PFX or PKCS12 encoded private key and certificate chain. pfx is an\nalternative to providing key and cert individually. PFX is usually\nencrypted, if it is, passphrase will be used to decrypt it. Multiple\nPFX can be provided either as an array of unencrypted PFX buffers,\nor an array of objects in the form {buf: <string|buffer>[,\npassphrase: <string>]}. The object form can only occur in an array.\nobject.passphrase is optional. Encrypted PFX will be decrypted with\nobject.passphrase if provided, or options.passphrase if it is not."
                },
                "privateKeyEngine": {
                    "description": "Name of an OpenSSL engine to get private key from. Should be used\ntogether with privateKeyIdentifier.",
                    "type": "string"
                },
                "privateKeyIdentifier": {
                    "description": "Identifier of a private key managed by an OpenSSL engine. Should be\nused together with privateKeyEngine. Should not be set together with\nkey, because both options define a private key in different ways.",
                    "type": "string"
                },
                "pskIdentityHint": {
                    "description": "hint to send to a client to help\nwith selecting the identity during TLS-PSK negotiation. Will be ignored\nin TLS 1.3. Upon failing to set pskIdentityHint `tlsClientError` will be\nemitted with `ERR_TLS_PSK_SET_IDENTIY_HINT_FAILED` code.",
                    "type": "string"
                },
                "rejectUnauthorized": {
                    "default": true,
                    "description": "If true the server will reject any connection which is not\nauthorized with the list of supplied CAs. This option only has an\neffect if requestCert is true.",
                    "type": "boolean"
                },
                "requestCert": {
                    "description": "If true the server will request a certificate from clients that\nconnect and attempt to verify that certificate. Defaults to\nfalse.",
                    "type": "boolean"
                },
                "secureContext": {
                    "$ref": "#/definitions/SecureContext",
                    "description": "An optional TLS context object from tls.createSecureContext()"
                },
                "secureOptions": {
                    "description": "Optionally affect the OpenSSL protocol behavior, which is not\nusually necessary. This should be used carefully if at all! Value is\na numeric bitmask of the SSL_OP_* options from OpenSSL Options",
                    "type": "number"
                },
                "secureProtocol": {
                    "description": "Legacy mechanism to select the TLS protocol version to use, it does\nnot support independent control of the minimum and maximum version,\nand does not support limiting the protocol to TLSv1.3. Use\nminVersion and maxVersion instead. The possible values are listed as\nSSL_METHODS, use the function names as strings. For example, use\n'TLSv1_1_method' to force TLS version 1.1, or 'TLS_method' to allow\nany TLS protocol version up to TLSv1.3. It is not recommended to use\nTLS versions less than 1.2, but it may be required for\ninteroperability. Default: none, see minVersion.",
                    "type": "string"
                },
                "sessionIdContext": {
                    "description": "Opaque identifier used by servers to ensure session state is not\nshared between applications. Unused by clients.",
                    "type": "string"
                },
                "sessionTimeout": {
                    "description": "The number of seconds after which a TLS session created by the\nserver will no longer be resumable. See Session Resumption for more\ninformation. Default: 300.",
                    "type": "number"
                },
                "sigalgs": {
                    "description": "Colon-separated list of supported signature algorithms. The list\ncan contain digest algorithms (SHA256, MD5 etc.), public key\nalgorithms (RSA-PSS, ECDSA etc.), combination of both (e.g\n'RSA+SHA384') or TLS v1.3 scheme names (e.g. rsa_pss_pss_sha512).",
                    "type": "string"
                },
                "ticketKeys": {
                    "additionalProperties": false,
                    "description": "48-bytes of cryptographically strong pseudo-random data.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "number"
                        }
                    },
                    "properties": {
                        "BYTES_PER_ELEMENT": {
                            "type": "number"
                        },
                        "__@toStringTag@25": {
                            "const": "Uint8Array",
                            "type": "string"
                        },
                        "buffer": {
                            "$ref": "#/definitions/ArrayBufferLike"
                        },
                        "byteLength": {
                            "type": "number"
                        },
                        "byteOffset": {
                            "type": "number"
                        },
                        "length": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "BYTES_PER_ELEMENT",
                        "__@toStringTag@25",
                        "buffer",
                        "byteLength",
                        "byteOffset",
                        "length"
                    ],
                    "type": "object"
                }
            },
            "type": "object"
        },
        "Transform": {
            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "allowHalfOpen": {
                    "description": "If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `true`.\n\nThis can be changed manually to change the half-open behavior of an existing\n`Duplex` stream instance, but must be changed before the `'end'` event is emitted.",
                    "type": "boolean"
                },
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `readable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "readable": {
                    "description": "Is `true` if it is safe to call {@link read}, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.",
                    "type": "boolean"
                },
                "readableAborted": {
                    "description": "Returns whether the stream was destroyed or errored before emitting `'end'`.",
                    "type": "boolean"
                },
                "readableDidRead": {
                    "description": "Returns whether `'data'` has been emitted.",
                    "type": "boolean"
                },
                "readableEncoding": {
                    "anyOf": [
                        {
                            "enum": [
                                "ascii",
                                "base64",
                                "base64url",
                                "binary",
                                "hex",
                                "latin1",
                                "ucs-2",
                                "ucs2",
                                "utf-16le",
                                "utf-8",
                                "utf16le",
                                "utf8"
                            ],
                            "type": "string"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Getter for the property `encoding` of a given `Readable` stream. The `encoding` property can be set using the {@link setEncoding} method."
                },
                "readableEnded": {
                    "description": "Becomes `true` when [`'end'`](https://nodejs.org/docs/latest-v22.x/api/stream.html#event-end) event is emitted.",
                    "type": "boolean"
                },
                "readableFlowing": {
                    "description": "This property reflects the current state of a `Readable` stream as described\nin the [Three states](https://nodejs.org/docs/latest-v22.x/api/stream.html#three-states) section.",
                    "type": [
                        "null",
                        "boolean"
                    ]
                },
                "readableHighWaterMark": {
                    "description": "Returns the value of `highWaterMark` passed when creating this `Readable`.",
                    "type": "number"
                },
                "readableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "readableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Readable` stream.",
                    "type": "boolean"
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "allowHalfOpen",
                "closed",
                "destroyed",
                "errored",
                "readable",
                "readableAborted",
                "readableDidRead",
                "readableEncoding",
                "readableEnded",
                "readableFlowing",
                "readableHighWaterMark",
                "readableLength",
                "readableObjectMode",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "TreeRepository<any>": {
            "description": "Repository with additional functions to work with trees.",
            "properties": {
                "manager": {
                    "$ref": "#/definitions/EntityManager",
                    "description": "Entity Manager used by this repository."
                },
                "metadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the entity current repository manages."
                },
                "queryRunner": {
                    "$ref": "#/definitions/QueryRunner",
                    "description": "Query runner provider used for this repository."
                },
                "target": {
                    "$ref": "#/definitions/EntityTarget<any>",
                    "description": "Entity target that is managed by this repository.\nIf this repository manages entity from schema,\nthen it returns a name of that schema instead."
                }
            },
            "required": [
                "manager",
                "metadata",
                "target"
            ],
            "type": "object"
        },
        "UniqueMetadata": {
            "description": "Unique metadata contains all information about table's unique constraints.",
            "properties": {
                "columnNamesWithOrderingMap": {
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "Map of column names with order set.\nUsed only by MongoDB driver.",
                    "type": "object"
                },
                "columns": {
                    "description": "Unique columns.",
                    "items": {
                        "$ref": "#/definitions/ColumnMetadata"
                    },
                    "type": "array"
                },
                "deferrable": {
                    "description": "Indicate if unique constraints can be deferred.",
                    "enum": [
                        "INITIALLY DEFERRED",
                        "INITIALLY IMMEDIATE"
                    ],
                    "type": "string"
                },
                "embeddedMetadata": {
                    "$ref": "#/definitions/EmbeddedMetadata",
                    "description": "Embedded metadata if this unique was applied on embedded."
                },
                "entityMetadata": {
                    "$ref": "#/definitions/EntityMetadata",
                    "description": "Entity metadata of the class to which this unique constraint is applied."
                },
                "givenColumnNames": {
                    "anyOf": [
                        {
                            "items": {
                                "type": "string"
                            },
                            "type": "array"
                        },
                        {
                            "type": "object"
                        }
                    ],
                    "description": "User specified column names."
                },
                "givenName": {
                    "description": "User specified unique constraint name.",
                    "type": "string"
                },
                "name": {
                    "description": "Final unique constraint name.\nIf unique constraint name was given by a user then it stores normalized (by naming strategy) givenName.\nIf unique constraint name was not given then its generated.",
                    "type": "string"
                },
                "target": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Function"
                        },
                        {
                            "type": "string"
                        }
                    ],
                    "description": "Target class to which metadata is applied."
                }
            },
            "required": [
                "columnNamesWithOrderingMap",
                "columns",
                "entityMetadata",
                "name"
            ],
            "type": "object"
        },
        "UpsertType": {
            "enum": [
                "on-conflict-do-update",
                "on-duplicate-key-update",
                "primary-key"
            ],
            "type": "string"
        },
        "ValidationOptions": {
            "properties": {
                "abortEarly": {
                    "default": true,
                    "description": "when true, stops validation on the first error, otherwise returns all the errors found.",
                    "type": "boolean"
                },
                "allowUnknown": {
                    "default": false,
                    "description": "when true, allows object to contain unknown keys which are ignored.",
                    "type": "boolean"
                },
                "artifacts": {
                    "default": false,
                    "description": "when true, return artifacts alongside the value.",
                    "type": "boolean"
                },
                "cache": {
                    "default": false,
                    "description": "when true, schema caching is enabled (for schemas with explicit caching rules).",
                    "type": "boolean"
                },
                "context": {
                    "$ref": "#/definitions/Context",
                    "description": "provides an external data set to be used in references"
                },
                "convert": {
                    "default": true,
                    "description": "when true, attempts to cast values to the required types (e.g. a string to a number).",
                    "type": "boolean"
                },
                "dateFormat": {
                    "default": "'iso'",
                    "description": "sets the string format used when converting dates to strings in error messages and casting.",
                    "enum": [
                        "date",
                        "iso",
                        "string",
                        "time",
                        "utc"
                    ],
                    "type": "string"
                },
                "debug": {
                    "default": false,
                    "description": "when true, valid results and throw errors are decorated with a debug property which includes an array of the validation steps used to generate the returned result.",
                    "type": "boolean"
                },
                "errors": {
                    "$ref": "#/definitions/ErrorFormattingOptions",
                    "description": "error formatting settings."
                },
                "externals": {
                    "default": true,
                    "description": "if false, the external rules set with `any.external()` are ignored, which is required to ignore any external validations in synchronous mode (or an exception is thrown).",
                    "type": "boolean"
                },
                "messages": {
                    "$ref": "#/definitions/LanguageMessages",
                    "default": {},
                    "description": "overrides individual error messages. Defaults to no override (`{}`).\nMessages use the same rules as templates.\nVariables in double braces `{{var}}` are HTML escaped if the option `errors.escapeHtml` is set to true."
                },
                "noDefaults": {
                    "default": false,
                    "description": "when true, do not apply default values.",
                    "type": "boolean"
                },
                "nonEnumerables": {
                    "default": false,
                    "description": "when true, inputs are shallow cloned to include non-enumerable properties.",
                    "type": "boolean"
                },
                "presence": {
                    "default": "'optional'",
                    "description": "sets the default presence requirements. Supported modes: 'optional', 'required', and 'forbidden'.",
                    "enum": [
                        "forbidden",
                        "optional",
                        "required"
                    ],
                    "type": "string"
                },
                "skipFunctions": {
                    "default": false,
                    "description": "when true, ignores unknown keys with a function value.",
                    "type": "boolean"
                },
                "stripUnknown": {
                    "anyOf": [
                        {
                            "properties": {
                                "arrays": {
                                    "type": "boolean"
                                },
                                "objects": {
                                    "type": "boolean"
                                }
                            },
                            "type": "object"
                        },
                        {
                            "type": "boolean"
                        }
                    ],
                    "default": false,
                    "description": "remove unknown elements from objects and arrays.\n- when true, all unknown elements will be removed\n- when an object:\n     - objects - set to true to remove unknown keys from objects"
                }
            },
            "type": "object"
        },
        "ValueTransformer": {
            "description": "Interface for objects that deal with (un)marshalling data.",
            "type": "object"
        },
        "View": {
            "description": "View in the database represented in this class.",
            "properties": {
                "@instanceof": {
                    "type": "object"
                },
                "database": {
                    "description": "Database name that this view resides in if it applies.",
                    "type": "string"
                },
                "expression": {
                    "description": "View definition.",
                    "type": [
                        "string",
                        "object"
                    ]
                },
                "indices": {
                    "description": "View Indices",
                    "items": {
                        "$ref": "#/definitions/TableIndex"
                    },
                    "type": "array"
                },
                "materialized": {
                    "description": "Indicates if view is materialized.",
                    "type": "boolean"
                },
                "name": {
                    "description": "View name",
                    "type": "string"
                },
                "schema": {
                    "description": "Schema name that this view resides in if it applies.",
                    "type": "string"
                }
            },
            "required": [
                "@instanceof",
                "expression",
                "indices",
                "materialized",
                "name"
            ],
            "type": "object"
        },
        "Writable": {
            "properties": {
                "closed": {
                    "description": "Is `true` after `'close'` has been emitted.",
                    "type": "boolean"
                },
                "destroyed": {
                    "description": "Is `true` after `writable.destroy()` has been called.",
                    "type": "boolean"
                },
                "errored": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/Error"
                        },
                        {
                            "type": "null"
                        }
                    ],
                    "description": "Returns error if the stream has been destroyed with an error."
                },
                "writable": {
                    "description": "Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored, or ended.",
                    "type": "boolean"
                },
                "writableCorked": {
                    "description": "Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.",
                    "type": "number"
                },
                "writableEnded": {
                    "description": "Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.",
                    "type": "boolean"
                },
                "writableFinished": {
                    "description": "Is set to `true` immediately before the `'finish'` event is emitted.",
                    "type": "boolean"
                },
                "writableHighWaterMark": {
                    "description": "Return the value of `highWaterMark` passed when creating this `Writable`.",
                    "type": "number"
                },
                "writableLength": {
                    "description": "This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.",
                    "type": "number"
                },
                "writableNeedDrain": {
                    "description": "Is `true` if the stream's buffer has been full and stream will emit `'drain'`.",
                    "type": "boolean"
                },
                "writableObjectMode": {
                    "description": "Getter for the property `objectMode` of a given `Writable` stream.",
                    "type": "boolean"
                }
            },
            "required": [
                "closed",
                "destroyed",
                "errored",
                "writable",
                "writableCorked",
                "writableEnded",
                "writableFinished",
                "writableHighWaterMark",
                "writableLength",
                "writableNeedDrain",
                "writableObjectMode"
            ],
            "type": "object"
        },
        "WriteConcern": {
            "description": "A MongoDB WriteConcern, which describes the level of acknowledgement\nrequested from MongoDB for write operations.",
            "properties": {
                "fsync": {
                    "description": "equivalent to the j option",
                    "enum": [
                        1,
                        false,
                        true
                    ]
                },
                "j": {
                    "description": "request acknowledgment that the write operation has been written to the on-disk journal",
                    "type": "boolean"
                },
                "w": {
                    "anyOf": [
                        {
                            "const": "majority",
                            "type": "string"
                        },
                        {
                            "type": "number"
                        }
                    ],
                    "description": "request acknowledgment that the write operation has propagated to a specified number of mongod instances or to mongod instances with specified tags."
                },
                "wtimeout": {
                    "description": "specify a time limit to prevent write operations from blocking indefinitely",
                    "type": "number"
                }
            },
            "type": "object"
        },
        "ZlibOptions": {
            "properties": {
                "chunkSize": {
                    "default": "16*1024",
                    "type": "number"
                },
                "dictionary": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/ArrayBuffer"
                        },
                        {
                            "$ref": "#/definitions/DataView"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Int8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint8ClampedArray",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Int16Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint16Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Int32Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Uint32Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Float32Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "Float64Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "additionalProperties": false,
                                    "properties": {},
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "BigInt64Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        },
                        {
                            "additionalProperties": false,
                            "patternProperties": {
                                "^[0-9]+$": {
                                    "additionalProperties": false,
                                    "properties": {},
                                    "type": "number"
                                }
                            },
                            "properties": {
                                "BYTES_PER_ELEMENT": {
                                    "type": "number"
                                },
                                "__@toStringTag@25": {
                                    "const": "BigUint64Array",
                                    "type": "string"
                                },
                                "buffer": {
                                    "$ref": "#/definitions/ArrayBufferLike"
                                },
                                "byteLength": {
                                    "type": "number"
                                },
                                "byteOffset": {
                                    "type": "number"
                                },
                                "length": {
                                    "type": "number"
                                }
                            },
                            "required": [
                                "BYTES_PER_ELEMENT",
                                "__@toStringTag@25",
                                "buffer",
                                "byteLength",
                                "byteOffset",
                                "length"
                            ],
                            "type": "object"
                        }
                    ]
                },
                "finishFlush": {
                    "default": "constants.Z_FINISH",
                    "type": "number"
                },
                "flush": {
                    "default": "constants.Z_NO_FLUSH",
                    "type": "number"
                },
                "info": {
                    "description": "If `true`, returns an object with `buffer` and `engine`.",
                    "type": "boolean"
                },
                "level": {
                    "type": "number"
                },
                "maxOutputLength": {
                    "default": "buffer.kMaxLength",
                    "description": "Limits output size when using convenience methods.",
                    "type": "number"
                },
                "memLevel": {
                    "type": "number"
                },
                "strategy": {
                    "type": "number"
                },
                "windowBits": {
                    "type": "number"
                }
            },
            "type": "object"
        },
        "default.BaseLogger": {
            "properties": {
                "debug": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'debug'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                },
                "error": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'error'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                },
                "fatal": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'fatal'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                },
                "info": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'info'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                },
                "level": {
                    "$ref": "#/definitions/default.LevelWithSilentOrString",
                    "description": "Set this property to the desired logging level. In order of priority, available levels are:\n\n- 'fatal'\n- 'error'\n- 'warn'\n- 'info'\n- 'debug'\n- 'trace'\n\nThe logging level is a __minimum__ level. For instance if `logger.level` is `'info'` then all `'fatal'`, `'error'`, `'warn'`,\nand `'info'` logs will be enabled.\n\nYou can pass `'silent'` to disable logging."
                },
                "silent": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Noop function."
                },
                "trace": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'trace'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                },
                "warn": {
                    "$ref": "#/definitions/default.LogFn",
                    "description": "Log at `'warn'` level the given msg. If the first argument is an object, all its properties will be included in the JSON line.\nIf more args follows `msg`, these will be used to format `msg` using `util.format`."
                }
            },
            "required": [
                "debug",
                "error",
                "fatal",
                "info",
                "level",
                "silent",
                "trace",
                "warn"
            ],
            "type": "object"
        },
        "default.LevelMapping": {
            "properties": {
                "labels": {
                    "additionalProperties": false,
                    "description": "Returns the mappings of level internal level numbers to their string representations.",
                    "patternProperties": {
                        "^[0-9]+$": {
                            "type": "string"
                        }
                    },
                    "type": "object"
                },
                "values": {
                    "additionalProperties": {
                        "type": "number"
                    },
                    "description": "Returns the mappings of level names to their respective internal number representation.",
                    "type": "object"
                }
            },
            "required": [
                "labels",
                "values"
            ],
            "type": "object"
        },
        "default.LevelWithSilentOrString": {
            "anyOf": [
                {
                    "allOf": [
                        {
                            "properties": {},
                            "type": "object"
                        },
                        {
                            "type": "string"
                        }
                    ]
                },
                {
                    "enum": [
                        "debug",
                        "error",
                        "fatal",
                        "info",
                        "silent",
                        "trace",
                        "warn"
                    ],
                    "type": "string"
                }
            ]
        },
        "default.LogFn": {
            "type": "object"
        },
        "global.NodeJS.Platform": {
            "enum": [
                "aix",
                "android",
                "cygwin",
                "darwin",
                "freebsd",
                "haiku",
                "linux",
                "netbsd",
                "openbsd",
                "sunos",
                "win32"
            ],
            "type": "string"
        },
        "import(\"events\")<any>": {
            "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:",
            "type": "object"
        },
        "typeofDuplex": {
            "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Duplex"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofEventEmitterAsyncResource": {
            "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves.",
            "properties": {
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "prototype": {
                    "$ref": "#/definitions/EventEmitterAsyncResource"
                }
            },
            "required": [
                "EventEmitter",
                "EventEmitterAsyncResource",
                "captureRejectionSymbol",
                "captureRejections",
                "defaultMaxListeners",
                "errorMonitor",
                "prototype"
            ],
            "type": "object"
        },
        "typeofPassThrough": {
            "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams.",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/PassThrough"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofReadable": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Readable"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofStream": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Stream"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofTransform": {
            "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`",
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Transform"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofWritable": {
            "properties": {
                "Duplex": {
                    "$ref": "#/definitions/typeofDuplex",
                    "description": "Duplex streams are streams that implement both the `Readable` and `Writable` interfaces.\n\nExamples of `Duplex` streams include:\n\n* `TCP sockets`\n* `zlib streams`\n* `crypto streams`"
                },
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")",
                    "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "PassThrough": {
                    "$ref": "#/definitions/typeofPassThrough",
                    "description": "The `stream.PassThrough` class is a trivial implementation of a `Transform` stream that simply passes the input bytes across to the output. Its purpose is\nprimarily for examples and testing, but there are some use cases where `stream.PassThrough` is useful as a building block for novel sorts of streams."
                },
                "Readable": {
                    "$ref": "#/definitions/typeofReadable"
                },
                "Stream": {
                    "$ref": "#/definitions/typeofStream"
                },
                "Transform": {
                    "$ref": "#/definitions/typeofTransform",
                    "description": "Transform streams are `Duplex` streams where the output is in some way\nrelated to the input. Like all `Duplex` streams, `Transform` streams\nimplement both the `Readable` and `Writable` interfaces.\n\nExamples of `Transform` streams include:\n\n* `zlib streams`\n* `crypto streams`"
                },
                "Writable": {
                    "$ref": "#/definitions/typeofWritable"
                },
                "addAbortSignal": {
                    "description": "A stream to attach a signal to.\n\nAttaches an AbortSignal to a readable or writeable stream. This lets code\ncontrol stream destruction using an `AbortController`.\n\nCalling `abort` on the `AbortController` corresponding to the passed `AbortSignal` will behave the same way as calling `.destroy(new AbortError())` on the\nstream, and `controller.error(new AbortError())` for webstreams.\n\n```js\nimport fs from 'node:fs';\n\nconst controller = new AbortController();\nconst read = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n// Later, abort the operation closing the stream\ncontroller.abort();\n```\n\nOr using an `AbortSignal` with a readable stream as an async iterable:\n\n```js\nconst controller = new AbortController();\nsetTimeout(() => controller.abort(), 10_000); // set a timeout\nconst stream = addAbortSignal(\n  controller.signal,\n  fs.createReadStream(('object.json')),\n);\n(async () => {\n  try {\n    for await (const chunk of stream) {\n      await process(chunk);\n    }\n  } catch (e) {\n    if (e.name === 'AbortError') {\n      // The operation was cancelled\n    } else {\n      throw e;\n    }\n  }\n})();\n```\n\nOr using an `AbortSignal` with a ReadableStream:\n\n```js\nconst controller = new AbortController();\nconst rs = new ReadableStream({\n  start(controller) {\n    controller.enqueue('hello');\n    controller.enqueue('world');\n    controller.close();\n  },\n});\n\naddAbortSignal(controller.signal, rs);\n\nfinished(rs, (err) => {\n  if (err) {\n    if (err.name === 'AbortError') {\n      // The operation was cancelled\n    }\n  }\n});\n\nconst reader = rs.getReader();\n\nreader.read().then(({ value, done }) => {\n  console.log(value); // hello\n  console.log(done); // false\n  controller.abort();\n});\n```",
                    "type": "object"
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "consumers": {
                    "properties": {
                        "arrayBuffer": {
                            "type": "object"
                        },
                        "blob": {
                            "type": "object"
                        },
                        "buffer": {
                            "type": "object"
                        },
                        "json": {
                            "type": "object"
                        },
                        "text": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "arrayBuffer",
                        "blob",
                        "buffer",
                        "json",
                        "text"
                    ],
                    "type": "object"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "duplexPair": {
                    "description": "The utility function `duplexPair` returns an Array with two items,\neach being a `Duplex` stream connected to the other side:\n\n```js\nconst [ sideA, sideB ] = duplexPair();\n```\n\nWhatever is written to one stream is made readable on the other. It provides\nbehavior analogous to a network connection, where the data written by the client\nbecomes readable by the server, and vice-versa.\n\nThe Duplex streams are symmetrical; one or the other may be used without any\ndifference in behavior.",
                    "type": "object"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "finished": {
                    "description": "A readable and/or writable stream/webstream.\n\nA function to get notified when a stream is no longer readable, writable\nor has experienced an error or a premature close event.\n\n```js\nimport { finished } from 'node:stream';\nimport fs from 'node:fs';\n\nconst rs = fs.createReadStream('archive.tar');\n\nfinished(rs, (err) => {\n  if (err) {\n    console.error('Stream failed.', err);\n  } else {\n    console.log('Stream is done reading.');\n  }\n});\n\nrs.resume(); // Drain the stream.\n```\n\nEspecially useful in error handling scenarios where a stream is destroyed\nprematurely (like an aborted HTTP request), and will not emit `'end'` or `'finish'`.\n\nThe `finished` API provides [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamfinishedstream-options).\n\n`stream.finished()` leaves dangling event listeners (in particular `'error'`, `'end'`, `'finish'` and `'close'`) after `callback` has been\ninvoked. The reason for this is so that unexpected `'error'` events (due to\nincorrect stream implementations) do not cause unexpected crashes.\nIf this is unwanted behavior then the returned cleanup function needs to be\ninvoked in the callback:\n\n```js\nconst cleanup = finished(rs, (err) => {\n  cleanup();\n  // ...\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "getDefaultHighWaterMark": {
                    "description": "Returns the default highWaterMark used by streams.\nDefaults to `65536` (64 KiB), or `16` for `objectMode`.",
                    "type": "object"
                },
                "isErrored": {
                    "description": "Returns whether the stream has encountered an error.",
                    "type": "object"
                },
                "isReadable": {
                    "description": "Returns whether the stream is readable.",
                    "type": "object"
                },
                "pipeline": {
                    "description": "A module method to pipe between streams and generators forwarding errors and\nproperly cleaning up and provide a callback when the pipeline is complete.\n\n```js\nimport { pipeline } from 'node:stream';\nimport fs from 'node:fs';\nimport zlib from 'node:zlib';\n\n// Use the pipeline API to easily pipe a series of streams\n// together and get notified when the pipeline is fully done.\n\n// A pipeline to gzip a potentially huge tar file efficiently:\n\npipeline(\n  fs.createReadStream('archive.tar'),\n  zlib.createGzip(),\n  fs.createWriteStream('archive.tar.gz'),\n  (err) => {\n    if (err) {\n      console.error('Pipeline failed.', err);\n    } else {\n      console.log('Pipeline succeeded.');\n    }\n  },\n);\n```\n\nThe `pipeline` API provides a [`promise version`](https://nodejs.org/docs/latest-v22.x/api/stream.html#streampipelinesource-transforms-destination-options).\n\n`stream.pipeline()` will call `stream.destroy(err)` on all streams except:\n\n* `Readable` streams which have emitted `'end'` or `'close'`.\n* `Writable` streams which have emitted `'finish'` or `'close'`.\n\n`stream.pipeline()` leaves dangling event listeners on the streams\nafter the `callback` has been invoked. In the case of reuse of streams after\nfailure, this can cause event listener leaks and swallowed errors. If the last\nstream is readable, dangling event listeners will be removed so that the last\nstream can be consumed later.\n\n`stream.pipeline()` closes all the streams when an error is raised.\nThe `IncomingRequest` usage with `pipeline` could lead to an unexpected behavior\nonce it would destroy the socket without sending the expected response.\nSee the example below:\n\n```js\nimport fs from 'node:fs';\nimport http from 'node:http';\nimport { pipeline } from 'node:stream';\n\nconst server = http.createServer((req, res) => {\n  const fileStream = fs.createReadStream('./fileNotExist.txt');\n  pipeline(fileStream, res, (err) => {\n    if (err) {\n      console.log(err); // No such file\n      // this message can't be sent once `pipeline` already destroyed the socket\n      return res.end('error!!!');\n    }\n  });\n});\n```",
                    "properties": {
                        "__promisify__": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "__promisify__"
                    ],
                    "type": "object"
                },
                "promises": {
                    "properties": {
                        "finished": {
                            "type": "object"
                        },
                        "pipeline": {
                            "type": "object"
                        }
                    },
                    "required": [
                        "finished",
                        "pipeline"
                    ],
                    "type": "object"
                },
                "prototype": {
                    "$ref": "#/definitions/Writable"
                },
                "setDefaultHighWaterMark": {
                    "description": "Sets the default highWaterMark used by streams.",
                    "type": "object"
                }
            },
            "required": [
                "Duplex",
                "EventEmitter",
                "EventEmitterAsyncResource",
                "PassThrough",
                "Readable",
                "Stream",
                "Transform",
                "Writable",
                "addAbortSignal",
                "captureRejectionSymbol",
                "captureRejections",
                "consumers",
                "defaultMaxListeners",
                "duplexPair",
                "errorMonitor",
                "finished",
                "getDefaultHighWaterMark",
                "isErrored",
                "isReadable",
                "pipeline",
                "promises",
                "prototype",
                "setDefaultHighWaterMark"
            ],
            "type": "object"
        },
        "typeofcaptureRejectionSymbol": {
            "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`.",
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "required": [
                "__@toStringTag@25",
                "description"
            ],
            "type": "object"
        },
        "typeoferrorMonitor": {
            "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed.",
            "properties": {
                "__@toStringTag@25": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                }
            },
            "required": [
                "__@toStringTag@25",
                "description"
            ],
            "type": "object"
        },
        "typeofimport(\"events\")": {
            "description": "The `EventEmitter` class is defined and exposed by the `node:events` module:\n\n```js\nimport { EventEmitter } from 'node:events';\n```\n\nAll `EventEmitter`s emit the event `'newListener'` when new listeners are\nadded and `'removeListener'` when existing listeners are removed.\n\nIt supports the following option:",
            "properties": {
                "EventEmitter": {
                    "$ref": "#/definitions/typeofimport(\"events\")"
                },
                "EventEmitterAsyncResource": {
                    "$ref": "#/definitions/typeofEventEmitterAsyncResource",
                    "description": "Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that\nrequire manual async tracking. Specifically, all events emitted by instances\nof `events.EventEmitterAsyncResource` will run within its `async context`.\n\n```js\nimport { EventEmitterAsyncResource, EventEmitter } from 'node:events';\nimport { notStrictEqual, strictEqual } from 'node:assert';\nimport { executionAsyncId, triggerAsyncId } from 'node:async_hooks';\n\n// Async tracking tooling will identify this as 'Q'.\nconst ee1 = new EventEmitterAsyncResource({ name: 'Q' });\n\n// 'foo' listeners will run in the EventEmitters async context.\nee1.on('foo', () => {\n  strictEqual(executionAsyncId(), ee1.asyncId);\n  strictEqual(triggerAsyncId(), ee1.triggerAsyncId);\n});\n\nconst ee2 = new EventEmitter();\n\n// 'foo' listeners on ordinary EventEmitters that do not track async\n// context, however, run in the same async context as the emit().\nee2.on('foo', () => {\n  notStrictEqual(executionAsyncId(), ee2.asyncId);\n  notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);\n});\n\nPromise.resolve().then(() => {\n  ee1.emit('foo');\n  ee2.emit('foo');\n});\n```\n\nThe `EventEmitterAsyncResource` class has the same methods and takes the\nsame options as `EventEmitter` and `AsyncResource` themselves."
                },
                "captureRejectionSymbol": {
                    "$ref": "#/definitions/typeofcaptureRejectionSymbol",
                    "description": "Value: `Symbol.for('nodejs.rejection')`\n\nSee how to write a custom `rejection handler`."
                },
                "captureRejections": {
                    "description": "Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)\n\nChange the default `captureRejections` option on all new `EventEmitter` objects.",
                    "type": "boolean"
                },
                "defaultMaxListeners": {
                    "description": "By default, a maximum of `10` listeners can be registered for any single\nevent. This limit can be changed for individual `EventEmitter` instances\nusing the `emitter.setMaxListeners(n)` method. To change the default\nfor _all_`EventEmitter` instances, the `events.defaultMaxListeners` property\ncan be used. If this value is not a positive number, a `RangeError` is thrown.\n\nTake caution when setting the `events.defaultMaxListeners` because the\nchange affects _all_ `EventEmitter` instances, including those created before\nthe change is made. However, calling `emitter.setMaxListeners(n)` still has\nprecedence over `events.defaultMaxListeners`.\n\nThis is not a hard limit. The `EventEmitter` instance will allow\nmore listeners to be added but will output a trace warning to stderr indicating\nthat a \"possible EventEmitter memory leak\" has been detected. For any single\n`EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to\ntemporarily avoid this warning:\n\n```js\nimport { EventEmitter } from 'node:events';\nconst emitter = new EventEmitter();\nemitter.setMaxListeners(emitter.getMaxListeners() + 1);\nemitter.once('event', () => {\n  // do stuff\n  emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));\n});\n```\n\nThe `--trace-warnings` command-line flag can be used to display the\nstack trace for such warnings.\n\nThe emitted warning can be inspected with `process.on('warning')` and will\nhave the additional `emitter`, `type`, and `count` properties, referring to\nthe event emitter instance, the event's name and the number of attached\nlisteners, respectively.\nIts `name` property is set to `'MaxListenersExceededWarning'`.",
                    "type": "number"
                },
                "errorMonitor": {
                    "$ref": "#/definitions/typeoferrorMonitor",
                    "description": "This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no\nregular `'error'` listener is installed."
                },
                "prototype": {
                    "$ref": "#/definitions/import(\"events\")<any>"
                }
            },
            "required": [
                "EventEmitter",
                "EventEmitterAsyncResource",
                "captureRejectionSymbol",
                "captureRejections",
                "defaultMaxListeners",
                "errorMonitor",
                "prototype"
            ],
            "type": "object"
        },
        "{[x:string]:EntitySchemaColumnOptions|undefined;}": {
            "description": "Entity column's options.",
            "type": "object"
        },
        "{[x:string]:EntitySchemaEmbeddedColumnOptions;}": {
            "description": "Embedded Entities options",
            "type": "object"
        },
        "{[x:string]:EntitySchemaRelationIdOptions|undefined;}": {
            "description": "Entity relation id options.",
            "type": "object"
        },
        "{[x:string]:EntitySchemaRelationOptions|undefined;}": {
            "description": "Entity relation's options.",
            "type": "object"
        },
        "{deflate?:ZlibOptions|undefined;gzip?:ZlibOptions|undefined;}": {
            "properties": {
                "deflate": {
                    "$ref": "#/definitions/ZlibOptions"
                },
                "gzip": {
                    "$ref": "#/definitions/ZlibOptions"
                }
            },
            "type": "object"
        },
        "{deflate?:ZlibOptions|undefined;gzip?:ZlibOptions|undefined;}_1": {
            "properties": {
                "deflate": {
                    "$ref": "#/definitions/ZlibOptions"
                },
                "gzip": {
                    "$ref": "#/definitions/ZlibOptions"
                }
            },
            "type": "object"
        },
        "{error:default.LogFn;trace:default.LogFn;info:default.LogFn;warn:default.LogFn;debug:default.LogFn;fatal:default.LogFn;}": {
            "properties": {
                "debug": {
                    "$ref": "#/definitions/default.LogFn"
                },
                "error": {
                    "$ref": "#/definitions/default.LogFn"
                },
                "fatal": {
                    "$ref": "#/definitions/default.LogFn"
                },
                "info": {
                    "$ref": "#/definitions/default.LogFn"
                },
                "trace": {
                    "$ref": "#/definitions/default.LogFn"
                },
                "warn": {
                    "$ref": "#/definitions/default.LogFn"
                }
            },
            "required": [
                "debug",
                "error",
                "fatal",
                "info",
                "trace",
                "warn"
            ],
            "type": "object"
        },
        "{onPreAuth?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onCredentials?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostAuth?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPreHandler?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostHandler?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPreResponse?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;onPostResponse?:RouteExtObject<ReqRefDefaults>|RouteExtObject<ReqRefDefaults>[]|undefined;}": {
            "properties": {
                "onCredentials": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPostAuth": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPostHandler": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPostResponse": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPreAuth": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPreHandler": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                },
                "onPreResponse": {
                    "anyOf": [
                        {
                            "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                        },
                        {
                            "items": {
                                "$ref": "#/definitions/RouteExtObject<ReqRefDefaults>"
                            },
                            "type": "array"
                        }
                    ]
                }
            },
            "type": "object"
        },
        "{}_1": {
            "type": "object"
        },
        "{}_2": {
            "type": "object"
        }
    }
}

